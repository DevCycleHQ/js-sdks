{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","assembly/types/target.ts","assembly/types/featureConfiguration.ts","assembly/types/feature.ts","assembly/types/configBody.ts","assembly/types/bucketedUserConfig.ts","assembly/types/targetV2.ts","assembly/types/featureConfigurationV2.ts","assembly/types/featureV2.ts","assembly/managers/platformDataManager.ts","~lib/as-uuid/assembly/rng.ts","~lib/shared/runtime.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/arraybuffer.ts","~lib/util/error.ts","~lib/rt.ts","~lib/util/sort.ts","~lib/typedarray.ts","~lib/as-uuid/assembly/stringify.ts","~lib/util/hash.ts","~lib/set.ts","assembly/types/dvcEvent.ts","~lib/string.ts","assembly/types/protobuf-generated/CustomDataType.ts","~lib/as-proto/assembly/WireType.ts","~lib/as-proto/assembly/internal/FixedWriter.ts","~lib/as-proto/assembly/internal/FixedSizer.ts","~lib/as-proto/assembly/Protobuf.ts","~lib/as-proto/assembly/internal/FixedReader.ts","assembly/types/protobuf-generated/VariableType_PB.ts","assembly/helpers/murmurhash.ts","~lib/staticarray.ts","assembly/bucketing/versionCompare.ts","~lib/array.ts","~lib/builtins.ts","~lib/assemblyscript-regex/assembly/regexp.ts","~lib/assemblyscript-regex/assembly/parser/string-iterator.ts","~lib/assemblyscript-regex/assembly/parser/parser.ts","~lib/assemblyscript-regex/assembly/parser/node.ts","~lib/assemblyscript-regex/assembly/char.ts","~lib/assemblyscript-regex/assembly/util.ts","~lib/assemblyscript-regex/assembly/parser/walker.ts","~lib/number.ts","~lib/assemblyscript-regex/assembly/nfa/nfa.ts","~lib/assemblyscript-regex/assembly/nfa/matcher.ts","~lib/math.ts","~lib/assemblyscript-regex/assembly/nfa/walker.ts","assembly/bucketing/bucketing.ts","~lib/map.ts","assembly/managers/configDataManager.ts","assembly/managers/clientCustomDataManager.ts","assembly/eventQueue/eventQueue.ts","assembly/managers/eventQueueManager.ts","assembly/index.ts","assembly/helpers/stringHelpers.ts","~lib/@devcycle/assemblyscript-json/assembly/JSON.ts","assembly/types/dvcUser.ts","~lib/date.ts","~lib/@devcycle/assemblyscript-json/assembly/util/index.ts","~lib/@devcycle/assemblyscript-json/assembly/decoder.ts","assembly/helpers/jsonHelpers.ts","assembly/helpers/lodashHelpers.ts","~lib/memory.ts","~lib/console.ts","assembly/bucketing/segmentation.ts","assembly/types/configBodyV2.ts","assembly/types/protobuf-generated/VariableForUserParams_PB.ts","assembly/types/protobuf-generated/DVCUser_PB.ts","assembly/types/protobuf-generated/NullableString.ts","assembly/types/protobuf-generated/NullableDouble.ts","assembly/types/protobuf-generated/NullableCustomData.ts","assembly/types/protobuf-generated/CustomDataValue.ts","assembly/types/protobuf-generated/EvalReason_PB.ts","assembly/types/protobuf-generated/SDKVariable_PB.ts","assembly/types/platformData.ts","assembly/helpers/arrayHelpers.ts","~lib/util/bytes.ts","assembly/types/eventQueueOptions.ts","assembly/eventQueue/requestPayloadManager.ts","~lib/as-uuid/assembly/uuid.ts","~lib/as-uuid/assembly/v4.ts","assembly/testHelpers.ts","~lib/function.ts"],"names":[],"mappings":"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","sourceRoot":"./bucketing-lib.worker","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export let ROOT: Root = changetype<Root>(0); // unsafe initializion below\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  let head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  let prev = block.prev;\n  let next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  let slMap = GETSL(root, fl) & (~0 << sl);\n  let head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  let tail = GETTAIL(root);\n  let tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  let size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\n  let left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  let pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  let pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  let pagesBefore = memory.size();\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  let root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  let memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, block);\n  prepareBlock(root, block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let blockInfo = block.mmInfo;\n  let blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  let newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy let white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy let total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy let state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let iter: Object = changetype<Object>(0); // unsafe initializion below\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    let rtId = this.rtId;\n    // 0: Object, 1: ArrayBuffer, 2: String\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  let pn = pinSpace;\n  let iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  let ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  let obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  let newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  let budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getDateFromJSON,\n    getF64FromJSONObj,\n    getF64FromJSONOptional,\n    getJSONArrayFromJSON,\n    getJSONObjFromJSON,\n    getStringFromJSON,\n    getStringFromJSONOptional,\n    isValidString,\n    isValidStringOptional,\n    jsonArrFromValueArray\n} from '../helpers/jsonHelpers'\nimport { SortingArray, sortObjectsByString } from '../helpers/arrayHelpers'\n\nexport class Target extends JSON.Value {\n    readonly _id: string\n    readonly _audience: Audience\n    readonly rollout: Rollout | null\n    readonly distribution: TargetDistribution[]\n\n    private readonly _sortedDistribution: TargetDistribution[]\n\n    constructor(target: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(target, '_id')\n\n        this._audience = new Audience(getJSONObjFromJSON(target, '_audience'))\n\n        const rollout = target.getObj('rollout')\n        this.rollout = rollout ? new Rollout(rollout) : null\n\n        const distributionJSON = getJSONArrayFromJSON(target, 'distribution')\n        const distribution = distributionJSON.valueOf().map<TargetDistribution>((dist) => {\n            return new TargetDistribution(dist as JSON.Obj)\n        })\n        this.distribution = distribution\n\n        const sortingArray: SortingArray<TargetDistribution> = []\n        for (let i = 0; i < distribution.length; i++) {\n            sortingArray.push({\n                entry: distribution[i],\n                value: distribution[i]._variation\n            })\n        }\n\n        this._sortedDistribution = sortObjectsByString<TargetDistribution>(sortingArray, 'desc')\n    }\n\n    /**\n     * Given the feature and a hash of the user_id, bucket the user according to the variation distribution percentages\n     */\n    decideTargetVariation(boundedHash: f64): string {\n        let distributionIndex: f64 = 0\n        const previousDistributionIndex: f64 = 0\n        for (let i = 0; i < this._sortedDistribution.length; i++) {\n            const distribution = this._sortedDistribution[i]\n            distributionIndex += distribution.percentage\n            if (boundedHash >= previousDistributionIndex && \n                (boundedHash < distributionIndex || (distributionIndex == 1 && boundedHash == 1))) {\n                return distribution._variation\n            }\n        }\n        throw new Error(`Failed to decide target variation: ${this._id}`)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('_audience', this._audience)\n        if (this.rollout) {\n            json.set('rollout', this.rollout)\n        }\n        json.set('distribution', jsonArrFromValueArray(this.distribution))\n        return json.stringify()\n    }\n}\n\nexport class AudienceFilter extends JSON.Value {\n    type: string\n    constructor(filter: JSON.Obj) {\n        super()\n        this.type = isValidString(filter, 'type', validTypes, false)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        if (this.type) {\n            json.set('type', this.type)\n        }\n\n        return json.stringify()\n    }\n}\n// This is a virtual container class that's used by the code to determine whether a filter is a nested operator\n// or a base level filter. This is used to support the recursive nature of nested filters.\n// The config is returned to its original form when stringified.\nexport class AudienceFilterOrOperator extends JSON.Value {\n    readonly operatorClass: AudienceOperator | null\n    readonly filterClass: AudienceFilter | null\n\n    constructor(filter: JSON.Obj) {\n        super()\n        const operator = isValidStringOptional(filter, 'operator', validAudienceOperators, false)\n        this.operatorClass = operator ? new AudienceOperator(filter) : null\n        this.filterClass = operator ? null : initializeFilterClass(filter)\n    }\n\n    stringify(): string {\n        if (this.operatorClass !== null) {\n            return (this.operatorClass as AudienceOperator).stringify()\n        }\n        if (this.filterClass !== null) {\n            return (this.filterClass as AudienceFilter).stringify()\n        }\n        return ''\n    }\n}\n\nexport class AudienceOperator extends JSON.Value {\n    readonly operator: string\n    readonly filters: AudienceFilterOrOperator[]\n\n    constructor(filter: JSON.Obj) {\n        super()\n\n        this.operator = isValidString(filter, 'operator', validAudienceOperators, false)\n\n        const filters = getJSONArrayFromJSON(filter, 'filters')\n        // Initialize AudienceFilterOrOperator\n        this.filters = []\n        for (let i = 0; i < filters.valueOf().length; i ++) {\n            this.filters.push(new AudienceFilterOrOperator(filters.valueOf()[i] as JSON.Obj))\n        }\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        if (this.operator) {\n            json.set('operator', this.operator)\n        }\n        if (this.filters) {\n            json.set('filters', jsonArrFromValueArray(this.filters as AudienceFilterOrOperator[]))\n        }\n\n        return json.stringify()\n    }\n}\n\nexport class Audience extends JSON.Value {\n    readonly filters: AudienceOperator\n\n    constructor(audience: JSON.Obj) {\n        super()\n\n        this.filters = new AudienceOperator(getJSONObjFromJSON(audience, 'filters'))\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('filters', this.filters)\n        return json.stringify()\n    }\n}\n\nconst validAudienceOperators = ['and', 'or']\n\nconst validTypes = ['all', 'user', 'optIn', 'audienceMatch']\n\nexport const validSubTypes = [\n    'user_id', 'email', 'ip', 'country', 'platform',\n    'platformVersion', 'appVersion', 'deviceModel', 'customData'\n]\n\nexport const validComparators = [\n    '=', '!=', '>', '>=', '<', '<=', 'exist', '!exist', 'contain', '!contain', \n    'startWith', '!startWith', 'endWith', '!endWith' ]\n\nconst validAudienceMatchComparators = ['=', '!=']\nexport const validDataKeyTypes = [\n    'String', 'Boolean', 'Number'\n]\n\nexport class AudienceMatchFilter extends AudienceFilter {\n    readonly _audiences: JSON.Arr\n    readonly comparator: string\n    readonly isValid: bool\n\n    constructor(filter: JSON.Obj) {\n        super(filter)\n        this._audiences = getJSONArrayFromJSON(filter, '_audiences')\n        this.type = isValidString(filter, 'type', ['audienceMatch'], false)\n        this.comparator = isValidString(filter, 'comparator', validAudienceMatchComparators, false)\n        this.isValid = validAudienceMatchComparators.includes(this.comparator)\n    }\n    stringify(): string {\n        const json = new JSON.Obj()\n        if (this.comparator) {\n            json.set('comparator', this.comparator)\n        }\n        if (this._audiences) {\n            json.set('_audiences', this._audiences)\n        }\n        if (this.type) {\n            json.set('type', this.type)\n        }\n\n        return json.stringify()\n    }\n}\n\nexport class UserFilter extends AudienceFilter {\n    readonly subType: string\n    readonly values: JSON.Arr\n    readonly comparator: string\n    readonly isValid: bool\n\n    private _compiledStringValues: string[] | null = null\n    private _compiledBoolValues:  bool[] | null = null\n    private _compiledNumValues: number[] | null = null\n\n    constructor(filter: JSON.Obj) {\n        super(filter)\n        this.values = getJSONArrayFromJSON(filter, 'values')\n        this.subType = isValidString(filter, 'subType', validSubTypes, false)\n        this.comparator = isValidString(filter, 'comparator', validComparators, false)\n        this.isValid = validComparators.includes(this.comparator)\n\n        this.compileValues(this.values.valueOf())\n    }\n\n    compileValues(values: JSON.Value[]): void {\n        if (!values || values.length === 0) return\n        const firstValue = values[0]\n\n        if (firstValue.isBool) {\n            const boolValues = new Array<bool>()\n\n            for (let i=0; i < values.length; i++) {\n                const value = values[i]\n                if (!value.isBool) {\n                    console.log('[DevCycle] Warning: Filter values must be all of the same type. ' +\n                        `Expected: bool, got: ${value}`)\n                    continue\n                }\n\n                boolValues.push((value as JSON.Bool).valueOf())\n            }\n            this._compiledBoolValues = boolValues\n        } else if (firstValue.isString) {\n            const stringValues = new Array<string>()\n\n            for (let i=0; i < values.length; i++) {\n                const value = values[i]\n                if (!value.isString) {\n                    console.log('[DevCycle] Warning: Filter values must be all of the same type. ' +\n                        `Expected: string, got: ${value}`)\n                    continue\n                }\n\n                stringValues.push((value as JSON.Str).valueOf())\n            }\n            this._compiledStringValues = stringValues\n        } else if (firstValue.isFloat || firstValue.isInteger) {\n            const numValues = new Array<number>()\n\n            for (let i=0; i < values.length; i++) {\n                const value = values[i]\n                const float = value.isFloat ? value as JSON.Float : null\n                const int = value.isInteger ? value as JSON.Integer : null\n                if (float === null && int === null) {\n                    console.log('[DevCycle] Warning: Filter values must be all of the same type. ' +\n                        `Expected: number, got: ${value}`)\n                    continue\n                }\n\n                const numValue = float !== null\n                    ? (float as JSON.Float).valueOf()\n                    : (int !== null ? f64((int as JSON.Integer).valueOf()) : NaN)\n                if (!isNaN(numValue)) {\n                    numValues.push(numValue)\n                }\n            }\n            this._compiledNumValues = numValues\n        } else {\n            throw new Error(`Filter values of unknown type. ${firstValue}`)\n        }\n    }\n\n    getStringValues(): string[] {\n        return this._compiledStringValues !== null\n            ? this._compiledStringValues as string[]\n            : []\n    }\n\n    getBooleanValues(): bool[] {\n        return this._compiledBoolValues !== null\n            ? this._compiledBoolValues as bool[]\n            : []\n    }\n\n    getNumberValues(): number[] {\n        return this._compiledNumValues !== null\n            ? this._compiledNumValues as number[]\n            : []\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        if (this.type) {\n            json.set('type', this.type)\n        }\n        if (this.subType) {\n            json.set('subType', this.subType)\n        }\n        if (this.comparator) {\n            json.set('comparator', this.comparator)\n        }\n        if (this.values) {\n            json.set('values', this.values)\n        }\n        return json.stringify()\n    }\n}\n\nexport class CustomDataFilter extends UserFilter {\n    readonly dataKeyType: string\n    readonly dataKey: string\n\n    constructor(filter: JSON.Obj) {\n        super(filter)\n        this.dataKey = getStringFromJSON(filter, 'dataKey')\n        this.dataKeyType = isValidString(filter, 'dataKeyType', validDataKeyTypes)\n    }\n    stringify(): string {\n        const json = new JSON.Obj()\n        if (this.dataKey) {\n            json.set('dataKey', this.dataKey)\n        }\n        if (this.dataKeyType) {\n            json.set('dataKeyType', this.dataKeyType)\n        }\n        if (this.type) {\n            json.set('type', this.type)\n        }\n        if (this.subType) {\n            json.set('subType', this.subType)\n        }\n        if (this.comparator) {\n            json.set('comparator', this.comparator)\n        }\n        if (this.values) {\n            json.set('values', this.values)\n        }\n        return json.stringify()\n    }\n}\n\nfunction initializeFilterClass(filter: JSON.Obj): AudienceFilter {\n    if (getStringFromJSONOptional(filter, 'type') === 'user') {\n        if (getStringFromJSONOptional(filter, 'subType') === 'customData') {\n            return new CustomDataFilter(filter)\n        }\n        return new UserFilter(filter)\n    } else if (getStringFromJSONOptional(filter, 'type') === 'audienceMatch'){\n        return new AudienceMatchFilter(filter)\n    } else {\n        return new AudienceFilter(filter)\n    }\n}\n\nconst validRolloutTypes = ['schedule', 'gradual', 'stepped']\n\nexport class Rollout extends JSON.Value {\n    readonly type: string\n    readonly startPercentage: f64\n    readonly startDate: Date\n    readonly stages: RolloutStage[] | null\n\n    constructor(rollout: JSON.Obj) {\n        super()\n        this.type = isValidString(rollout, 'type', validRolloutTypes)\n\n        this.startPercentage = getF64FromJSONOptional(rollout, 'startPercentage', f64(1))\n\n        this.startDate = getDateFromJSON(rollout, 'startDate')\n\n        const stages = rollout.getArr('stages')\n        this.stages = stages ?\n            stages.valueOf().map<RolloutStage>((stage) => {\n                return new RolloutStage(stage as JSON.Obj)\n            }) : null\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('type', this.type)\n        json.set('startPercentage', this.startPercentage)\n        json.set('startDate', this.startDate.toISOString())\n        if (this.stages) {\n            json.set('stages', jsonArrFromValueArray(this.stages as RolloutStage[]))\n        }\n        return json.stringify()\n    }\n}\n\nconst validRolloutStages = ['linear', 'discrete']\n\nexport class RolloutStage extends JSON.Value {\n    readonly type: string\n    readonly date: Date\n    readonly percentage: f64\n\n    constructor(stage: JSON.Obj) {\n        super()\n        this.type = isValidString(stage, 'type', validRolloutStages)\n        this.date = getDateFromJSON(stage, 'date')\n        this.percentage = getF64FromJSONObj(stage, 'percentage')\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('type', this.type)\n        json.set('date', this.date.toISOString())\n        json.set('percentage', this.percentage)\n        return json.stringify()\n    }\n}\n\nexport class TargetDistribution extends JSON.Value {\n    readonly _variation: string\n    readonly percentage: f64\n\n    constructor(distribution: JSON.Obj) {\n        super()\n        this._variation = getStringFromJSON(distribution, '_variation')\n        this.percentage = getF64FromJSONObj(distribution, 'percentage')\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_variation', this._variation)\n        json.set('percentage', this.percentage)\n        return json.stringify()\n    }\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getDateFromJSON,\n    getJSONArrayFromJSON,\n    getStringFromJSON,\n    isValidString,\n    jsonArrFromValueArray,\n    jsonObjFromMap\n} from '../helpers/jsonHelpers'\nimport { Target } from './target'\n\nexport class FeatureConfiguration extends JSON.Value {\n    readonly _id: string\n    readonly prerequisites: FeaturePrerequisites[] | null\n    readonly winningVariation: FeatureWinningVariation | null\n    readonly forcedUsers: Map<string, string> | null\n    readonly targets: Target[]\n\n    constructor(featureConfig: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(featureConfig, '_id')\n\n        const prerequisites = featureConfig.getArr('prerequisites')\n        this.prerequisites = prerequisites ?\n            prerequisites.valueOf().map<FeaturePrerequisites>((preq) => {\n                return new FeaturePrerequisites(preq as JSON.Obj)\n            }) : null\n\n        const winningVar = featureConfig.getObj('winningVariation')\n        this.winningVariation = winningVar ? new FeatureWinningVariation(winningVar) : null\n\n        const targets = getJSONArrayFromJSON(featureConfig, 'targets')\n        this.targets = targets.valueOf().map<Target>((target) => new Target(target as JSON.Obj))\n\n        this.forcedUsers = null\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        if (this.prerequisites) {\n            json.set('prerequisites', jsonArrFromValueArray(this.prerequisites as FeaturePrerequisites[]))\n        }\n        if (this.winningVariation) {\n            json.set('winningVariation', this.winningVariation as FeatureWinningVariation)\n        }\n        if (this.forcedUsers) {\n            json.set('forcedUsers', jsonObjFromMap(this.forcedUsers as Map<string, string>))\n        }\n        json.set('targets', jsonArrFromValueArray(this.targets))\n        return json.stringify()\n    }\n}\n\nconst comparatorValues = ['=', '!=']\n\nexport class FeaturePrerequisites extends JSON.Value {\n    readonly _feature: string\n    readonly comparator: string\n\n    constructor(featurePrerequisites: JSON.Obj) {\n        super()\n\n        this._feature = getStringFromJSON(featurePrerequisites, '_feature')\n\n        this.comparator = isValidString(featurePrerequisites, 'comparator', comparatorValues)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_feature', this._feature)\n        json.set('comparator', this.comparator)\n        return json.stringify()\n    }\n}\n\nexport class FeatureWinningVariation extends JSON.Value {\n    readonly _variation: string\n    readonly updatedAt: Date\n\n    constructor(winningVar: JSON.Obj) {\n        super()\n        this._variation = getStringFromJSON(winningVar, '_variation')\n        this.updatedAt = getDateFromJSON(winningVar, 'updatedAt')\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_variation', this._variation)\n        json.set('updatedAt', this.updatedAt.toISOString())\n        return json.stringify()\n    }\n}\n\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getJSONArrayFromJSON,\n    getJSONObjFromJSON, getJSONObjFromJSONOptional, getJSONValueFromJSON,\n    getStringFromJSON,\n    isValidString,\n    jsonArrFromValueArray\n} from '../helpers/jsonHelpers'\nimport { FeatureConfiguration } from './featureConfiguration'\n\nconst validTypes = ['release', 'experiment', 'permission', 'ops']\n\nexport class Feature extends JSON.Value {\n    readonly _id: string\n    readonly type: string\n    readonly key: string\n    readonly variations: Variation[]\n    readonly configuration: FeatureConfiguration\n    readonly settings: JSON.Obj | null\n\n    private readonly _variationsById: Map<string, Variation>\n\n    constructor(feature: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(feature, '_id')\n\n        this.type = isValidString(feature, 'type', validTypes)\n\n        this.key = getStringFromJSON(feature, 'key')\n\n        const variationsJSON = getJSONArrayFromJSON(feature, 'variations').valueOf()\n        const variations = new Array<Variation>()\n        const variationsById = new Map<string, Variation>()\n        for (let i = 0; i < variationsJSON.length; i++) {\n            const variation = new Variation(variationsJSON[i] as JSON.Obj)\n            variations.push(variation)\n            variationsById.set(variation._id, variation)\n        }\n        this.variations = variations\n        this._variationsById = variationsById\n\n        this.configuration = new FeatureConfiguration(getJSONObjFromJSON(feature, 'configuration'))\n\n        this.settings = getJSONObjFromJSONOptional(feature, 'settings')\n    }\n\n    getVariationById(variationId: string): Variation | null {\n        if (!this._variationsById.has(variationId)) return null\n        return this._variationsById.get(variationId)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('type', this.type)\n        json.set('key', this.key)\n        json.set('variations', jsonArrFromValueArray(this.variations))\n        json.set('configuration', this.configuration)\n        return json.stringify()\n    }\n}\n\nexport class Variation extends JSON.Value {\n    readonly _id: string\n    readonly name: string\n    readonly key: string\n    readonly variables: Array<VariationVariable>\n\n    private readonly _variablesById: Map<string, VariationVariable>\n\n    constructor(variation: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(variation, '_id')\n\n        this.name = getStringFromJSON(variation, 'name')\n        this.key = getStringFromJSON(variation, 'key')\n\n        const variablesJSON = getJSONArrayFromJSON(variation, 'variables').valueOf()\n        const variables = new Array<VariationVariable>()\n        const variablesById = new Map<string, VariationVariable>()\n        for (let i = 0; i < variablesJSON.length; i++) {\n            const variable = new VariationVariable(variablesJSON[i] as JSON.Obj)\n            variables.push(variable)\n            variablesById.set(variable._var, variable)\n        }\n        this.variables = variables\n        this._variablesById = variablesById\n    }\n\n    getVariableById(variableId: string): VariationVariable | null {\n        return this._variablesById.has(variableId)\n            ? this._variablesById.get(variableId)\n            : null\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('name', this.name)\n        json.set('key', this.key)\n        json.set('variables', jsonArrFromValueArray(this.variables))\n\n        return json.stringify()\n    }\n}\n\nexport class VariationVariable extends JSON.Value {\n    readonly _var: string\n    readonly value: JSON.Value\n\n    constructor(variable: JSON.Obj) {\n        super()\n        this._var = getStringFromJSON(variable, '_var')\n        this.value = getJSONValueFromJSON(variable, 'value')\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_var', this._var)\n        json.set('value', this.value)\n        return json.stringify()\n    }\n}\n\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getStringFromJSON,\n    getJSONObjFromJSON,\n    getJSONArrayFromJSON,\n    jsonArrFromValueArray,\n    jsonObjFromMap,\n    isValidString,\n    getJSONObjFromJSONOptional,\n    getStringFromJSONOptional,\n    getBoolFromJSON\n} from '../helpers/jsonHelpers'\nimport { Feature } from './feature'\nimport { Audience } from './target'\n\nexport class Settings extends JSON.Value {\n    readonly disablePassthroughRollouts: bool\n\n    constructor(settings: JSON.Obj) {\n        super()\n        if (settings.has(\"disablePassthroughRollouts\")) {\n            this.disablePassthroughRollouts = getBoolFromJSON(settings, 'disablePassthroughRollouts')\n        } else {\n            this.disablePassthroughRollouts = false\n        }\n    }\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('disablePassthroughRollouts', this.disablePassthroughRollouts)\n        return json.stringify()\n    }\n}\n\nexport class PublicProject extends JSON.Value {\n    readonly _id: string\n    readonly key: string\n    readonly a0_organization: string\n    readonly settings: Settings\n\n    constructor(project: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(project, '_id')\n        this.key = getStringFromJSON(project, 'key')\n        this.a0_organization = getStringFromJSON(project, 'a0_organization')\n        this.settings = new Settings(getJSONObjFromJSON(project, 'settings'))\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('key', this.key)\n        json.set('a0_organization', this.a0_organization)\n        json.set('settings', this.settings)\n\n        return json.stringify()\n    }\n}\n\nexport class PublicEnvironment extends JSON.Value {\n    readonly _id: string\n    readonly key: string\n\n    constructor(environment: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(environment, '_id')\n        this.key = getStringFromJSON(environment, 'key')\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('key', this.key)\n        return json.stringify()\n    }\n}\n\nconst validVariableTypes = ['String', 'Boolean', 'Number', 'JSON']\n\nexport class Variable extends JSON.Value {\n    readonly _id: string\n    readonly type: string\n    readonly key: string\n\n    constructor(variable: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(variable, '_id')\n        this.type = isValidString(variable, 'type', validVariableTypes)\n        this.key = getStringFromJSON(variable, 'key')\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('type', this.type)\n        json.set('key', this.key)\n        return json.stringify()\n    }\n}\n\nexport class ConfigBody {\n    readonly project: PublicProject\n    readonly audiences: Map<string, Audience>\n    readonly environment: PublicEnvironment\n    readonly features: Feature[]\n    readonly variables: Variable[]\n    readonly etag: string | null\n    readonly clientSDKKey: string | null\n\n    private readonly _variableKeyMap: Map<string, Variable>\n    private readonly _variableIdMap: Map<string, Variable>\n    private readonly _variableIdToFeatureMap: Map<string, Feature>\n\n    static fromUTF8(\n        configUTF8: Uint8Array,\n        etag: string | null = null,\n    ): ConfigBody {\n        const configJSON = JSON.parse(configUTF8)\n        if (!configJSON.isObj) {\n            throw new Error(\n                'generateBucketedConfig config param not a JSON Object',\n            )\n        }\n        const configJSONObj = configJSON as JSON.Obj\n        return new ConfigBody(configJSONObj, etag)\n    }\n\n    static fromString(\n        configStr: string,\n        etag: string | null = null,\n    ): ConfigBody {\n        const configJSON = JSON.parse(configStr)\n        if (!configJSON.isObj) {\n            throw new Error(\n                'generateBucketedConfig config param not a JSON Object',\n            )\n        }\n        const configJSONObj = configJSON as JSON.Obj\n        return new ConfigBody(configJSONObj, etag)\n    }\n\n    constructor(configJSONObj: JSON.Obj, etag: string | null = null) {\n        this.etag = etag\n        this.clientSDKKey = getStringFromJSONOptional(\n            configJSONObj,\n            'clientSDKKey'\n        )\n        this.project = new PublicProject(\n            getJSONObjFromJSON(configJSONObj, 'project'),\n        )\n\n        this.environment = new PublicEnvironment(\n            getJSONObjFromJSON(configJSONObj, 'environment'),\n        )\n\n        const featuresJSON = getJSONArrayFromJSON(\n            configJSONObj,\n            'features',\n        ).valueOf()\n        const features = new Array<Feature>()\n        const _varIdToFeatureMap = new Map<string, Feature>()\n        const _featureIdMap = new Map<string, Feature>()\n\n        for (let i = 0; i < featuresJSON.length; i++) {\n            const feature = new Feature(featuresJSON[i] as JSON.Obj)\n            features.push(feature)\n\n            if (!_featureIdMap.has(feature._id)) {\n                _featureIdMap.set(feature._id, feature)\n            }\n\n            for (let j = 0; j < feature.variations.length; j++) {\n                for (\n                    let k = 0;\n                    k < feature.variations[j].variables.length;\n                    k++\n                ) {\n                    if (\n                        !_varIdToFeatureMap.has(\n                            feature.variations[j].variables[k]._var,\n                        )\n                    ) {\n                        _varIdToFeatureMap.set(\n                            feature.variations[j].variables[k]._var,\n                            feature,\n                        )\n                    }\n                }\n            }\n        }\n        this.features = features\n        this._variableIdToFeatureMap = _varIdToFeatureMap\n\n        const audiencesJSON = getJSONObjFromJSONOptional(\n            configJSONObj,\n            'audiences',\n        )\n        const audiences = new Map<string, Audience>()\n        if (audiencesJSON) {\n            const audienceKeys = audiencesJSON.keys\n            for (let i = 0; i < audienceKeys.length; i++) {\n                const audience_id = audienceKeys[i]\n                const aud = audiencesJSON.get(audience_id)\n                audiences.set(audience_id, new Audience(aud as JSON.Obj))\n            }\n        }\n        this.audiences = audiences\n\n        const variablesJSON = getJSONArrayFromJSON(\n            configJSONObj,\n            'variables',\n        ).valueOf()\n        const variables = new Array<Variable>()\n        const _variableKeyMap = new Map<string, Variable>()\n        const _variableIdMap = new Map<string, Variable>()\n        for (let i = 0; i < variablesJSON.length; i++) {\n            const variable = new Variable(variablesJSON[i] as JSON.Obj)\n            variables.push(variable)\n            _variableKeyMap.set(variable.key, variable)\n            _variableIdMap.set(variable._id, variable)\n        }\n        this.variables = variables\n        this._variableKeyMap = _variableKeyMap\n        this._variableIdMap = _variableIdMap\n    }\n\n    stringify(): string {\n        const json: JSON.Obj = new JSON.Obj()\n        json.set('project', this.project)\n        json.set('environment', this.environment)\n        json.set('audiences', jsonObjFromMap(this.audiences))\n        json.set('features', jsonArrFromValueArray(this.features))\n        json.set('variables', jsonArrFromValueArray(this.variables))\n        if (this.clientSDKKey) {\n            json.set('clientSDKKey', this.clientSDKKey)\n        }\n        return json.stringify()\n    }\n\n    getVariableForId(variable_id: string): Variable | null {\n        return this._variableIdMap.has(variable_id)\n            ? this._variableIdMap.get(variable_id)\n            : null\n    }\n\n    getVariableForKey(variableKey: string): Variable | null {\n        return this._variableKeyMap.has(variableKey)\n            ? this._variableKeyMap.get(variableKey)\n            : null\n    }\n\n    getFeatureForVariableId(variable_id: string): Feature | null {\n        return this._variableIdToFeatureMap.has(variable_id)\n            ? this._variableIdToFeatureMap.get(variable_id)\n            : null\n    }\n}\n\nexport class ConfigMetadata {\n    readonly project: ProjectMetadata\n    readonly environment: EnvironmentMetadata\n\n    constructor(project: PublicProject, environment: PublicEnvironment) {\n        this.project = new ProjectMetadata(project)\n        this.environment = new EnvironmentMetadata(environment)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        const project = new JSON.Obj()\n        project.set('id', this.project.id)\n        project.set('key', this.project.key)\n        const environment = new JSON.Obj()\n        environment.set('id', this.environment.id)\n        environment.set('key', this.environment.key)\n        json.set('project', project)\n        json.set('environment', environment)\n        return json.stringify()\n    }\n}\n\nexport class ProjectMetadata { \n    readonly id: string\n    readonly key: string\n\n    constructor(project: PublicProject) {\n        this.id = project._id\n        this.key = project.key\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('id', this.id)\n        json.set('key', this.key)\n        return json.stringify()\n    }\n}\n\nexport class EnvironmentMetadata {\n    readonly id: string\n    readonly key: string\n\n    constructor(environment: PublicEnvironment) {\n        this.id = environment._id\n        this.key = environment.key\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('id', this.id)\n        json.set('key', this.key)\n        return json.stringify()\n    }\n}","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getJSONObjFromJSON,\n    getJSONValueFromJSON,\n    getStringFromJSON,\n    getStringFromJSONOptional,\n    getStringMapFromJSONObj,\n    jsonObjFromMap\n} from '../helpers/jsonHelpers'\nimport { PublicProject, PublicEnvironment } from './configBody'\nimport {\n    NullableString,\n    SDKVariable_PB,\n    VariableType_PB,\n    EvalReason_PB,\n    encodeSDKVariable_PB,\n} from './'\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace DEFAULT_REASONS {\n    export const MISSING_CONFIG = 'MISSING_CONFIG'\n    export const MISSING_VARIABLE = 'MISSING_VARIABLE'\n    export const MISSING_FEATURE = 'MISSING_FEATURE'\n    export const MISSING_VARIATION = 'MISSING_VARIATION'\n    export const MISSING_VARIABLE_FOR_VARIATION = 'MISSING_VARIABLE_FOR_VARIATION'\n    export const USER_NOT_IN_ROLLOUT = 'USER_NOT_IN_ROLLOUT'\n    export const USER_NOT_TARGETED = 'USER_NOT_TARGETED'\n    export const INVALID_VARIABLE_TYPE = 'INVALID_VARIABLE_TYPE'\n    export const UNKNOWN = 'UNKNOWN'\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace EVAL_REASONS {\n    export const TARGETING_MATCH = 'TARGETING_MATCH'\n    export const SPLIT = 'SPLIT'\n    export const DEFAULT = 'DEFAULT'\n    export const DISABLED = 'DISABLED'\n    export const ERROR = 'ERROR'\n    export const OVERRIDE = 'OVERRIDE'\n    export const OPT_IN = 'OPT_IN'\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace EVAL_REASON_DETAILS {\n    // All Users\n    export const ALL_USERS = 'All Users'\n    // Audiences\n    export const AUDIENCE_MATCH = 'Audience Match'\n    export const NOT_IN_AUDIENCE = 'Not in Audience'\n    // Opt-In\n    export const OPT_IN = 'Opt-In'\n    export const NOT_OPTED_IN = 'Not Opt-In'\n    // Overrides\n    export const OVERRIDE = 'Override'\n    // Split details\n    export const RANDOM_DISTRIBUTION = 'Random Distribution'\n    export const ROLLOUT = 'Rollout'\n    // User Specific\n    export const USER_ID = 'User ID'\n    export const EMAIL = 'Email'\n    export const COUNTRY = 'Country'\n    export const PLATFORM = 'Platform'\n    export const PLATFORM_VERSION = 'Platform Version'\n    export const APP_VERSION = 'App Version'\n    export const DEVICE_MODEL = 'Device Model'\n    export const CUSTOM_DATA = 'Custom Data'\n}\n\nexport class EvalReason extends JSON.Value {\n    readonly reason: string\n    readonly details: string\n    readonly target_id: string\n\n    // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n    constructor(reason: string, details: string = \"\", target_id: string = \"\") {\n        super()\n        this.reason = reason\n        this.details = details\n        this.target_id = target_id\n    }\n\n    static fromJSONObj(jsonObj: JSON.Obj): EvalReason {\n        let reason = getStringFromJSONOptional(jsonObj, 'reason')\n        if (!reason) {\n            reason = \"\"\n        }\n        \n        let details = getStringFromJSONOptional(jsonObj, 'details')\n        if (!details) {\n            details = \"\"\n        }\n        \n        let targetId = getStringFromJSONOptional(jsonObj, 'targetId')\n        if (!targetId) {\n            targetId = \"\"\n        }\n        return new EvalReason(reason, details, targetId)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('reason', this.reason)\n        json.set('details', this.details)\n        json.set('target_id', this.target_id)\n        return json.stringify()\n    }\n}\n\nexport class FeatureVariation extends JSON.Obj {\n    constructor(\n        public readonly _feature: string,\n        public readonly _variation: string\n    ) {\n        super()\n    }\n\n    static fromJSONObj(jsonObj: JSON.Obj): FeatureVariation {\n        const _feature = jsonObj.getString('_feature')\n        const _variation = jsonObj.getString('_variation')\n        if (!_feature) throw new Error('Feature Variation missing _feature')\n        if (!_variation) throw new Error('Feature Variation missing _variation')\n        return new FeatureVariation(_feature.valueOf(), _variation.valueOf())\n    }\n\n    static getVariableVariationMapFromJSONObj(jsonObj: JSON.Obj): Map<string, FeatureVariation> {\n        const featureVarMap = new Map<string, FeatureVariation>()\n        const keys = jsonObj.keys\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i]\n            const featureVarJSON = jsonObj.getObj(key)\n            if (featureVarJSON) {\n                featureVarMap.set(key, this.fromJSONObj(featureVarJSON))\n            }\n        }\n\n        return featureVarMap\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_feature', this._feature)\n        json.set('_variation', this._variation)\n        return json.stringify()\n    }\n}\n\nexport class BucketedUserConfig extends JSON.Obj {\n    constructor(\n        public readonly project: PublicProject,\n        public readonly environment: PublicEnvironment,\n        public readonly features: Map<string, SDKFeature>,\n        public readonly featureVariationMap: Map<string, string>,\n        public readonly variableVariationMap: Map<string, FeatureVariation>,\n        public readonly variables: Map<string, SDKVariable>,\n    ) {\n        super()\n    }\n\n    /**\n     * Making this a method instead of constructor that we can use just for testing these models,\n     * these values will be generated from the bucketing code.\n     */\n    static fromJSONString(userConfigStr: string): BucketedUserConfig {\n        const userConfigJSON = JSON.parse(userConfigStr)\n        if (!userConfigJSON.isObj) throw new Error('bucketedUserConfigFromJSONString not a JSON Object')\n        const userConfigJSONObj = userConfigJSON as JSON.Obj\n\n        const project = new PublicProject(getJSONObjFromJSON(userConfigJSONObj, 'project'))\n\n        const environment = new PublicEnvironment(getJSONObjFromJSON(userConfigJSONObj, 'environment'))\n\n        const features = getJSONObjFromJSON(userConfigJSONObj, 'features')\n        const featuresMap = new Map<string, SDKFeature>()\n        for (let i = 0; i < features.keys.length; i++) {\n            const key = features.keys[i]\n            features.set(key, SDKFeature.fromJSONObj(features.get(key) as JSON.Obj))\n        }\n\n        const featureVar = getJSONObjFromJSON(userConfigJSONObj, 'featureVariationMap')\n        const featureVarMap = getStringMapFromJSONObj(featureVar)\n\n        const variableFeatureVariation = getJSONObjFromJSON(userConfigJSONObj, 'variableVariationMap')\n        const variableVariationMap = new Map<string, FeatureVariation>()\n        for (let i = 0; i < variableFeatureVariation.keys.length; i++) {\n            const key = variableFeatureVariation.keys[i]\n            const json = variableFeatureVariation.getObj(key)\n            if (!json) throw new Error('Missing FeatureVariation object in variableVariationMap')\n            variableVariationMap.set(key, FeatureVariation.fromJSONObj(json))\n        }\n\n        const variables = getJSONObjFromJSON(userConfigJSONObj, 'variables')\n        const variablesMap = new Map<string, SDKVariable>()\n        for (let i = 0; i < variables.keys.length; i++) {\n            const key = variables.keys[i]\n            variablesMap.set(key, SDKVariable.fromJSONObj(variables.get(key) as JSON.Obj))\n        }\n\n        return new BucketedUserConfig(\n            project,\n            environment,\n            featuresMap,\n            featureVarMap,\n            variableVariationMap,\n            variablesMap,\n        )\n    }\n\n    stringify(): string {\n        const json: JSON.Obj = new JSON.Obj()\n        json.set('project', this.project)\n        json.set('environment', this.environment)\n        json.set('features', jsonObjFromMap(this.features))\n        json.set('featureVariationMap', jsonObjFromMap(this.featureVariationMap))\n        json.set('variableVariationMap', jsonObjFromMap(this.variableVariationMap))\n        json.set('variables', jsonObjFromMap(this.variables))\n        return json.stringify()\n    }\n}\n\nexport class SDKFeature extends JSON.Obj {\n    constructor(\n        public readonly _id: string,\n        public readonly type: string,\n        public readonly key: string,\n        public readonly _variation: string,\n        public readonly variationName: string,\n        public readonly variationKey: string,\n        public readonly evalReason: EvalReason\n    ) {\n        super()\n    }\n\n    static fromJSONObj(featureObj: JSON.Obj): SDKFeature {\n        const evalObj = featureObj.getObj('eval') \n        const evalObjJSON =  evalObj ? evalObj : new JSON.Obj()\n        return new SDKFeature(\n            getStringFromJSON(featureObj, '_id'),\n            getStringFromJSON(featureObj, 'type'),\n            getStringFromJSON(featureObj, 'key'),\n            getStringFromJSON(featureObj, '_variation'),\n            getStringFromJSON(featureObj, 'variationName'),\n            getStringFromJSON(featureObj, 'variationKey'),\n            EvalReason.fromJSONObj(evalObjJSON)\n        )\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('type', this.type)\n        json.set('key', this.key)\n        json.set('_variation', this._variation)\n        json.set('variationName', this.variationName)\n        json.set('variationKey', this.variationKey)\n        // pb property is named eval for consistency with js lib\n        json.set('eval', this.evalReason)\n        return json.stringify()\n    }\n}\n\nexport class SDKVariable extends JSON.Obj {\n    constructor(\n        public readonly _id: string,\n        public readonly type: string,\n        public readonly key: string,\n        public readonly value: JSON.Value,\n        public readonly _feature: string | null,\n        public readonly evalReason: EvalReason,\n    ) {\n        super()\n    }\n\n    static fromJSONString(userConfigStr: string): SDKVariable {\n        const configJSON = JSON.parse(userConfigStr)\n        if (!configJSON.isObj) {\n            throw new Error('SDKVariable not a JSON Object')\n        }\n        const configJSONObj = configJSON as JSON.Obj\n        return SDKVariable.fromJSONObj(configJSONObj)\n    }\n\n    static fromJSONObj(variableObj: JSON.Obj): SDKVariable {\n        const evalObj = variableObj.getObj('eval') \n        const evalObjJSON =  evalObj ? evalObj : new JSON.Obj()\n\n        return new SDKVariable(\n            getStringFromJSON(variableObj, '_id'),\n            getStringFromJSON(variableObj, 'type'),\n            getStringFromJSON(variableObj, 'key'),\n            getJSONValueFromJSON(variableObj, 'value'),\n            getStringFromJSONOptional(variableObj, '_feature'),\n            EvalReason.fromJSONObj(evalObjJSON),\n        )\n    }\n\n    static variableTypeFromString(str: string): VariableType_PB {\n        if (str === 'Boolean') {\n            return VariableType_PB.Boolean\n        } else if (str === 'Number') {\n            return VariableType_PB.Number\n        } else if (str === 'String') {\n            return VariableType_PB.String\n        } else if (str === 'JSON') {\n            return VariableType_PB.JSON\n        } else {\n            throw new Error(`Unknown VariableType: ${str}`)\n        }\n    }\n\n    toProtobuf(): Uint8Array {\n        const boolValue = (this.type === 'Boolean' && this.value.isBool)\n            ? (this.value as JSON.Bool).valueOf()\n            : false\n        const numValue = (this.type === 'Number' && this.value.isInteger)\n            ? f64((this.value as JSON.Integer).valueOf())\n            : (this.type === 'Number' && this.value.isFloat) ? (this.value as JSON.Float).valueOf() : 0.0\n        const stringValue = (this.type === 'String' && this.value.isString)\n            ? (this.value as JSON.Str).valueOf()\n            : null\n        const jsonValue = (this.type === 'JSON' && this.value.isObj)\n            ? this.value.stringify()\n            : null\n\n        const evalReasonPb = new EvalReason_PB(\n            this.evalReason.reason,\n            this.evalReason.details,\n            this.evalReason.target_id\n        )\n\n        const pbVariable = new SDKVariable_PB(\n            this._id,\n            SDKVariable.variableTypeFromString(this.type),\n            this.key,\n            boolValue,\n            numValue,\n            stringValue || jsonValue || '',\n            new NullableString('', true),\n            new NullableString(this._feature || '', this._feature === null),\n            evalReasonPb,\n        )\n        return encodeSDKVariable_PB(pbVariable)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('type', this.type)\n        json.set('key', this.key)\n        json.set('value', this.value)\n        // pb property is named eval for consistency with js lib\n        json.set('eval', this.evalReason)\n        // set evalReason in proto for backward compatibility\n        if (this._feature) {\n            json.set('_feature', this._feature)\n        }\n        return json.stringify()\n    }\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getJSONArrayFromJSON,\n    getJSONObjFromJSON,\n    getStringFromJSON,\n    getStringFromJSONOptional,\n    isValidString,\n    jsonArrFromValueArray\n} from '../helpers/jsonHelpers'\nimport { SortingArray, sortObjectsByString } from '../helpers/arrayHelpers'\nimport { Audience, Rollout, TargetDistribution } from './target'\n\nexport class TargetV2 extends JSON.Value {\n    readonly _id: string\n    readonly _audience: Audience\n    readonly rollout: Rollout | null\n    readonly distribution: TargetDistribution[]\n    readonly bucketingKey: string\n    private readonly _sortedDistribution: TargetDistribution[]\n\n    constructor(target: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(target, '_id')\n\n        this._audience = new Audience(getJSONObjFromJSON(target, '_audience'))\n\n        const rollout = target.getObj('rollout')\n        this.rollout = rollout ? new Rollout(rollout) : null\n\n        const distributionJSON = getJSONArrayFromJSON(target, 'distribution')\n        const distribution = distributionJSON.valueOf().map<TargetDistribution>((dist) => {\n            return new TargetDistribution(dist as JSON.Obj)\n        })\n        this.distribution = distribution\n\n        const sortingArray: SortingArray<TargetDistribution> = []\n        for (let i = 0; i < distribution.length; i++) {\n            sortingArray.push({\n                entry: distribution[i],\n                value: distribution[i]._variation\n            })\n        }\n        const bucketingKey = getStringFromJSONOptional(target, 'bucketingKey')\n        if (bucketingKey) {\n            this.bucketingKey = bucketingKey\n        } else {\n            this.bucketingKey = 'user_id'\n        }\n        this._sortedDistribution = sortObjectsByString<TargetDistribution>(sortingArray, 'desc')\n    }\n\n    /**\n     * Given the feature and a hash of the user_id, bucket the user according to the variation distribution percentages\n     */\n    decideTargetVariation(boundedHash: f64): string {\n        let distributionIndex: f64 = 0\n        const previousDistributionIndex: f64 = 0\n        for (let i = 0; i < this._sortedDistribution.length; i++) {\n            const distribution = this._sortedDistribution[i]\n            distributionIndex += distribution.percentage\n            if (boundedHash >= previousDistributionIndex && \n                (boundedHash < distributionIndex || (distributionIndex == 1 && boundedHash == 1))) {\n                return distribution._variation\n            }\n        }\n        throw new Error(`Failed to decide target variation: ${this._id}`)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('_audience', this._audience)\n        if (this.rollout) {\n            json.set('rollout', this.rollout)\n        }\n        if (this.bucketingKey) {\n            json.set('bucketingKey', this.bucketingKey)\n        }\n        json.set('distribution', jsonArrFromValueArray(this.distribution))\n        return json.stringify()\n    }\n}\n\nexport class AudienceFilter extends JSON.Value {\n    type: string\n    constructor(filter: JSON.Obj) {\n        super()\n        this.type = isValidString(filter, 'type', validTypes, false)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        if (this.type) {\n            json.set('type', this.type)\n        }\n\n        return json.stringify()\n    }\n}\n\nconst validTypes = ['all', 'user', 'optIn', 'audienceMatch']\n\nexport const validSubTypes = [\n    'user_id', 'email', 'ip', 'country', 'platform',\n    'platformVersion', 'appVersion', 'deviceModel', 'customData'\n]\n\nexport const validComparators = [\n    '=', '!=', '>', '>=', '<', '<=', 'exist', '!exist', 'contain', '!contain',\n    'startWith', '!startWith', 'endWith', '!endWith'\n]\n\nconst validAudienceMatchComparators = ['=', '!=']\nexport const validDataKeyTypes = [\n    'String', 'Boolean', 'Number'\n]\n\nexport class AudienceMatchFilter extends AudienceFilter {\n    readonly _audiences: JSON.Arr\n    readonly comparator: string\n    readonly isValid: bool\n\n    constructor(filter: JSON.Obj) {\n        super(filter)\n        this._audiences = getJSONArrayFromJSON(filter, '_audiences')\n        this.type = isValidString(filter, 'type', ['audienceMatch'], false)\n        this.comparator = isValidString(filter, 'comparator', validAudienceMatchComparators, false)\n        this.isValid = validAudienceMatchComparators.includes(this.comparator)\n    }\n    stringify(): string {\n        const json = new JSON.Obj()\n        if (this.comparator) {\n            json.set('comparator', this.comparator)\n        }\n        if (this._audiences) {\n            json.set('_audiences', this._audiences)\n        }\n        if (this.type) {\n            json.set('type', this.type)\n        }\n\n        return json.stringify()\n    }\n}\n\nexport class UserFilter extends AudienceFilter {\n    readonly subType: string\n    readonly values: JSON.Arr\n    readonly comparator: string\n    readonly isValid: bool\n\n    private _compiledStringValues: string[] | null = null\n    private _compiledBoolValues:  bool[] | null = null\n    private _compiledNumValues: number[] | null = null\n\n    constructor(filter: JSON.Obj) {\n        super(filter)\n        this.values = getJSONArrayFromJSON(filter, 'values')\n        this.subType = isValidString(filter, 'subType', validSubTypes, false)\n        this.comparator = isValidString(filter, 'comparator', validComparators, false)\n        this.isValid = validComparators.includes(this.comparator)\n\n        this.compileValues(this.values.valueOf())\n    }\n\n    compileValues(values: JSON.Value[]): void {\n        if (!values || values.length === 0) return\n        const firstValue = values[0]\n\n        if (firstValue.isBool) {\n            const boolValues = new Array<bool>()\n\n            for (let i=0; i < values.length; i++) {\n                const value = values[i]\n                if (!value.isBool) {\n                    console.log('[DevCycle] Warning: Filter values must be all of the same type. ' +\n                        `Expected: bool, got: ${value}`)\n                    continue\n                }\n\n                boolValues.push((value as JSON.Bool).valueOf())\n            }\n            this._compiledBoolValues = boolValues\n        } else if (firstValue.isString) {\n            const stringValues = new Array<string>()\n\n            for (let i=0; i < values.length; i++) {\n                const value = values[i]\n                if (!value.isString) {\n                    console.log('[DevCycle] Warning: Filter values must be all of the same type. ' +\n                        `Expected: string, got: ${value}`)\n                    continue\n                }\n\n                stringValues.push((value as JSON.Str).valueOf())\n            }\n            this._compiledStringValues = stringValues\n        } else if (firstValue.isFloat || firstValue.isInteger) {\n            const numValues = new Array<number>()\n\n            for (let i=0; i < values.length; i++) {\n                const value = values[i]\n                const float = value.isFloat ? value as JSON.Float : null\n                const int = value.isInteger ? value as JSON.Integer : null\n                if (float === null && int === null) {\n                    console.log('[DevCycle] Warning: Filter values must be all of the same type. ' +\n                        `Expected: number, got: ${value}`)\n                    continue\n                }\n\n                const numValue = float !== null\n                    ? (float as JSON.Float).valueOf()\n                    : (int !== null ? f64((int as JSON.Integer).valueOf()) : NaN)\n                if (!isNaN(numValue)) {\n                    numValues.push(numValue)\n                }\n            }\n            this._compiledNumValues = numValues\n        } else {\n            throw new Error(`Filter values of unknown type. ${firstValue}`)\n        }\n    }\n\n    getStringValues(): string[] {\n        return this._compiledStringValues !== null\n            ? this._compiledStringValues as string[]\n            : []\n    }\n\n    getBooleanValues(): bool[] {\n        return this._compiledBoolValues !== null\n            ? this._compiledBoolValues as bool[]\n            : []\n    }\n\n    getNumberValues(): number[] {\n        return this._compiledNumValues !== null\n            ? this._compiledNumValues as number[]\n            : []\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        if (this.type) {\n            json.set('type', this.type)\n        }\n        if (this.subType) {\n            json.set('subType', this.subType)\n        }\n        if (this.comparator) {\n            json.set('comparator', this.comparator)\n        }\n        if (this.values) {\n            json.set('values', this.values)\n        }\n        return json.stringify()\n    }\n}\n\nexport class CustomDataFilter extends UserFilter {\n    readonly dataKeyType: string\n    readonly dataKey: string\n\n    constructor(filter: JSON.Obj) {\n        super(filter)\n        this.dataKey = getStringFromJSON(filter, 'dataKey')\n        this.dataKeyType = isValidString(filter, 'dataKeyType', validDataKeyTypes)\n    }\n    stringify(): string {\n        const json = new JSON.Obj()\n        if (this.dataKey) {\n            json.set('dataKey', this.dataKey)\n        }\n        if (this.dataKeyType) {\n            json.set('dataKeyType', this.dataKeyType)\n        }\n        if (this.type) {\n            json.set('type', this.type)\n        }\n        if (this.subType) {\n            json.set('subType', this.subType)\n        }\n        if (this.comparator) {\n            json.set('comparator', this.comparator)\n        }\n        if (this.values) {\n            json.set('values', this.values)\n        }\n        return json.stringify()\n    }\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getDateFromJSON,\n    getJSONArrayFromJSON,\n    getStringFromJSON,\n    isValidString,\n    jsonArrFromValueArray,\n    jsonObjFromMap\n} from '../helpers/jsonHelpers'\nimport { TargetV2 } from './targetV2'\n\nexport class FeatureConfigurationV2 extends JSON.Value {\n    readonly _id: string\n    readonly prerequisites: FeaturePrerequisites[] | null\n    readonly winningVariation: FeatureWinningVariation | null\n    readonly forcedUsers: Map<string, string> | null\n    readonly targets: TargetV2[]\n\n    constructor(featureConfig: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(featureConfig, '_id')\n\n        const prerequisites = featureConfig.getArr('prerequisites')\n        this.prerequisites = prerequisites ?\n            prerequisites.valueOf().map<FeaturePrerequisites>((preq) => {\n                return new FeaturePrerequisites(preq as JSON.Obj)\n            }) : null\n\n        const winningVar = featureConfig.getObj('winningVariation')\n        this.winningVariation = winningVar ? new FeatureWinningVariation(winningVar) : null\n\n        const targets = getJSONArrayFromJSON(featureConfig, 'targets')\n        this.targets = targets.valueOf().map<TargetV2>((target) => new TargetV2(target as JSON.Obj))\n\n        this.forcedUsers = null\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        if (this.prerequisites) {\n            json.set('prerequisites', jsonArrFromValueArray(this.prerequisites as FeaturePrerequisites[]))\n        }\n        if (this.winningVariation) {\n            json.set('winningVariation', this.winningVariation as FeatureWinningVariation)\n        }\n        if (this.forcedUsers) {\n            json.set('forcedUsers', jsonObjFromMap(this.forcedUsers as Map<string, string>))\n        }\n        json.set('targets', jsonArrFromValueArray(this.targets))\n        return json.stringify()\n    }\n}\n\nconst comparatorValues = ['=', '!=']\n\nexport class FeaturePrerequisites extends JSON.Value {\n    readonly _feature: string\n    readonly comparator: string\n\n    constructor(featurePrerequisites: JSON.Obj) {\n        super()\n\n        this._feature = getStringFromJSON(featurePrerequisites, '_feature')\n\n        this.comparator = isValidString(featurePrerequisites, 'comparator', comparatorValues)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_feature', this._feature)\n        json.set('comparator', this.comparator)\n        return json.stringify()\n    }\n}\n\nexport class FeatureWinningVariation extends JSON.Value {\n    readonly _variation: string\n    readonly updatedAt: Date\n\n    constructor(winningVar: JSON.Obj) {\n        super()\n        this._variation = getStringFromJSON(winningVar, '_variation')\n        this.updatedAt = getDateFromJSON(winningVar, 'updatedAt')\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_variation', this._variation)\n        json.set('updatedAt', this.updatedAt.toISOString())\n        return json.stringify()\n    }\n}\n\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getJSONArrayFromJSON,\n    getJSONObjFromJSON, getJSONObjFromJSONOptional,\n    getStringFromJSON,\n    isValidString,\n    jsonArrFromValueArray\n} from '../helpers/jsonHelpers'\nimport { FeatureConfigurationV2 } from './featureConfigurationV2'\nimport { Variation } from './feature'\n\nconst validTypes = ['release', 'experiment', 'permission', 'ops']\n\nexport class FeatureV2 extends JSON.Value {\n    readonly _id: string\n    readonly type: string\n    readonly key: string\n    readonly variations: Variation[]\n    readonly configuration: FeatureConfigurationV2\n    readonly settings: JSON.Obj | null\n\n    private readonly _variationsById: Map<string, Variation>\n\n    constructor(feature: JSON.Obj) {\n        super()\n        this._id = getStringFromJSON(feature, '_id')\n\n        this.type = isValidString(feature, 'type', validTypes)\n\n        this.key = getStringFromJSON(feature, 'key')\n\n        const variationsJSON = getJSONArrayFromJSON(feature, 'variations').valueOf()\n        const variations = new Array<Variation>()\n        const variationsById = new Map<string, Variation>()\n        for (let i = 0; i < variationsJSON.length; i++) {\n            const variation = new Variation(variationsJSON[i] as JSON.Obj)\n            variations.push(variation)\n            variationsById.set(variation._id, variation)\n        }\n        this.variations = variations\n        this._variationsById = variationsById\n\n        this.configuration = new FeatureConfigurationV2(getJSONObjFromJSON(feature, 'configuration'))\n\n        this.settings = getJSONObjFromJSONOptional(feature, 'settings')\n    }\n\n    getVariationById(variationId: string): Variation | null {\n        if (!this._variationsById.has(variationId)) return null\n        return this._variationsById.get(variationId)\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('_id', this._id)\n        json.set('type', this.type)\n        json.set('key', this.key)\n        json.set('variations', jsonArrFromValueArray(this.variations))\n        json.set('configuration', this.configuration)\n        return json.stringify()\n    }\n}\n","import { PlatformData } from '../types'\n\nlet _platformData: PlatformData | null = null\n\nexport function _setPlatformData(platformData: PlatformData): void {\n    _platformData = platformData\n}\n\nexport function _getPlatformData(): PlatformData {\n    if (_platformData === null) {\n        throw new Error('Platform data is not set.')\n    } else {\n        return _platformData as PlatformData\n    }\n}\n\nexport function _clearPlatformData(): void {\n    _platformData = null\n}\n","const CHUNK_SIZE = 16;\nconst POOL_SIZE = 256;\nconst rnds8Pool = new Uint8Array(POOL_SIZE); // random values to pre-allocate\nlet poolPtr = POOL_SIZE;\n\n/**\n * Gets an Uint8Array(16) filled with random values\n */\nexport default function rng(gen: (array: Uint8Array) => void = randomFill): Uint8Array {\n    if (poolPtr > POOL_SIZE - CHUNK_SIZE) {\n        gen(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.subarray(poolPtr, (poolPtr += CHUNK_SIZE));\n}\n\n/**\n * Default function to fill an array with random values\n */\nfunction randomFill(array: Uint8Array): void {\n    for (let i = 0; i < POOL_SIZE; i++) {\n        unchecked(array[i] = u8(Math.random() * 256));\n    }\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  let uv  = reinterpret<u64>(value);\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  let sid = uv & 0x000FFFFFFFFFFFFF;\n  let frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  let len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFDEFEC65B963019, // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  0x3FF571ED4AAF883D, 0xBFDB0B6832D4FCA4, // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  0x3FF49539F0F010B0, 0xBFD7418B0A1FB77B, // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  0x3FF3C995B0B80385, 0xBFD39DE91A6DCF7B, // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  0x3FF30D190C8864A5, 0xBFD01D9BF3F2B631, // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  0x3FF25E227B0B8EA0, 0xBFC97C1D1B3B7AF0, // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  0x3FF1BB4A4A1A343F, 0xBFC2F9E393AF3C9F, // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  0x3FF12358F08AE5BA, 0xBFB960CBBF788D5C, // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  0x3FF0953F419900A7, 0xBFAA6F9DB6475FCE, // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0x0,\n  0x3FEE608CFD9A47AC, 0x3FB338CA9F24F53D, // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  0x3FECA4B31F026AA0, 0x3FC476A9543891BA, // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  0x3FEB2036576AFCE6, 0x3FCE840B4AC4E4D2, // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  0x3FE9C2D163A1AA2D, 0x3FD40645F0C6651C, // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  0x3FE886E6037841ED, 0x3FD88E9C2C1B9FF8, // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  0x3FE767DCF5534862, 0x3FDCE0A44EB17BCC  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFD57BF7808CAADE, // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  0x3FF571ED4AAF883D, 0xBFD2BEF0A7C06DDB, // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  0x3FF49539F0F010B0, 0xBFD01EAE7F513A67, // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  0x3FF3C995B0B80385, 0xBFCB31D8A68224E9, // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  0x3FF30D190C8864A5, 0xBFC6574F0AC07758, // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  0x3FF25E227B0B8EA0, 0xBFC1AA2BC79C8100, // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  0x3FF1BB4A4A1A343F, 0xBFBA4E76CE8C0E5E, // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  0x3FF12358F08AE5BA, 0xBFB1973C5A611CCC, // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  0x3FF0953F419900A7, 0xBFA252F438E10C1E, // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0,\n  0x3FEE608CFD9A47AC, 0x3FAAA5AA5DF25984, // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  0x3FECA4B31F026AA0, 0x3FBC5E53AA362EB4, // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  0x3FEB2036576AFCE6, 0x3FC526E57720DB08, // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  0x3FE9C2D163A1AA2D, 0x3FCBC2860D224770, // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  0x3FE886E6037841ED, 0x3FD1058BC8A07EE1, // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  0x3FE767DCF5534862, 0x3FD4043057B6EE09  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<u64>([\n  //     invc       ,        logc\n  0x3FF724286BB1ACF8, 0xBFE1095FEECDB000,\n  0x3FF6E1F766D2CCA1, 0xBFE08494BD76D000,\n  0x3FF6A13D0E30D48A, 0xBFE00143AEE8F800,\n  0x3FF661EC32D06C85, 0xBFDEFEC5360B4000,\n  0x3FF623FA951198F8, 0xBFDDFDD91AB7E000,\n  0x3FF5E75BA4CF026C, 0xBFDCFFAE0CC79000,\n  0x3FF5AC055A214FB8, 0xBFDC043811FDA000,\n  0x3FF571ED0F166E1E, 0xBFDB0B67323AE000,\n  0x3FF53909590BF835, 0xBFDA152F5A2DB000,\n  0x3FF5014FED61ADDD, 0xBFD9217F5AF86000,\n  0x3FF4CAB88E487BD0, 0xBFD8304DB0719000,\n  0x3FF49539B4334FEE, 0xBFD74189F9A9E000,\n  0x3FF460CBDFAFD569, 0xBFD6552BB5199000,\n  0x3FF42D664EE4B953, 0xBFD56B23A29B1000,\n  0x3FF3FB01111DD8A6, 0xBFD483650F5FA000,\n  0x3FF3C995B70C5836, 0xBFD39DE937F6A000,\n  0x3FF3991C4AB6FD4A, 0xBFD2BAA1538D6000,\n  0x3FF3698E0CE099B5, 0xBFD1D98340CA4000,\n  0x3FF33AE48213E7B2, 0xBFD0FA853A40E000,\n  0x3FF30D191985BDB1, 0xBFD01D9C32E73000,\n  0x3FF2E025CAB271D7, 0xBFCE857DA2FA6000,\n  0x3FF2B404CF13CD82, 0xBFCCD3C8633D8000,\n  0x3FF288B02C7CCB50, 0xBFCB26034C14A000,\n  0x3FF25E2263944DE5, 0xBFC97C1C2F4FE000,\n  0x3FF234563D8615B1, 0xBFC7D6023F800000,\n  0x3FF20B46E33EAF38, 0xBFC633A71A05E000,\n  0x3FF1E2EEFDCDA3DD, 0xBFC494F5E9570000,\n  0x3FF1BB4A580B3930, 0xBFC2F9E424E0A000,\n  0x3FF19453847F2200, 0xBFC162595AFDC000,\n  0x3FF16E06C0D5D73C, 0xBFBF9C9A75BD8000,\n  0x3FF1485F47B7E4C2, 0xBFBC7B575BF9C000,\n  0x3FF12358AD0085D1, 0xBFB960C60FF48000,\n  0x3FF0FEF00F532227, 0xBFB64CE247B60000,\n  0x3FF0DB2077D03A8F, 0xBFB33F78B2014000,\n  0x3FF0B7E6D65980D9, 0xBFB0387D1A42C000,\n  0x3FF0953EFE7B408D, 0xBFAA6F9208B50000,\n  0x3FF07325CAC53B83, 0xBFA47A954F770000,\n  0x3FF05197E40D1B5C, 0xBF9D23A8C50C0000,\n  0x3FF03091C1208EA2, 0xBF916A2629780000,\n  0x3FF0101025B37E21, 0xBF7720F8D8E80000,\n  0x3FEFC07EF9CAA76B, 0x3F86FE53B1500000,\n  0x3FEF4465D3F6F184, 0x3FA11CCCE10F8000,\n  0x3FEECC079F84107F, 0x3FAC4DFC8C8B8000,\n  0x3FEE573A99975AE8, 0x3FB3AA321E574000,\n  0x3FEDE5D6F0BD3DE6, 0x3FB918A0D08B8000,\n  0x3FED77B681FF38B3, 0x3FBE72E9DA044000,\n  0x3FED0CB5724DE943, 0x3FC1DCD2507F6000,\n  0x3FECA4B2DC0E7563, 0x3FC476AB03DEA000,\n  0x3FEC3F8EE8D6CB51, 0x3FC7074377E22000,\n  0x3FEBDD2B4F020C4C, 0x3FC98EDE8BA94000,\n  0x3FEB7D6C006015CA, 0x3FCC0DB86AD2E000,\n  0x3FEB20366E2E338F, 0x3FCE840AAFCEE000,\n  0x3FEAC57026295039, 0x3FD0790AB4678000,\n  0x3FEA6D01BC2731DD, 0x3FD1AC056801C000,\n  0x3FEA16D3BC3FF18B, 0x3FD2DB11D4FEE000,\n  0x3FE9C2D14967FEAD, 0x3FD406464EC58000,\n  0x3FE970E4F47C9902, 0x3FD52DBE093AF000,\n  0x3FE920FB3982BCF2, 0x3FD651902050D000,\n  0x3FE8D30187F759F1, 0x3FD771D2CDEAF000,\n  0x3FE886E5EBB9F66D, 0x3FD88E9C857D9000,\n  0x3FE83C97B658B994, 0x3FD9A80155E16000,\n  0x3FE7F405FFC61022, 0x3FDABE186ED3D000,\n  0x3FE7AD22181415CA, 0x3FDBD0F2AEA0E000,\n  0x3FE767DCF99EFF8C, 0x3FDCE0A43DBF4000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE6200012B90A8E, 0x3C8904AB0644B605,\n  0x3FE66000045734A6, 0x3C61FF9BEA62F7A9,\n  0x3FE69FFFC325F2C5, 0x3C827ECFCB3C90BA,\n  0x3FE6E00038B95A04, 0x3C88FF8856739326,\n  0x3FE71FFFE09994E3, 0x3C8AFD40275F82B1,\n  0x3FE7600015590E10, 0xBC72FD75B4238341,\n  0x3FE7A00012655BD5, 0x3C7808E67C242B76,\n  0x3FE7E0003259E9A6, 0xBC6208E426F622B7,\n  0x3FE81FFFEDB4B2D2, 0xBC8402461EA5C92F,\n  0x3FE860002DFAFCC3, 0x3C6DF7F4A2F29A1F,\n  0x3FE89FFFF78C6B50, 0xBC8E0453094995FD,\n  0x3FE8E00039671566, 0xBC8A04F3BEC77B45,\n  0x3FE91FFFE2BF1745, 0xBC77FA34400E203C,\n  0x3FE95FFFCC5C9FD1, 0xBC76FF8005A0695D,\n  0x3FE9A0003BBA4767, 0x3C70F8C4C4EC7E03,\n  0x3FE9DFFFE7B92DA5, 0x3C8E7FD9478C4602,\n  0x3FEA1FFFD72EFDAF, 0xBC6A0C554DCDAE7E,\n  0x3FEA5FFFDE04FF95, 0x3C867DA98CE9B26B,\n  0x3FEA9FFFCA5E8D2B, 0xBC8284C9B54C13DE,\n  0x3FEADFFFDDAD03EA, 0x3C5812C8EA602E3C,\n  0x3FEB1FFFF10D3D4D, 0xBC8EFADDAD27789C,\n  0x3FEB5FFFCE21165A, 0x3C53CB1719C61237,\n  0x3FEB9FFFD950E674, 0x3C73F7D94194CE00,\n  0x3FEBE000139CA8AF, 0x3C750AC4215D9BC0,\n  0x3FEC20005B46DF99, 0x3C6BEEA653E9C1C9,\n  0x3FEC600040B9F7AE, 0xBC7C079F274A70D6,\n  0x3FECA0006255FD8A, 0xBC7A0B4076E84C1F,\n  0x3FECDFFFD94C095D, 0x3C88F933F99AB5D7,\n  0x3FED1FFFF975D6CF, 0xBC582C08665FE1BE,\n  0x3FED5FFFA2561C93, 0xBC7B04289BD295F3,\n  0x3FED9FFF9D228B0C, 0x3C870251340FA236,\n  0x3FEDE00065BC7E16, 0xBC75011E16A4D80C,\n  0x3FEE200002F64791, 0x3C89802F09EF62E0,\n  0x3FEE600057D7A6D8, 0xBC7E0B75580CF7FA,\n  0x3FEEA00027EDC00C, 0xBC8C848309459811,\n  0x3FEEE0006CF5CB7C, 0xBC8F8027951576F4,\n  0x3FEF2000782B7DCC, 0xBC8F81D97274538F,\n  0x3FEF6000260C450A, 0xBC4071002727FFDC,\n  0x3FEF9FFFE88CD533, 0xBC581BDCE1FDA8B0,\n  0x3FEFDFFFD50F8689, 0x3C87F91ACB918E6E,\n  0x3FF0200004292367, 0x3C9B7FF365324681,\n  0x3FF05FFFE3E3D668, 0x3C86FA08DDAE957B,\n  0x3FF0A0000A85A757, 0xBC57E2DE80D3FB91,\n  0x3FF0E0001A5F3FCC, 0xBC91823305C5F014,\n  0x3FF11FFFF8AFBAF5, 0xBC8BFABB6680BAC2,\n  0x3FF15FFFE54D91AD, 0xBC9D7F121737E7EF,\n  0x3FF1A00011AC36E1, 0x3C9C000A0516F5FF,\n  0x3FF1E00019C84248, 0xBC9082FBE4DA5DA0,\n  0x3FF220000FFE5E6E, 0xBC88FDD04C9CFB43,\n  0x3FF26000269FD891, 0x3C8CFE2A7994D182,\n  0x3FF2A00029A6E6DA, 0xBC700273715E8BC5,\n  0x3FF2DFFFE0293E39, 0x3C9B7C39DAB2A6F9,\n  0x3FF31FFFF7DCF082, 0x3C7DF1336EDC5254,\n  0x3FF35FFFF05A8B60, 0xBC9E03564CCD31EB,\n  0x3FF3A0002E0EAECC, 0x3C75F0E74BD3A477,\n  0x3FF3E000043BB236, 0x3C9C7DCB149D8833,\n  0x3FF4200002D187FF, 0x3C7E08AFCF2D3D28,\n  0x3FF460000D387CB1, 0x3C820837856599A6,\n  0x3FF4A00004569F89, 0xBC89FA5C904FBCD2,\n  0x3FF4E000043543F3, 0xBC781125ED175329,\n  0x3FF51FFFCC027F0F, 0x3C9883D8847754DC,\n  0x3FF55FFFFD87B36F, 0xBC8709E731D02807,\n  0x3FF59FFFF21DF7BA, 0x3C87F79F68727B02,\n  0x3FF5DFFFEBFC3481, 0xBC9180902E30E93E\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<u64>([\n  //      invc      ,        logc\n  0x3FF734F0C3E0DE9F, 0xBFD7CC7F79E69000,\n  0x3FF713786A2CE91F, 0xBFD76FEEC20D0000,\n  0x3FF6F26008FAB5A0, 0xBFD713E31351E000,\n  0x3FF6D1A61F138C7D, 0xBFD6B85B38287800,\n  0x3FF6B1490BC5B4D1, 0xBFD65D5590807800,\n  0x3FF69147332F0CBA, 0xBFD602D076180000,\n  0x3FF6719F18224223, 0xBFD5A8CA86909000,\n  0x3FF6524F99A51ED9, 0xBFD54F4356035000,\n  0x3FF63356AA8F24C4, 0xBFD4F637C36B4000,\n  0x3FF614B36B9DDC14, 0xBFD49DA7FDA85000,\n  0x3FF5F66452C65C4C, 0xBFD445923989A800,\n  0x3FF5D867B5912C4F, 0xBFD3EDF439B0B800,\n  0x3FF5BABCCB5B90DE, 0xBFD396CE448F7000,\n  0x3FF59D61F2D91A78, 0xBFD3401E17BDA000,\n  0x3FF5805612465687, 0xBFD2E9E2EF468000,\n  0x3FF56397CEE76BD3, 0xBFD2941B3830E000,\n  0x3FF54725E2A77F93, 0xBFD23EC58CDA8800,\n  0x3FF52AFF42064583, 0xBFD1E9E129279000,\n  0x3FF50F22DBB2BDDF, 0xBFD1956D2B48F800,\n  0x3FF4F38F4734DED7, 0xBFD141679AB9F800,\n  0x3FF4D843CFDE2840, 0xBFD0EDD094EF9800,\n  0x3FF4BD3EC078A3C8, 0xBFD09AA518DB1000,\n  0x3FF4A27FC3E0258A, 0xBFD047E65263B800,\n  0x3FF4880524D48434, 0xBFCFEB224586F000,\n  0x3FF46DCE1B192D0B, 0xBFCF474A7517B000,\n  0x3FF453D9D3391854, 0xBFCEA4443D103000,\n  0x3FF43A2744B4845A, 0xBFCE020D44E9B000,\n  0x3FF420B54115F8FB, 0xBFCD60A22977F000,\n  0x3FF40782DA3EF4B1, 0xBFCCC00104959000,\n  0x3FF3EE8F5D57FE8F, 0xBFCC202956891000,\n  0x3FF3D5D9A00B4CE9, 0xBFCB81178D811000,\n  0x3FF3BD60C010C12B, 0xBFCAE2C9CCD3D000,\n  0x3FF3A5242B75DAB8, 0xBFCA45402E129000,\n  0x3FF38D22CD9FD002, 0xBFC9A877681DF000,\n  0x3FF3755BC5847A1C, 0xBFC90C6D69483000,\n  0x3FF35DCE49AD36E2, 0xBFC87120A645C000,\n  0x3FF34679984DD440, 0xBFC7D68FB4143000,\n  0x3FF32F5CCEFFCB24, 0xBFC73CB83C627000,\n  0x3FF3187775A10D49, 0xBFC6A39A9B376000,\n  0x3FF301C8373E3990, 0xBFC60B3154B7A000,\n  0x3FF2EB4EBB95F841, 0xBFC5737D76243000,\n  0x3FF2D50A0219A9D1, 0xBFC4DC7B8FC23000,\n  0x3FF2BEF9A8B7FD2A, 0xBFC4462C51D20000,\n  0x3FF2A91C7A0C1BAB, 0xBFC3B08ABC830000,\n  0x3FF293726014B530, 0xBFC31B996B490000,\n  0x3FF27DFA5757A1F5, 0xBFC2875490A44000,\n  0x3FF268B39B1D3BBF, 0xBFC1F3B9F879A000,\n  0x3FF2539D838FF5BD, 0xBFC160C8252CA000,\n  0x3FF23EB7AAC9083B, 0xBFC0CE7F57F72000,\n  0x3FF22A012BA940B6, 0xBFC03CDC49FEA000,\n  0x3FF2157996CC4132, 0xBFBF57BDBC4B8000,\n  0x3FF201201DD2FC9B, 0xBFBE370896404000,\n  0x3FF1ECF4494D480B, 0xBFBD17983EF94000,\n  0x3FF1D8F5528F6569, 0xBFBBF9674ED8A000,\n  0x3FF1C52311577E7C, 0xBFBADC79202F6000,\n  0x3FF1B17C74CB26E9, 0xBFB9C0C3E7288000,\n  0x3FF19E010C2C1AB6, 0xBFB8A646B372C000,\n  0x3FF18AB07BB670BD, 0xBFB78D01B3AC0000,\n  0x3FF1778A25EFBCB6, 0xBFB674F145380000,\n  0x3FF1648D354C31DA, 0xBFB55E0E6D878000,\n  0x3FF151B990275FDD, 0xBFB4485CDEA1E000,\n  0x3FF13F0EA432D24C, 0xBFB333D94D6AA000,\n  0x3FF12C8B7210F9DA, 0xBFB22079F8C56000,\n  0x3FF11A3028ECB531, 0xBFB10E4698622000,\n  0x3FF107FBDA8434AF, 0xBFAFFA6C6AD20000,\n  0x3FF0F5EE0F4E6BB3, 0xBFADDA8D4A774000,\n  0x3FF0E4065D2A9FCE, 0xBFABBCECE4850000,\n  0x3FF0D244632CA521, 0xBFA9A1894012C000,\n  0x3FF0C0A77CE2981A, 0xBFA788583302C000,\n  0x3FF0AF2F83C636D1, 0xBFA5715E67D68000,\n  0x3FF09DDB98A01339, 0xBFA35C8A49658000,\n  0x3FF08CABAF52E7DF, 0xBFA149E364154000,\n  0x3FF07B9F2F4E28FB, 0xBF9E72C082EB8000,\n  0x3FF06AB58C358F19, 0xBF9A55F152528000,\n  0x3FF059EEA5ECF92C, 0xBF963D62CF818000,\n  0x3FF04949CDD12C90, 0xBF9228FB8CAA0000,\n  0x3FF038C6C6F0ADA9, 0xBF8C317B20F90000,\n  0x3FF02865137932A9, 0xBF8419355DAA0000,\n  0x3FF0182427EA7348, 0xBF781203C2EC0000,\n  0x3FF008040614B195, 0xBF60040979240000,\n  0x3FEFE01FF726FA1A, 0x3F6FEFF384900000,\n  0x3FEFA11CC261EA74, 0x3F87DC41353D0000,\n  0x3FEF6310B081992E, 0x3F93CEA3C4C28000,\n  0x3FEF25F63CEEADCD, 0x3F9B9FC114890000,\n  0x3FEEE9C8039113E7, 0x3FA1B0D8CE110000,\n  0x3FEEAE8078CBB1AB, 0x3FA58A5BD001C000,\n  0x3FEE741AA29D0C9B, 0x3FA95C8340D88000,\n  0x3FEE3A91830A99B5, 0x3FAD276AEF578000,\n  0x3FEE01E009609A56, 0x3FB07598E598C000,\n  0x3FEDCA01E577BB98, 0x3FB253F5E30D2000,\n  0x3FED92F20B7C9103, 0x3FB42EDD8B380000,\n  0x3FED5CAC66FB5CCE, 0x3FB606598757C000,\n  0x3FED272CAA5EDE9D, 0x3FB7DA76356A0000,\n  0x3FECF26E3E6B2CCD, 0x3FB9AB434E1C6000,\n  0x3FECBE6DA2A77902, 0x3FBB78C7BB0D6000,\n  0x3FEC8B266D37086D, 0x3FBD431332E72000,\n  0x3FEC5894BD5D5804, 0x3FBF0A3171DE6000,\n  0x3FEC26B533BB9F8C, 0x3FC067152B914000,\n  0x3FEBF583EEECE73F, 0x3FC147858292B000,\n  0x3FEBC4FD75DB96C1, 0x3FC2266ECDCA3000,\n  0x3FEB951E0C864A28, 0x3FC303D7A6C55000,\n  0x3FEB65E2C5EF3E2C, 0x3FC3DFC33C331000,\n  0x3FEB374867C9888B, 0x3FC4BA366B7A8000,\n  0x3FEB094B211D304A, 0x3FC5933928D1F000,\n  0x3FEADBE885F2EF7E, 0x3FC66ACD2418F000,\n  0x3FEAAF1D31603DA2, 0x3FC740F8EC669000,\n  0x3FEA82E63FD358A7, 0x3FC815C0F51AF000,\n  0x3FEA5740EF09738B, 0x3FC8E92954F68000,\n  0x3FEA2C2A90AB4B27, 0x3FC9BB3602F84000,\n  0x3FEA01A01393F2D1, 0x3FCA8BED1C2C0000,\n  0x3FE9D79F24DB3C1B, 0x3FCB5B515C01D000,\n  0x3FE9AE2505C7B190, 0x3FCC2967CCBCC000,\n  0x3FE9852EF297CE2F, 0x3FCCF635D5486000,\n  0x3FE95CBAEEA44B75, 0x3FCDC1BD3446C000,\n  0x3FE934C69DE74838, 0x3FCE8C01B8CFE000,\n  0x3FE90D4F2F6752E6, 0x3FCF5509C0179000,\n  0x3FE8E6528EFFD79D, 0x3FD00E6C121FB800,\n  0x3FE8BFCE9FCC007C, 0x3FD071B80E93D000,\n  0x3FE899C0DABEC30E, 0x3FD0D46B9E867000,\n  0x3FE87427AA2317FB, 0x3FD13687334BD000,\n  0x3FE84F00ACB39A08, 0x3FD1980D67234800,\n  0x3FE82A49E8653E55, 0x3FD1F8FFE0CC8000,\n  0x3FE8060195F40260, 0x3FD2595FD7636800,\n  0x3FE7E22563E0A329, 0x3FD2B9300914A800,\n  0x3FE7BEB377DCB5AD, 0x3FD3187210436000,\n  0x3FE79BAA679725C2, 0x3FD377266DEC1800,\n  0x3FE77907F2170657, 0x3FD3D54FFBAF3000,\n  0x3FE756CADBD6130C, 0x3FD432EEE32FE000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE61000014FB66B, 0x3C7E026C91425B3C,\n  0x3FE63000034DB495, 0x3C8DBFEA48005D41,\n  0x3FE650000D94D478, 0x3C8E7FA786D6A5B7,\n  0x3FE67000074E6FAD, 0x3C61FCEA6B54254C,\n  0x3FE68FFFFEDF0FAE, 0xBC7C7E274C590EFD,\n  0x3FE6B0000763C5BC, 0xBC8AC16848DCDA01,\n  0x3FE6D0001E5CC1F6, 0x3C833F1C9D499311,\n  0x3FE6EFFFEB05F63E, 0xBC7E80041AE22D53,\n  0x3FE710000E869780, 0x3C7BFF6671097952,\n  0x3FE72FFFFC67E912, 0x3C8C00E226BD8724,\n  0x3FE74FFFDF81116A, 0xBC6E02916EF101D2,\n  0x3FE770000F679C90, 0xBC67FC71CD549C74,\n  0x3FE78FFFFA7EC835, 0x3C81BEC19EF50483,\n  0x3FE7AFFFFE20C2E6, 0xBC707E1729CC6465,\n  0x3FE7CFFFED3FC900, 0xBC808072087B8B1C,\n  0x3FE7EFFFE9261A76, 0x3C8DC0286D9DF9AE,\n  0x3FE81000049CA3E8, 0x3C897FD251E54C33,\n  0x3FE8300017932C8F, 0xBC8AFEE9B630F381,\n  0x3FE850000633739C, 0x3C89BFBF6B6535BC,\n  0x3FE87000204289C6, 0xBC8BBF65F3117B75,\n  0x3FE88FFFEBF57904, 0xBC89006EA23DCB57,\n  0x3FE8B00022BC04DF, 0xBC7D00DF38E04B0A,\n  0x3FE8CFFFE50C1B8A, 0xBC88007146FF9F05,\n  0x3FE8EFFFFC918E43, 0x3C83817BD07A7038,\n  0x3FE910001EFA5FC7, 0x3C893E9176DFB403,\n  0x3FE9300013467BB9, 0x3C7F804E4B980276,\n  0x3FE94FFFE6EE076F, 0xBC8F7EF0D9FF622E,\n  0x3FE96FFFDE3C12D1, 0xBC7082AA962638BA,\n  0x3FE98FFFF4458A0D, 0xBC87801B9164A8EF,\n  0x3FE9AFFFDD982E3E, 0xBC8740E08A5A9337,\n  0x3FE9CFFFED49FB66, 0x3C3FCE08C19BE000,\n  0x3FE9F00020F19C51, 0xBC8A3FAA27885B0A,\n  0x3FEA10001145B006, 0x3C74FF489958DA56,\n  0x3FEA300007BBF6FA, 0x3C8CBEAB8A2B6D18,\n  0x3FEA500010971D79, 0x3C88FECADD787930,\n  0x3FEA70001DF52E48, 0xBC8F41763DD8ABDB,\n  0x3FEA90001C593352, 0xBC8EBF0284C27612,\n  0x3FEAB0002A4F3E4B, 0xBC69FD043CFF3F5F,\n  0x3FEACFFFD7AE1ED1, 0xBC823EE7129070B4,\n  0x3FEAEFFFEE510478, 0x3C6A063EE00EDEA3,\n  0x3FEB0FFFDB650D5B, 0x3C5A06C8381F0AB9,\n  0x3FEB2FFFFEAACA57, 0xBC79011E74233C1D,\n  0x3FEB4FFFD995BADC, 0xBC79FF1068862A9F,\n  0x3FEB7000249E659C, 0x3C8AFF45D0864F3E,\n  0x3FEB8FFFF9871640, 0x3C7CFE7796C2C3F9,\n  0x3FEBAFFFD204CB4F, 0xBC63FF27EEF22BC4,\n  0x3FEBCFFFD2415C45, 0xBC6CFFB7EE3BEA21,\n  0x3FEBEFFFF86309DF, 0xBC814103972E0B5C,\n  0x3FEC0FFFE1B57653, 0x3C8BC16494B76A19,\n  0x3FEC2FFFF1FA57E3, 0xBC64FEEF8D30C6ED,\n  0x3FEC4FFFDCBFE424, 0xBC843F68BCEC4775,\n  0x3FEC6FFFED54B9F7, 0x3C847EA3F053E0EC,\n  0x3FEC8FFFEB998FD5, 0x3C7383068DF992F1,\n  0x3FECB0002125219A, 0xBC68FD8E64180E04,\n  0x3FECCFFFDD94469C, 0x3C8E7EBE1CC7EA72,\n  0x3FECEFFFEAFDC476, 0x3C8EBE39AD9F88FE,\n  0x3FED1000169AF82B, 0x3C757D91A8B95A71,\n  0x3FED30000D0FF71D, 0x3C89C1906970C7DA,\n  0x3FED4FFFEA790FC4, 0xBC580E37C558FE0C,\n  0x3FED70002EDC87E5, 0xBC7F80D64DC10F44,\n  0x3FED900021DC82AA, 0xBC747C8F94FD5C5C,\n  0x3FEDAFFFD86B0283, 0x3C8C7F1DC521617E,\n  0x3FEDD000296C4739, 0x3C88019EB2FFB153,\n  0x3FEDEFFFE54490F5, 0x3C6E00D2C652CC89,\n  0x3FEE0FFFCDABF694, 0xBC7F8340202D69D2,\n  0x3FEE2FFFDB52C8DD, 0x3C7B00C1CA1B0864,\n  0x3FEE4FFFF24216EF, 0x3C72FFA8B094AB51,\n  0x3FEE6FFFE88A5E11, 0xBC57F673B1EFBE59,\n  0x3FEE9000119EFF0D, 0xBC84808D5E0BC801,\n  0x3FEEAFFFDFA51744, 0x3C780006D54320B5,\n  0x3FEED0001A127FA1, 0xBC5002F860565C92,\n  0x3FEEF00007BABCC4, 0xBC8540445D35E611,\n  0x3FEF0FFFF57A8D02, 0xBC4FFB3139EF9105,\n  0x3FEF30001EE58AC7, 0x3C8A81ACF2731155,\n  0x3FEF4FFFF5823494, 0x3C8A3F41D4D7C743,\n  0x3FEF6FFFFCA94C6B, 0xBC6202F41C987875,\n  0x3FEF8FFFE1F9C441, 0x3C777DD1F477E74B,\n  0x3FEFAFFFD2E0E37E, 0xBC6F01199A7CA331,\n  0x3FEFD0001C77E49E, 0x3C7181EE4BCEACB1,\n  0x3FEFEFFFF7E0C331, 0xBC6E05370170875A,\n  0x3FF00FFFF465606E, 0xBC8A7EAD491C0ADA,\n  0x3FF02FFFF3867A58, 0xBC977F69C3FCB2E0,\n  0x3FF04FFFFDFC0D17, 0x3C97BFFE34CB945B,\n  0x3FF0700003CD4D82, 0x3C820083C0E456CB,\n  0x3FF08FFFF9F2CBE8, 0xBC6DFFDFBE37751A,\n  0x3FF0B000010CDA65, 0xBC913F7FAEE626EB,\n  0x3FF0D00001A4D338, 0x3C807DFA79489FF7,\n  0x3FF0EFFFFADAFDFD, 0xBC77040570D66BC0,\n  0x3FF110000BBAFD96, 0x3C8E80D4846D0B62,\n  0x3FF12FFFFAE5F45D, 0x3C9DBFFA64FD36EF,\n  0x3FF150000DD59AD9, 0x3C9A0077701250AE,\n  0x3FF170000F21559A, 0x3C8DFDF9E2E3DEEE,\n  0x3FF18FFFFC275426, 0x3C910030DC3B7273,\n  0x3FF1B000123D3C59, 0x3C997F7980030188,\n  0x3FF1CFFFF8299EB7, 0xBC65F932AB9F8C67,\n  0x3FF1EFFFF48AD400, 0x3C937FBF9DA75BEB,\n  0x3FF210000C8B86A4, 0x3C9F806B91FD5B22,\n  0x3FF2300003854303, 0x3C93FFC2EB9FBF33,\n  0x3FF24FFFFFBCF684, 0x3C7601E77E2E2E72,\n  0x3FF26FFFF52921D9, 0x3C7FFCBB767F0C61,\n  0x3FF2900014933A3C, 0xBC7202CA3C02412B,\n  0x3FF2B00014556313, 0xBC92808233F21F02,\n  0x3FF2CFFFEBFE523B, 0xBC88FF7E384FDCF2,\n  0x3FF2F0000BB8AD96, 0xBC85FF51503041C5,\n  0x3FF30FFFFB7AE2AF, 0xBC810071885E289D,\n  0x3FF32FFFFEAC5F7F, 0xBC91FF5D3FB7B715,\n  0x3FF350000CA66756, 0x3C957F82228B82BD,\n  0x3FF3700011FBF721, 0x3C8000BAC40DD5CC,\n  0x3FF38FFFF9592FB9, 0xBC943F9D2DB2A751,\n  0x3FF3B00004DDD242, 0x3C857F6B707638E1,\n  0x3FF3CFFFF5B2C957, 0x3C7A023A10BF1231,\n  0x3FF3EFFFEAB0B418, 0x3C987F6D66B152B0,\n  0x3FF410001532AFF4, 0x3C67F8375F198524,\n  0x3FF4300017478B29, 0x3C8301E672DC5143,\n  0x3FF44FFFE795B463, 0x3C89FF69B8B2895A,\n  0x3FF46FFFE80475E0, 0xBC95C0B19BC2F254,\n  0x3FF48FFFEF6FC1E7, 0x3C9B4009F23A2A72,\n  0x3FF4AFFFE5BEA704, 0xBC94FFB7BF0D7D45,\n  0x3FF4D000171027DE, 0xBC99C06471DC6A3D,\n  0x3FF4F0000FF03EE2, 0x3C977F890B85531C,\n  0x3FF5100012DC4BD1, 0x3C6004657166A436,\n  0x3FF530001605277A, 0xBC96BFCECE233209,\n  0x3FF54FFFECDB704C, 0xBC8902720505A1D7,\n  0x3FF56FFFEF5F54A9, 0x3C9BBFE60EC96412,\n  0x3FF5900017E61012, 0x3C887EC581AFEF90,\n  0x3FF5B00003C93E92, 0xBC9F41080ABF0CC0,\n  0x3FF5D0001D4919BC, 0xBC98812AFB254729,\n  0x3FF5EFFFE7B87A89, 0xBC947EB780ED6904\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<u64>([\n  //      invc      ,pad,       logc       ,       logctail\n  0x3FF6A00000000000, 0, 0xBFD62C82F2B9C800, 0x3CFAB42428375680,\n  0x3FF6800000000000, 0, 0xBFD5D1BDBF580800, 0xBD1CA508D8E0F720,\n  0x3FF6600000000000, 0, 0xBFD5767717455800, 0xBD2362A4D5B6506D,\n  0x3FF6400000000000, 0, 0xBFD51AAD872DF800, 0xBCE684E49EB067D5,\n  0x3FF6200000000000, 0, 0xBFD4BE5F95777800, 0xBD041B6993293EE0,\n  0x3FF6000000000000, 0, 0xBFD4618BC21C6000, 0x3D13D82F484C84CC,\n  0x3FF5E00000000000, 0, 0xBFD404308686A800, 0x3CDC42F3ED820B3A,\n  0x3FF5C00000000000, 0, 0xBFD3A64C55694800, 0x3D20B1C686519460,\n  0x3FF5A00000000000, 0, 0xBFD347DD9A988000, 0x3D25594DD4C58092,\n  0x3FF5800000000000, 0, 0xBFD2E8E2BAE12000, 0x3D267B1E99B72BD8,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5400000000000, 0, 0xBFD22941FBCF7800, 0xBD165A242853DA76,\n  0x3FF5200000000000, 0, 0xBFD1C898C1699800, 0xBD1FAFBC68E75404,\n  0x3FF5000000000000, 0, 0xBFD1675CABABA800, 0x3D1F1FC63382A8F0,\n  0x3FF4E00000000000, 0, 0xBFD1058BF9AE4800, 0xBD26A8C4FD055A66,\n  0x3FF4C00000000000, 0, 0xBFD0A324E2739000, 0xBD0C6BEE7EF4030E,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4800000000000, 0, 0xBFCFB9186D5E4000, 0x3D0D572AAB993C87,\n  0x3FF4600000000000, 0, 0xBFCEF0ADCBDC6000, 0x3D2B26B79C86AF24,\n  0x3FF4400000000000, 0, 0xBFCE27076E2AF000, 0xBD172F4F543FFF10,\n  0x3FF4200000000000, 0, 0xBFCD5C216B4FC000, 0x3D21BA91BBCA681B,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF3E00000000000, 0, 0xBFCBC286742D9000, 0x3D194EB0318BB78F,\n  0x3FF3C00000000000, 0, 0xBFCAF3C94E80C000, 0x3CBA4E633FCD9066,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3800000000000, 0, 0xBFC9525A9CF45000, 0xBD2AD1D904C1D4E3,\n  0x3FF3600000000000, 0, 0xBFC87FA06520D000, 0x3D2BBDBF7FDBFA09,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3200000000000, 0, 0xBFC6D60FE719D000, 0xBD10E46AA3B2E266,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF2E00000000000, 0, 0xBFC526E5E3A1B000, 0xBD20DE8B90075B8F,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2A00000000000, 0, 0xBFC371FC201E9000, 0x3CF178864D27543A,\n  0x3FF2800000000000, 0, 0xBFC29552F81FF000, 0xBD248D301771C408,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2200000000000, 0, 0xBFBFEC9131DBE000, 0xBD2575545CA333F2,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF1E00000000000, 0, 0xBFBC5E548F5BC000, 0xBD1D0C57585FBE06,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1800000000000, 0, 0xBFB6F0D28AE56000, 0xBD269737C93373DA,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1200000000000, 0, 0xBFB16536EEA38000, 0x3D147C5E768FA309,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0600000000000, 0, 0xBF97B91B07D58000, 0xBD288D5493FAA639,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FEFC00000000000, 0, 0x3F80101575890000, 0xBD10C76B999D2BE8,\n  0x3FEF800000000000, 0, 0x3F90205658938000, 0xBD23DC5B06E2F7D2,\n  0x3FEF400000000000, 0, 0x3F98492528C90000, 0xBD2AA0BA325A0C34,\n  0x3FEF000000000000, 0, 0x3FA0415D89E74000, 0x3D0111C05CF1D753,\n  0x3FEEC00000000000, 0, 0x3FA466AED42E0000, 0xBD2C167375BDFD28,\n  0x3FEE800000000000, 0, 0x3FA894AA149FC000, 0xBD197995D05A267D,\n  0x3FEE400000000000, 0, 0x3FACCB73CDDDC000, 0xBD1A68F247D82807,\n  0x3FEE200000000000, 0, 0x3FAEEA31C006C000, 0xBD0E113E4FC93B7B,\n  0x3FEDE00000000000, 0, 0x3FB1973BD1466000, 0xBD25325D560D9E9B,\n  0x3FEDA00000000000, 0, 0x3FB3BDF5A7D1E000, 0x3D2CC85EA5DB4ED7,\n  0x3FED600000000000, 0, 0x3FB5E95A4D97A000, 0xBD2C69063C5D1D1E,\n  0x3FED400000000000, 0, 0x3FB700D30AEAC000, 0x3CEC1E8DA99DED32,\n  0x3FED000000000000, 0, 0x3FB9335E5D594000, 0x3D23115C3ABD47DA,\n  0x3FECC00000000000, 0, 0x3FBB6AC88DAD6000, 0xBD1390802BF768E5,\n  0x3FECA00000000000, 0, 0x3FBC885801BC4000, 0x3D2646D1C65AACD3,\n  0x3FEC600000000000, 0, 0x3FBEC739830A2000, 0xBD2DC068AFE645E0,\n  0x3FEC400000000000, 0, 0x3FBFE89139DBE000, 0xBD2534D64FA10AFD,\n  0x3FEC000000000000, 0, 0x3FC1178E8227E000, 0x3D21EF78CE2D07F2,\n  0x3FEBE00000000000, 0, 0x3FC1AA2B7E23F000, 0x3D2CA78E44389934,\n  0x3FEBA00000000000, 0, 0x3FC2D1610C868000, 0x3D039D6CCB81B4A1,\n  0x3FEB800000000000, 0, 0x3FC365FCB0159000, 0x3CC62FA8234B7289,\n  0x3FEB400000000000, 0, 0x3FC4913D8333B000, 0x3D25837954FDB678,\n  0x3FEB200000000000, 0, 0x3FC527E5E4A1B000, 0x3D2633E8E5697DC7,\n  0x3FEAE00000000000, 0, 0x3FC6574EBE8C1000, 0x3D19CF8B2C3C2E78,\n  0x3FEAC00000000000, 0, 0x3FC6F0128B757000, 0xBD25118DE59C21E1,\n  0x3FEAA00000000000, 0, 0x3FC7898D85445000, 0xBD1C661070914305,\n  0x3FEA600000000000, 0, 0x3FC8BEAFEB390000, 0xBD073D54AAE92CD1,\n  0x3FEA400000000000, 0, 0x3FC95A5ADCF70000, 0x3D07F22858A0FF6F,\n  0x3FEA000000000000, 0, 0x3FCA93ED3C8AE000, 0xBD28724350562169,\n  0x3FE9E00000000000, 0, 0x3FCB31D8575BD000, 0xBD0C358D4EACE1AA,\n  0x3FE9C00000000000, 0, 0x3FCBD087383BE000, 0xBD2D4BC4595412B6,\n  0x3FE9A00000000000, 0, 0x3FCC6FFBC6F01000, 0xBCF1EC72C5962BD2,\n  0x3FE9600000000000, 0, 0x3FCDB13DB0D49000, 0xBD2AFF2AF715B035,\n  0x3FE9400000000000, 0, 0x3FCE530EFFE71000, 0x3CC212276041F430,\n  0x3FE9200000000000, 0, 0x3FCEF5ADE4DD0000, 0xBCCA211565BB8E11,\n  0x3FE9000000000000, 0, 0x3FCF991C6CB3B000, 0x3D1BCBECCA0CDF30,\n  0x3FE8C00000000000, 0, 0x3FD07138604D5800, 0x3CF89CDB16ED4E91,\n  0x3FE8A00000000000, 0, 0x3FD0C42D67616000, 0x3D27188B163CEAE9,\n  0x3FE8800000000000, 0, 0x3FD1178E8227E800, 0xBD2C210E63A5F01C,\n  0x3FE8600000000000, 0, 0x3FD16B5CCBACF800, 0x3D2B9ACDF7A51681,\n  0x3FE8400000000000, 0, 0x3FD1BF99635A6800, 0x3D2CA6ED5147BDB7,\n  0x3FE8200000000000, 0, 0x3FD214456D0EB800, 0x3D0A87DEBA46BAEA,\n  0x3FE7E00000000000, 0, 0x3FD2BEF07CDC9000, 0x3D2A9CFA4A5004F4,\n  0x3FE7C00000000000, 0, 0x3FD314F1E1D36000, 0xBD28E27AD3213CB8,\n  0x3FE7A00000000000, 0, 0x3FD36B6776BE1000, 0x3D116ECDB0F177C8,\n  0x3FE7800000000000, 0, 0x3FD3C25277333000, 0x3D183B54B606BD5C,\n  0x3FE7600000000000, 0, 0x3FD419B423D5E800, 0x3D08E436EC90E09D,\n  0x3FE7400000000000, 0, 0x3FD4718DC271C800, 0xBD2F27CE0967D675,\n  0x3FE7200000000000, 0, 0x3FD4C9E09E173000, 0xBD2E20891B0AD8A4,\n  0x3FE7000000000000, 0, 0x3FD522AE0738A000, 0x3D2EBE708164C759,\n  0x3FE6E00000000000, 0, 0x3FD57BF753C8D000, 0x3D1FADEDEE5D40EF,\n  0x3FE6C00000000000, 0, 0x3FD5D5BDDF596000, 0xBD0A0B2A08A465DC\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  let ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  let buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  let bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  let array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): Int8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): Uint8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): Uint8ClampedArray {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    let len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): Int16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    let len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): Uint16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    let len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): Int32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    let len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    FILL<u32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): Uint32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    let len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): Int64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    let len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    FILL<u64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): Uint64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    let len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    FILL<f32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): Float32Array {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    let len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    FILL<f64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): Float64Array {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  let slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\n  let count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  let byteLength = len << alignof<T>();\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  let len = array.length;\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  let dataStart  = array.dataStart;\n  let j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  let byteLength = j << alignof<T>();\n  let data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  let dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  let dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  let byteLength: i32;\n  let bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<\n  TArray extends ArrayLike<number>,\n  UArray extends ArrayLike<number>\n>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<valueof<UArray>>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n  let sourceLen = source.length;\n  if (offset < 0 || sourceLen + offset > target.length) {\n    // offset is out of bounds\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  // @ts-ignore: dataStart\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\n  // @ts-ignore: dataStart\n  let sourceStart = source.dataStart;\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\n  ) {\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\n  } else {\n    for (let i = 0; i < sourceLen; i++) {\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<valueof<UArray>>()) {\n          store<valueof<TArray>>(ptr,\n            isFinite<valueof<UArray>>(value)\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\n              : 0\n          );\n        } else {\n          if (!isSigned<valueof<UArray>>()) {\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\n          } else if (sizeof<valueof<TArray>>() <= 4) {\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\n          } else {\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\n          }\n        }\n      } else {\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\n        } else {\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\n        }\n      }\n    }\n  }\n}\n","const MINUS_CODE: u16 = 0x2d; // '-'\n\nconst HEX_CODES = memory.data<u8>([\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n    0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66\n]);\n\nfunction byteToHex(byte: u32): u32 {\n    return (\n        <u32>load<u8>(HEX_CODES + (byte >> 4 & 0x0F)) |\n        <u32>load<u8>(HEX_CODES + (byte >> 0 & 0x0F)) << 16\n    );\n}\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nexport default function stringify(arr: Uint8Array, offset: i32 = 0): string {\n    const src = arr.dataStart + offset;\n    const dst = __new(16 * 4 + 4 * 2, idof<string>());\n\n    store<u32>(dst +  0, byteToHex(load<u8>(src + 0)));\n    store<u32>(dst +  4, byteToHex(load<u8>(src + 1)));\n    store<u32>(dst +  8, byteToHex(load<u8>(src + 2)));\n    store<u32>(dst + 12, byteToHex(load<u8>(src + 3)));\n\n    store<u16>(dst + 16, MINUS_CODE);\n\n    store<u32>(dst + 18, byteToHex(load<u8>(src + 4)));\n    store<u32>(dst + 22, byteToHex(load<u8>(src + 5)));\n\n    store<u16>(dst + 26, MINUS_CODE);\n\n    store<u32>(dst + 28, byteToHex(load<u8>(src + 6)));\n    store<u32>(dst + 32, byteToHex(load<u8>(src + 7)));\n\n    store<u16>(dst + 36, MINUS_CODE);\n\n    store<u32>(dst + 38, byteToHex(load<u8>(src + 8)));\n    store<u32>(dst + 42, byteToHex(load<u8>(src + 9)));\n\n    store<u16>(dst + 46, MINUS_CODE);\n\n    store<u32>(dst + 48, byteToHex(load<u8>(src + 10)));\n    store<u32>(dst + 52, byteToHex(load<u8>(src + 11)));\n    store<u32>(dst + 56, byteToHex(load<u8>(src + 12)));\n    store<u32>(dst + 60, byteToHex(load<u8>(src + 13)));\n    store<u32>(dst + 64, byteToHex(load<u8>(src + 14)));\n    store<u32>(dst + 68, byteToHex(load<u8>(src + 15)));\n\n    return changetype<string>(dst);\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  let h: u32 = key.length << 1;\n  let len: usize = h;\n  let pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  let end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\n\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a set entry. */\n@unmanaged class SetEntry<K> {\n  key: K;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<T>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\n  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<T>(): usize {\n  const align = ENTRY_ALIGN<T>();\n  const size = (offsetof<SetEntry<T>>() + align) & ~align;\n  return size;\n}\n\nexport class Set<T> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, SetEntry<K>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: T, hashCode: u32): SetEntry<T> | null {\n    let entry = load<SetEntry<T>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  @operator(\"[]\")\n  has(key: T): bool {\n    return this.find(key, HASH<T>(key)) != null;\n  }\n\n  add(key: T): this {\n    let hashCode = HASH<T>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (!entry) {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());\n      entry.key = key;\n      if (isManaged<T>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  @operator(\"[]=\")\n  private __set(key: T, value: bool): void {\n    if (value) this.add(key);\n    else this.delete(key);\n  }\n\n  delete(key: T): bool {\n    let entry = this.find(key, HASH<T>(key)); // unmanaged!\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<T>();\n      }\n      oldPtr += ENTRY_SIZE<T>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  values(): T[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<T>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.key);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Set]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<T>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n      while (cur < end) {\n        let entry = changetype<SetEntry<T>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          let val = changetype<usize>(entry.key);\n          if (isNullable<T>()) {\n            if (val) __visit(val, cookie);\n          } else __visit(val, cookie);\n        }\n        cur += ENTRY_SIZE<T>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getDateFromJSONOptional,\n    getF64FromJSONOptional,\n    getJSONObjFromJSONOptional,\n    getStringFromJSON,\n    getStringFromJSONOptional,\n    getStringMapFromJSONObj,\n    jsonArrFromValueArray,\n    jsonObjFromMap\n} from '../helpers/jsonHelpers'\nimport { DVCPopulatedUser } from './dvcUser'\nimport uuid from 'as-uuid/assembly'\n\nexport const EventTypes = new Set<string>()\nEventTypes.add('variableEvaluated')\nEventTypes.add('aggVariableEvaluated')\nEventTypes.add('variableDefaulted')\nEventTypes.add('aggVariableDefaulted')\nEventTypes.add('sdkConfig')\n\n/**\n * Public interface for DVCEvent passed into SDK methods.\n */\nexport class DVCEvent extends JSON.Value {\n    constructor(\n        /**\n         * type of the event\n         */\n        public readonly type: string,\n\n        /**\n         * target / subject of event. Contextual to event type\n         */\n        public readonly target: string | null,\n\n        /**\n         * date event occurred according to client stored as time since epoch\n         */\n        public readonly date: Date | null,\n\n        /**\n         * value for numerical events. Contextual to event type\n         */\n        public readonly value: f64,\n\n        /**\n         * extra metadata for event. Contextual to event type\n         */\n        public readonly metaData: JSON.Obj | null\n    ) {\n        super()\n    }\n\n    static fromJSONString(eventStr: string): DVCEvent {\n        const eventJSON = JSON.parse(eventStr)\n        if (!eventJSON.isObj) throw new Error('DVCEvent eventStr not a JSON Object')\n        const event = eventJSON as JSON.Obj\n\n        return new DVCEvent(\n            getStringFromJSON(event, 'type'),\n            getStringFromJSONOptional(event, 'target'),\n            getDateFromJSONOptional(event, 'date'),\n            getF64FromJSONOptional(event, 'value', NaN),\n            getJSONObjFromJSONOptional(event, 'metaData')\n        )\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('type', this.type)\n        const date = this.date // nullable check only works like this\n        if (date) json.set('date', date.toISOString())\n        if (this.target) json.set('target', this.target)\n        if (!isNaN(this.value)) json.set('value', this.value)\n        if (this.metaData) json.set('metaData', this.metaData)\n        return json.stringify()\n    }\n}\n\n/**\n * Internal interface for events after they've been populated with user_id and featureVars.\n */\nexport class DVCRequestEvent extends JSON.Value {\n    /**\n     * type of the event\n     */\n    readonly type: string\n\n    /**\n     * target / subject of event. Contextual to event type\n     */\n    readonly target: string | null\n\n    readonly customType: string | null\n\n    readonly user_id: string\n\n    /**\n     * date event occurred according to client stored as time since epoch\n     */\n    readonly date: Date\n\n    readonly clientDate: Date\n\n    /**\n     * value for numerical events. Contextual to event type\n     */\n    readonly value: f64\n\n    readonly featureVars: Map<string, string>\n\n    /**\n     * extra metadata for event. Contextual to event type\n     */\n    readonly metaData: JSON.Obj | null\n\n    constructor(event: DVCEvent, user_id: string, featureVars: Map<string, string>) {\n        super()\n\n        const isCustomEvent = !EventTypes.has(event.type)\n\n        this.type = isCustomEvent ? 'customEvent' : event.type\n        this.target = event.target\n        this.customType = isCustomEvent ? event.type : null\n        this.user_id = user_id\n        this.date = new Date(Date.now())\n        const eventDate = event.date ? event.date : null\n        this.clientDate = eventDate ? eventDate: new Date(Date.now())\n        this.value = event.value\n        this.featureVars = featureVars\n        this.metaData = event.metaData\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('type', this.type)\n        if (this.target) json.set('target', this.target)\n        if (this.customType) json.set('customType', this.customType)\n        json.set('user_id', this.user_id)\n        json.set('date', this.date.toISOString())\n        json.set('clientDate', this.clientDate.toISOString())\n        if (!isNaN(this.value)) json.set('value', this.value)\n        const featureVars = this.featureVars // nullable check only works like this\n        if (featureVars) json.set('featureVars', jsonObjFromMap(featureVars))\n        if (this.metaData) json.set('metaData', this.metaData)\n        return json.stringify()\n    }\n}\n\nexport class UserEventsBatchRecord extends JSON.Value {\n    constructor(\n        public user: DVCPopulatedUser,\n        public events: DVCRequestEvent[]\n    ) {\n        super()\n\n        // remove privateCustomData from user before sending events to server\n        this.user.privateCustomData = null\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('user', this.user)\n        json.set('events', jsonArrFromValueArray(this.events))\n        return json.stringify()\n    }\n}\n\nexport class FlushPayload extends JSON.Value {\n    public readonly payloadId: string\n    public status: string\n\n    constructor(\n        public records: UserEventsBatchRecord[]\n    ) {\n        super()\n        this.status = 'sending'\n        this.payloadId = uuid()\n    }\n\n    /**\n     * Add batchRecord for user, first check if there is an existing record for the user,\n     * otherwise create a new record with a max `chunkSize` number of events.\n     */\n    addBatchRecordForUser(record: UserEventsBatchRecord, chunkSize: i32): void {\n        const userRecord = this.recordForUser(record.user.user_id)\n        const splicedEvents = record.events.splice(0, chunkSize - this.eventCount())\n        if (splicedEvents.length === 0) return\n\n        if (userRecord) {\n            userRecord.user = record.user\n            userRecord.events = userRecord.events.concat(splicedEvents)\n        } else {\n            const newBatchRecord = new UserEventsBatchRecord(\n                record.user,\n                splicedEvents\n            )\n            this.records.push(newBatchRecord)\n        }\n    }\n\n    /**\n     * Fetch an existing UserEventsBatchRecord for a `user_id`\n     */\n    recordForUser(user_id: string): UserEventsBatchRecord | null {\n        for (let i = 0; i < this.records.length; i++) {\n            const record = this.records[i]\n            if (record.user.user_id === user_id) {\n                return record\n            }\n        }\n        return null\n    }\n\n    /**\n     * Fetch the total event count for all the records in the batch\n     */\n    eventCount(): i32 {\n        let count: i32 = 0\n        for (let i = 0; i < this.records.length; i++) {\n            const record = this.records[i]\n            count += record.events.length\n        }\n        return count\n    }\n\n    stringify(): string {\n        const jsonObj = new JSON.Obj()\n        jsonObj.set('records', jsonArrFromValueArray(this.records))\n        jsonObj.set('payloadId', this.payloadId)\n        jsonObj.set('eventCount', this.eventCount())\n        return jsonObj.stringify()\n    }\n}\n\nexport function testDVCEventClass(eventStr: string): string {\n    const event = DVCEvent.fromJSONString(eventStr)\n    return event.stringify()\n}\n\nexport function testDVCRequestEventClass(eventStr: string, user_id: string, featureVarsStr: string): string {\n    const featureVarsJSON = JSON.parse(featureVarsStr)\n    if (!featureVarsJSON.isObj) throw new Error('featureVarsJSON is not a JSON Object')\n\n    const requestEvent = new DVCRequestEvent(\n        DVCEvent.fromJSONString(eventStr),\n        user_id,\n        getStringMapFromJSONObj(featureVarsJSON as JSON.Obj)\n    )\n    return requestEvent.stringify()\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nexport enum CustomDataType {\n  Bool = 0,\n  Num = 1,\n  Str = 2,\n  Null = 3,\n}\n","export enum WireType {\n  /**\n   * int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */\n  VARINT = 0,\n  /**\n   * fixed64, sfixed64, double\n   */\n  FIXED_64 = 1,\n  /**\n   * string, bytes, embedded messages, packed repeated fields\n   */\n  LENGTH_DELIMITED = 2,\n  /**\n   * groups (deprecated)\n   * @deprecated\n   */\n  START_GROUP = 3,\n  /**\n   * groups (deprecated)\n   * @deprecated\n   */\n  END_GROUP = 4,\n  /**\n   * fixed32, sfixed32, float\n   */\n  FIXED_32 = 5,\n}\n","import { Writer } from \"../Writer\";\nimport { FixedSizer } from \"./FixedSizer\";\n\n/**\n * @internal\n *\n * Wire format writer using `Uint8Array`\n */\n@final\nexport class FixedWriter extends Writer {\n  /**\n   * Related sizer\n   */\n  readonly sizer: FixedSizer;\n\n  /**\n   * Current pointer.\n   */\n  private ptr: usize;\n\n  /**\n   * Fixed buffer.\n   */\n  private buf: Uint8Array;\n\n  /**\n   * Index in varlen array from sizer.\n   */\n  private varlenidx: i32;\n\n  constructor() {\n    super();\n    const sizer = this.sizer = new FixedSizer();\n    const buf = this.buf = new Uint8Array(sizer.len);\n    this.ptr = buf.dataStart;\n    this.varlenidx = 0;\n  }\n\n  @inline\n  uint32(value: u32): void {\n    this.varint<u32>(value);\n  }\n\n  @inline\n  int32(value: i32): void {\n    if (value < 0) {\n      this.int64(value);\n    } else {\n      this.varint<u32>(value);\n    }\n  }\n\n  @inline\n  sint32(value: i32): void {\n    this.varint<u32>((value << 1) ^ (value >> 31));\n  }\n\n  @inline\n  uint64(value: u64): void {\n    this.varint<u64>(value);\n  }\n\n  @inline\n  int64(value: i64): void {\n    this.varint<u64>(value);\n  }\n\n  @inline\n  sint64(value: i64): void {\n    this.varint<u64>((value << 1) ^ (value >> 63));\n  }\n\n  @inline\n  bool(value: bool): void {\n    this.fixed<u8>(value ? 1 : 0);\n  }\n\n  @inline\n  fixed32(value: u32): void {\n    this.fixed<u32>(value);\n  }\n\n  @inline\n  sfixed32(value: i32): void {\n    this.fixed<u32>(value);\n  }\n\n  @inline\n  fixed64(value: u64): void {\n    this.fixed<u64>(value);\n  }\n\n  @inline\n  sfixed64(value: i64): void {\n    this.fixed<u64>(value);\n  }\n\n  @inline\n  float(value: f32): void {\n    this.fixed<f32>(value);\n  }\n\n  @inline\n  double(value: f64): void {\n    this.fixed<f64>(value);\n  }\n\n  bytes(value: Uint8Array): void {\n    this.uint32(value.byteLength);\n    memory.copy(this.ptr, value.dataStart, value.byteLength);\n    this.ptr += value.byteLength;\n  }\n\n  string(value: string): void {\n    const len = this.varlen(); // use precomputed length\n    this.uint32(len);\n    String.UTF8.encodeUnsafe(changetype<usize>(value), value.length, this.ptr);\n    this.ptr += len;\n  }\n\n  @inline\n  fork(): void {\n    this.uint32(this.varlen()); // use precomputed length\n  }\n\n  @inline\n  ldelim(): void {\n    // nothing to do - all dirty work done by sizer\n  }\n\n  finish(): Uint8Array {\n    return this.buf;\n  }\n\n  reset(): void {\n    this.buf = new Uint8Array(this.sizer.len);\n    this.ptr = this.buf.dataStart;\n    this.varlenidx = 0;\n  }\n\n  @inline\n  private varint<T extends number>(val: T): void {\n    while (val > 0x7f) {\n      store<u8>(this.ptr++, (val & 0x7f) | 0x80);\n      val = <T>(val >>> 7);\n    }\n    store<u8>(this.ptr++, val);\n  }\n\n  @inline\n  private fixed<T extends number>(val: T): void {\n    store<T>(this.ptr, val);\n    this.ptr += sizeof<T>();\n  }\n\n  @inline\n  private varlen(): u32 {\n    return this.varlenidx >= this.sizer.varlen.length\n      ? 0\n      : this.sizer.varlen[this.varlenidx++];\n  }\n}\n","import { Writer } from \"../Writer\";\n\n/**\n * @internal\n */\n@final\nexport class FixedSizer extends Writer {\n  /**\n   * Total length.\n   */\n  len: u32;\n\n  /**\n   * Position stack.\n   */\n  readonly pos: Array<u32>;\n\n  /**\n   * Variable length list.\n   */\n  readonly varlen: Array<i32>;\n\n  /**\n   * Variable length index stack.\n   */\n  readonly varlenidx: Array<i32>;\n\n  constructor() {\n    super();\n    this.len = 0;\n    this.pos = [];\n    this.varlen = [];\n    this.varlenidx = [];\n  }\n\n  @inline\n  uint32(value: u32): void {\n    this.varint32(value);\n  }\n\n  @inline\n  int32(value: i32): void {\n    if (value < 0) {\n      // 10 bytes to encode negative number\n      this.len += 10;\n    } else {\n      this.varint32(value);\n    }\n  }\n\n  @inline\n  sint32(value: i32): void {\n    this.varint32((value << 1) ^ (value >> 31));\n  }\n\n  @inline\n  uint64(value: u64): void {\n    this.varint64(value);\n  }\n\n  @inline\n  int64(value: i64): void {\n    this.varint64(value);\n  }\n\n  @inline\n  sint64(value: i64): void {\n    this.varint64((value << 1) ^ (value >> 63));\n  }\n\n  @inline\n  bool(value: bool): void {\n    this.len += 1;\n  }\n\n  @inline\n  fixed32(value: u32): void {\n    this.len += 4;\n  }\n\n  @inline\n  sfixed32(value: i32): void {\n    this.len += 4;\n  }\n\n  @inline\n  fixed64(value: u64): void {\n    this.len += 8;\n  }\n\n  @inline\n  sfixed64(value: i64): void {\n    this.len += 8;\n  }\n\n  @inline\n  float(value: f32): void {\n    this.len += 4;\n  }\n\n  @inline\n  double(value: f64): void {\n    this.len += 8;\n  }\n\n  bytes(value: Uint8Array): void {\n    this.uint32(value.byteLength);\n    this.len += value.byteLength;\n  }\n\n  string(value: string): void {\n    const len = String.UTF8.byteLength(value);\n    this.varlen.push(len);\n    this.uint32(len);\n    this.len += len;\n  }\n\n  @inline\n  fork(): void {\n    this.pos.push(this.len); // save current position\n    this.varlenidx.push(this.varlen.length); // save current index in varlen array\n    this.varlen.push(0); // add 0 length to varlen array (to be updated in ldelim())\n  }\n\n  ldelim(): void {\n    assert(\n      this.pos.length && this.varlenidx.length,\n      \"Missing fork() before ldelim() call.\"\n    );\n\n    const endPos = this.len; // current position is end position\n    const startPos = this.pos.pop(); // get start position from stack\n    const idx = this.varlenidx.pop(); // get varlen index from stack\n    const len = endPos - startPos; // calculate length\n\n    this.varlen[idx] = len; // update variable length\n    this.uint32(len); // add uint32 that should be called in fork()\n  }\n\n  reset(): void {\n    this.len = 0;\n    // re-use arrays\n    this.pos.length = 0;\n    this.varlen.length = 0;\n    this.varlenidx.length = 0;\n  }\n\n  @inline\n  private varint32(value: u32): void {\n    this.len +=\n      value < 0\n        ? 10 // 10 bits with leading 1's\n        : value < 0x80\n        ? 1\n        : value < 0x4000\n        ? 2\n        : value < 0x200000\n        ? 3\n        : value < 0x10000000\n        ? 4\n        : 5;\n  }\n\n  @inline\n  private varint64(value: u64): void {\n    this.len +=\n      value < 0x80\n        ? 1\n        : value < 0x4000\n        ? 2\n        : value < 0x200000\n        ? 3\n        : value < 0x10000000\n        ? 4\n        : value < 0x400000000\n        ? 5\n        : value < 0x20000000000\n        ? 6\n        : value < 0x1000000000000\n        ? 7\n        : value < 0x80000000000000\n        ? 8\n        : value < 0x4000000000000000\n        ? 9\n        : 10;\n  }\n}\n","import { FixedWriter } from \"./internal/FixedWriter\";\nimport { FixedReader } from \"./internal/FixedReader\";\nimport { Writer } from \"./Writer\";\nimport { Reader } from \"./Reader\";\n\n// re-use instances to reduce allocations and GC\nconst WRITER = new FixedWriter();\nconst READER = new FixedReader(new Uint8Array(0));\n\n@final\nexport class Protobuf {\n  static encode<TMessage>(\n    message: TMessage,\n    encoder: (message: TMessage, writer: Writer) => void\n  ): Uint8Array {\n    // 1st pass - calculate length\n    WRITER.sizer.reset();\n    encoder(message, WRITER.sizer);\n    // 2nd pass - write data using length from the 1st pass\n    WRITER.reset();\n    encoder(message, WRITER);\n    return WRITER.finish();\n  }\n\n  static decode<TMessage>(\n    buffer: Uint8Array,\n    decoder: (reader: Reader, length: i32) => TMessage,\n    length: i32 = -1\n  ): TMessage {\n    READER.reset(buffer);\n    return decoder(READER, length);\n  }\n}\n","import { Reader } from \"../Reader\";\nimport { WireType } from \"../WireType\";\n\n/**\n * @internal\n *\n * Wire format reader using `Uint8Array`\n */\n@final\nexport class FixedReader extends Reader {\n  /**\n   * Read buffer\n   */\n  private buf: Uint8Array;\n\n  constructor(buf: Uint8Array) {\n    super();\n    this.ptr = buf.dataStart;\n    this.end = buf.dataStart + buf.byteLength;\n    this.buf = buf;\n  }\n\n  @inline\n  uint32(): u32 {\n    return this.varint32();\n  }\n\n  @inline\n  int32(): i32 {\n    return this.varint32();\n  }\n\n  @inline\n  sint32(): i32 {\n    const value: u32 = this.varint32();\n    return (value >>> 1) ^ -(value & 1);\n  }\n\n  @inline\n  uint64(): u64 {\n    return this.varint64();\n  }\n\n  @inline\n  int64(): i64 {\n    return this.varint64();\n  }\n\n  @inline\n  sint64(): i64 {\n    const value = this.varint64();\n    return (value >>> 1) ^ -(value & 1);\n  }\n\n  @inline\n  bool(): bool {\n    return this.varint32() !== 0;\n  }\n\n  @inline\n  fixed32(): u32 {\n    return load<u32>(this.inc(4));\n  }\n\n  @inline\n  sfixed32(): i32 {\n    return this.fixed32();\n  }\n\n  @inline\n  fixed64(): u64 {\n    return load<u64>(this.inc(8));\n  }\n\n  @inline\n  sfixed64(): u64 {\n    return this.fixed64();\n  }\n\n  @inline\n  float(): f32 {\n    return load<f32>(this.inc(4));\n  }\n\n  @inline\n  double(): f64 {\n    return load<f64>(this.inc(8));\n  }\n\n  bytes(): Uint8Array {\n    const length = this.uint32();\n    const buffer = new Uint8Array(length);\n    memory.copy(buffer.dataStart, this.inc(length), length);\n    return buffer;\n  }\n\n  string(): string {\n    const length = this.uint32();\n    return String.UTF8.decodeUnsafe(this.inc(length), length);\n  }\n\n  skip(length: u32): void {\n    if (length === 0) {\n      // skip varint\n      while (load<u8>(this.inc()) & 0x80);\n    } else {\n      this.inc(length);\n    }\n  }\n\n  skipType(wireType: WireType = WireType.VARINT): void {\n    switch (wireType) {\n      case WireType.VARINT:\n        this.skip(0);\n        break;\n      case WireType.FIXED_64:\n        this.skip(8);\n        break;\n      case WireType.LENGTH_DELIMITED:\n        this.skip(this.uint32());\n        break;\n      case WireType.START_GROUP:\n        while ((wireType = this.uint32() & 0x07) !== WireType.END_GROUP) {\n          this.skipType(wireType);\n        }\n        break;\n      case WireType.FIXED_32:\n        this.skip(4);\n        break;\n      default:\n        throw new Error(\"Invalid wire type \" + wireType.toString());\n    }\n  }\n\n  reset(buf: Uint8Array): void {\n    this.ptr = buf.dataStart;\n    this.end = buf.dataStart + buf.byteLength;\n    this.buf = buf;\n  }\n\n  private varint32(): u32 {\n    let loaded: u32;\n    let value: u32;\n\n    value = (loaded = load<u8>(this.inc())) & 0x7f;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 7;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 14;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 21;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0xf) << 28;\n    if (loaded < 0x80) return value;\n\n    // increment position until there is no continuation bit or until we read 10 bytes\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n\n    return value;\n  }\n\n  private varint64(): u64 {\n    let loaded: u64;\n    let value: u64;\n\n    value = (loaded = load<u8>(this.inc())) & 0x7f;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 7;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 14;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 21;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 28;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 35;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 42;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 49;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 56;\n    if (loaded < 0x80) return value;\n\n    value |= (load<u8>(this.inc()) & 0x1) << 63;\n\n    return value;\n  }\n\n  @inline\n  private inc(step: u32 = 1): usize {\n    const ptr = this.ptr;\n    this.ptr += step;\n    assert(this.ptr <= this.end, \"Index out of range\");\n\n    return ptr;\n  }\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nexport enum VariableType_PB {\n  Boolean = 0,\n  Number = 1,\n  String = 2,\n  JSON = 3,\n}\n","/* eslint-disable */\n// Linter disabled due to this code depending on semicolons etc.\nimport { unicodeCharEscape } from './stringHelpers'\n\nexport function murmurhashV3_js(key: string, seed: u32): string {\n    return `${murmurhashV3(key, seed)}`\n}\n\n// NOTE: update the test in murmurhash.test.ts if this value is changed (or figure out how to import it in the test)\nexport const murmurhashBufferSize = 2000\n\nconst keyBuffer = new StaticArray<i32>(murmurhashBufferSize)\n\nexport function murmurhashV3(key: string, seed: u32): u32 {\n    let currentBuffer = keyBuffer\n    if (key.length > keyBuffer.length) {\n        // console.log(\"Warning: exceeded maximum size of murmurhash buffer.\")\n        currentBuffer = new StaticArray<i32>(key.length)\n    }\n\n    for (let i = 0; i < key.length; i++) {\n        const charCode: i32 = key.charCodeAt(i)\n        if (charCode > 127) {\n            unchecked(currentBuffer[i] = unicodeCharEscape(charCode).charCodeAt(0))\n        } else {\n            unchecked(currentBuffer[i] = charCode)\n        }\n    }\n\n    const length = key.length;\n\n    let remainder: i32, bytes: i32, h1b: i32, c1: i32, c2: i32, k1: i32, i: i32, h1: i32;\n\n    remainder = key.length & 3;\n    bytes = length - remainder;\n    h1 = seed;\n    c1 = 0xcc9e2d51;\n    c2 = 0x1b873593;\n    i = 0;\n\n    while (i < bytes) {\n        k1 =\n            ((unchecked(currentBuffer[i]) & 0xff)) |\n            ((unchecked(currentBuffer[++i]) & 0xff) << 8) |\n            ((unchecked(currentBuffer[++i]) & 0xff) << 16) |\n            ((unchecked(currentBuffer[++i]) & 0xff) << 24);\n        ++i;\n\n\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    switch (remainder) {\n        case 3:\n            k1 ^= (unchecked(currentBuffer[i + 2]) & 0xff) << 16;\n        case 2:\n            k1 ^= (unchecked(currentBuffer[i + 1]) & 0xff) << 8;\n        case 1:\n            k1 ^= (unchecked(currentBuffer[i]) & 0xff);\n            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n            h1 ^= k1;\n    }\n\n    h1 ^= length;\n\n\n    h1 ^= h1 >>> 16;\n\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n\n    h1 ^= h1 >>> 13;\n\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n\n    h1 ^= h1 >>> 16;\n\n    return h1 as u32;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(outStart, ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","import { RegExp } from 'assemblyscript-regex/assembly'\n\nexport class OptionsType {\n    public lexicographical: bool\n    public zeroExtend: bool\n}\n\nfunction hasValidParts(lexicographical: bool, parts: string[]): bool {\n    for (let i = 0; i < parts.length; i++) {\n        // Regex objects are stateful, have to recreate this on each iteration\n        const regex = lexicographical ? new RegExp('^\\\\d+[A-Za-z]*$', 'g') : new RegExp('^\\\\d+$', 'g')\n        if (!regex.test(`${parts[i]}`)) {\n            return false\n        }\n    }\n    return !!parts.length\n}\n\nexport const versionCompare = (v1: string, v2: string, options: OptionsType | null): f64 => {\n    const lexicographical: bool = options ? options.lexicographical : false\n    const zeroExtend: bool = options ? options.zeroExtend : false\n\n    const v1parts = v1.split('.')\n    const v2parts = v2.split('.')\n    const hasV1 = hasValidParts(lexicographical, v1parts)\n    const hasV2 = hasValidParts(lexicographical, v2parts)\n    if (!hasV1 || !hasV2) {\n        return NaN\n    }\n\n    if (zeroExtend) {\n        while (v1parts.length < v2parts.length) v1parts.push('0')\n        while (v2parts.length < v1parts.length) v2parts.push('0')\n    }\n\n    let v1PartsFinal: f64[] = []\n    let v2PartsFinal: f64[] = []\n\n    if (!lexicographical) {\n        v1PartsFinal = v1parts.map<f64>((n) => parseInt(n))\n        v2PartsFinal = v2parts.map<f64>((n) => parseInt(n))\n    }\n\n    for (let i = 0; i < v1PartsFinal.length; ++i) {\n        if (v2PartsFinal.length === i) {\n            return 1\n        }\n\n        if (v1PartsFinal[i] === v2PartsFinal[i]) {\n            continue\n        } else if (v1PartsFinal[i] > v2PartsFinal[i]) {\n            return 1\n        } else {\n            return -1\n        }\n    }\n\n    if (v1PartsFinal.length !== v2PartsFinal.length) {\n        return -1\n    }\n\n    return 0\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","import { strtol, strtod, strtob } from \"./util/string\";\n\ntype auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVector<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore\n@builtin\nexport declare function bswap<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function eq<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ne<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rem<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i32 {\n    return strtol<i32>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i32, right: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u32, right: u32): u32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i64, right: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u64, right: u64): u64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): bool {\n    return strtob(value);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f32, right: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f32, right: f32): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f64 {\n    return strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f64, right: f64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f64, right: f64): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\n@external.js(\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\n@external.js(\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\n@external.js(\"return Date.now() * Math.random();\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","import { State, Automata, GroupStartMarkerState, MatchResult } from \"./nfa/nfa\";\nimport { walker as nfaWalker } from \"./nfa/walker\";\nimport { ConcatenationNode, AssertionNode, NodeType } from \"./parser/node\";\nimport { Char } from \"./char\";\nimport { Parser } from \"./parser/parser\";\nimport { first, last } from \"./util\";\nimport { walker as astWalker, expandRepetitions } from \"./parser/walker\";\n\nfunction recursiveBacktrackingSearch(\n  state: State,\n  input: string,\n  visited: u32[] = [],\n  position: i32 = 0\n): string | null {\n  // prevent endless loops when following epsilon transitions\n  for (let i = 0, len = visited.length; i < len; i++) {\n    if (visited[i] == state.id) {\n      return null;\n    }\n  }\n  visited.push(state.id);\n\n  const matches = state.matches(input, position);\n  if (matches == MatchResult.Match) {\n    // a match occurred\n    if (position == input.length) {\n      // we've reached the end of the string\n      return null;\n    }\n    visited = [];\n    position++;\n  } else if (matches == MatchResult.Fail) {\n    return null;\n  }\n\n  const transitions = state.transitions;\n  if (transitions.length == 0) {\n    // we've reached the end, so retur the matched string\n    return input.substring(0, position);\n  }\n\n  for (let i = 0, len = transitions.length; i < len; i++) {\n    const match = recursiveBacktrackingSearch(\n      transitions[i],\n      input,\n      visited,\n      position\n    );\n    if (match != null) {\n      // when unwinding the stack after a successful match, flag the captured values\n      if (state instanceof GroupStartMarkerState) {\n        (state as GroupStartMarkerState).flagged = true;\n      }\n      return match;\n    }\n  }\n  return null;\n}\n\nexport class Match {\n  constructor(\n    public matches: string[],\n    public index: i32,\n    public input: string\n  ) {}\n\n  static fromMatch(match: string, index: i32, input: string): Match {\n    return new Match([match], index, input);\n  }\n}\n\nexport class Flags {\n  global: bool = false;\n  ignoreCase: bool = false;\n  dotAll: bool = false;\n  multiline: bool = false;\n\n  constructor(flagString: string | null) {\n    if (flagString) {\n      this.global = flagString.includes(\"g\");\n      this.ignoreCase = flagString.includes(\"i\");\n      this.dotAll = flagString.includes(\"s\");\n      this.multiline = flagString.includes(\"m\");\n    }\n  }\n}\n\n// capture groups are implemented as GroupStart / GroupEnd states that record (capture)\n// the value of the current state of the string being matched.\n// Repeated capture groups, via range repetitions (e.g. {2,3}) share the same 'id'. The\n// returned regex should only return the value of the final repetition.\nfunction lastCapturesForGroup(groupMarkers: GroupStartMarkerState[]): string[] {\n  if (!groupMarkers.length) {\n    return [];\n  }\n  const values = [first(groupMarkers).capture];\n  let currrentId = first(groupMarkers).groupId;\n  for (let i = 0; i < groupMarkers.length; i++) {\n    const gm = groupMarkers[i];\n    if (gm.groupId != currrentId) {\n      currrentId = gm.groupId;\n      values.push(gm.capture);\n    } else {\n      if (gm.flagged) {\n        values[values.length - 1] = gm.capture;\n      }\n    }\n  }\n  return values;\n}\n\nexport class RegExp {\n  @lazy static gm: GroupStartMarkerState[] = new Array<GroupStartMarkerState>();\n  lastIndex: i32 = 0;\n  private flags: Flags;\n  private nfa: Automata;\n  private endOfInput: bool = false;\n  private startOfInput: bool = false;\n  private groupMarkers: GroupStartMarkerState[];\n\n  constructor(private regex: string, public flagsString: string | null = null) {\n    const ast = Parser.toAST(regex);\n    const flags = new Flags(flagsString);\n\n    // look for start / end assertions\n    const body = ast.body;\n    if (body != null && body.type == NodeType.Concatenation) {\n      const expressions = (ast.body as ConcatenationNode).expressions;\n      this.startOfInput = AssertionNode.is(first(expressions), Char.Caret);\n      this.endOfInput = AssertionNode.is(last(expressions), Char.Dollar);\n    }\n\n    astWalker(ast, expandRepetitions);\n\n    const nfa = Automata.toNFA(ast, flags);\n\n    // find all the group marker states\n    RegExp.gm = new Array<GroupStartMarkerState>();\n    nfaWalker(nfa.start, (state) => {\n      if (state instanceof GroupStartMarkerState) {\n        const startMarker = state as GroupStartMarkerState;\n        if (startMarker.capturing) {\n          RegExp.gm.push(state as GroupStartMarkerState);\n        }\n      }\n    });\n    this.nfa = nfa;\n    this.groupMarkers = RegExp.gm;\n\n    this.flags = flags;\n  }\n\n  exec(str: string): Match | null {\n    let groupMarkers = this.groupMarkers;\n    // remove all previous group marker results\n    for (let i = 0, len = groupMarkers.length; i < len; i++) {\n      groupMarkers[i].capture = \"\";\n    }\n\n    let len = str.length;\n    if (!len) {\n      const matchStr = recursiveBacktrackingSearch(this.nfa.start, \"\");\n      return matchStr != null ? new Match([matchStr], 0, str) : null;\n    }\n\n    // search for a match at each index within the string\n\n    for (\n      let matchIndex = this.lastIndex;\n      matchIndex < (this.startOfInput && !this.multiline ? 1 : len);\n      matchIndex++\n    ) {\n      // search for a match in this substring\n      const matchStr = recursiveBacktrackingSearch(\n        this.nfa.start,\n        str.substr(matchIndex)\n      );\n\n      // we have found a match\n      if (matchStr != null) {\n        // remove any non-flagged captures\n        groupMarkers.forEach((gm) => {\n          gm.capture = gm.flagged ? gm.capture : \"\";\n        });\n\n        const matches: string[] = [matchStr];\n        const match = new Match(\n          matches.concat(lastCapturesForGroup(groupMarkers)),\n          matchIndex,\n          str\n        );\n\n        // return this match (checking end of input condition)\n        const matchEndIndex = match.index + match.matches[0].length;\n\n        // has the start of input criteria been met?\n        if (this.startOfInput) {\n          if (this.flags.multiline && matchIndex != 0) {\n            if (str.charCodeAt(matchIndex - 1) != Char.LineFeed) continue;\n          } else if (matchIndex != 0) {\n            continue;\n          }\n        }\n\n        // has the enf of input criteria been met?\n        if (this.endOfInput) {\n          if (this.flags.multiline && matchEndIndex != len) {\n            if (str.charCodeAt(matchEndIndex) != Char.LineFeed) continue;\n          } else if (matchEndIndex != len) {\n            continue;\n          }\n        }\n\n        if (this.global) {\n          this.lastIndex = matchEndIndex;\n        }\n        return match;\n      }\n    }\n\n    this.lastIndex = 0;\n    return null;\n  }\n\n  test(str: string): bool {\n    return this.exec(str) != null;\n  }\n\n  toString(): string {\n    return this.regex;\n  }\n\n  get global(): bool {\n    return this.flags.global;\n  }\n\n  get ignoreCase(): bool {\n    return this.flags.ignoreCase;\n  }\n\n  get dotAll(): bool {\n    return this.flags.dotAll;\n  }\n\n  get multiline(): bool {\n    return this.flags.multiline;\n  }\n}\n\n// TODO: do we need this factory function, or can we invoke\n// the ctr via the loader?\nexport function createRegExp(regex: string, flags: string): RegExp {\n  return new RegExp(regex, flags);\n}\n\n// the executeRegExp exported function is used for benchmarking, giving a simple API\n// for executing a regex a given number of times\nexport function executeRegExp(\n  regexStr: string,\n  value: string,\n  iterations: i32\n): void {\n  const regex = new RegExp(regexStr, \"g\");\n  if (iterations < 0) {\n    while (regex.exec(value) != null);\n  } else {\n    for (let i = 0; i < iterations; i++) {\n      regex.exec(value);\n    }\n  }\n}\n","export class StringIterator {\n  current: u32;\n  cursor: u32 = 0;\n\n  constructor(private sourceString: string) {\n    this.current = this.sourceString.charCodeAt(0);\n  }\n\n  lookahead(distance: u32): u32 {\n    return this.sourceString.charCodeAt(this.cursor + distance);\n  }\n\n  next(): bool {\n    this.cursor++;\n    if (this.cursor >= u32(this.sourceString.length)) {\n      this.current = -1;\n      return false;\n    }\n    this.current = this.sourceString.charCodeAt(this.cursor);\n    return true;\n  }\n\n  currentAsString(): string {\n    return String.fromCharCode(this.current);\n  }\n\n  more(): bool {\n    return this.cursor < u32(this.sourceString.length);\n  }\n\n  copy(): StringIterator {\n    const iterator = new StringIterator(this.sourceString);\n    iterator.cursor = this.cursor;\n    iterator.current = this.current;\n    return iterator;\n  }\n}\n","import { isDigit, Char, isHexadecimalDigit } from \"../char\";\nimport { StringIterator } from \"./string-iterator\";\nimport {\n  AST,\n  RangeRepetitionNode,\n  GroupNode,\n  AssertionNode,\n  CharacterSetNode,\n  CharacterNode,\n  Node,\n  AlternationNode,\n  ConcatenationNode,\n  RepetitionNode,\n  CharacterClassNode,\n  CharacterRangeNode,\n} from \"./node\";\n\nfunction isQuantifier(code: Char): bool {\n  return code == Char.Question || code == Char.Plus || code == Char.Asterisk;\n}\n\n// characters which have special meaning within character sets\nfunction isCharacterSetSpecialChar(code: Char): bool {\n  return (\n    code == Char.Caret ||\n    code == Char.Minus ||\n    code == Char.RightSquareBracket ||\n    code == Char.Backslash\n  );\n}\n\nfunction isCharacterClass(code: u32): bool {\n  switch (code) {\n    case Char.d:\n    case Char.D:\n    case Char.Dot:\n    case Char.w:\n    case Char.W:\n    case Char.s:\n    case Char.S:\n    case Char.t:\n    case Char.r:\n    case Char.n:\n    case Char.v:\n    case Char.f:\n      return true;\n  }\n  return false;\n}\n\nfunction isAssertion(code: u32): bool {\n  return code == Char.Dollar || code == Char.Caret; // \"$\" or \"^\"\n}\n\nfunction isSpecialCharacter(code: u32): bool {\n  switch (code) {\n    case Char.Dollar:\n    case Char.LeftParenthesis:\n    case Char.RightParenthesis:\n    case Char.Asterisk:\n    case Char.Plus:\n    case Char.Dot:\n    case Char.Question:\n    case Char.Backslash:\n    case Char.LeftSquareBracket:\n    case Char.RightSquareBracket:\n    case Char.Caret:\n    case Char.VerticalBar:\n    case Char.LeftCurlyBrace:\n    case Char.RightCurlyBrace:\n      return true;\n  }\n  return false;\n}\n\nclass Range {\n  constructor(public from: i32, public to: i32) {}\n}\n\nexport class Parser {\n  iterator: StringIterator;\n\n  private constructor(input: string) {\n    this.iterator = new StringIterator(input);\n  }\n\n  static toAST(input: string): AST {\n    return new Parser(input).toAST();\n  }\n\n  private eatToken(value: u32 = -1): u32 {\n    const currentToken = this.iterator.current;\n    if (value != -1 && this.iterator.current != value) {\n      throw new Error(\"invalid token\");\n    }\n    this.iterator.next();\n    return currentToken;\n  }\n\n  private toAST(): AST {\n    if (!this.iterator.more()) {\n      return new AST(null);\n    } else {\n      return new AST(this.parseSequence());\n    }\n  }\n\n  private parseCharacterCode(code: u32): Node {\n    const length = code == Char.x ? 2 : 4;\n    // check whether we have the correct number of digits ahead\n    for (let i = 0; i < length; i++) {\n      if (!isHexadecimalDigit(this.iterator.lookahead(i + 1))) {\n        return new CharacterNode(this.eatToken());\n      }\n    }\n    // if so, parse the hex string\n    this.eatToken(code);\n    let value = \"\";\n    for (let i = 0; i < length; i++) {\n      value += this.iterator.currentAsString();\n      this.eatToken();\n    }\n    return new CharacterNode(u32(parseInt(value, 16)));\n  }\n\n  private parseCharacter(): Node {\n    let token = this.iterator.current;\n    if (this.iterator.current == Char.Backslash) {\n      this.eatToken(Char.Backslash);\n      token = this.iterator.current;\n      if (isSpecialCharacter(token)) {\n        this.eatToken();\n        return new CharacterNode(token);\n      } else if (isAssertion(token)) {\n        return new CharacterNode(this.eatToken());\n      } else if (token == Char.x) {\n        return this.parseCharacterCode(Char.x);\n      } else if (token == Char.u) {\n        return this.parseCharacterCode(Char.u);\n      } else if (isCharacterClass(token)) {\n        return new CharacterSetNode(this.eatToken());\n      } else {\n        return new CharacterNode(this.eatToken());\n      }\n    }\n\n    if (isAssertion(token)) {\n      return new AssertionNode(this.eatToken());\n    }\n\n    if (token == Char.Dot) {\n      this.eatToken(Char.Dot);\n      return new CharacterSetNode(Char.Dot);\n    }\n\n    return new CharacterNode(this.eatToken());\n  }\n\n  private maybeParseDigit(): i32 {\n    let digitStr = \"\";\n    while (this.iterator.more()) {\n      const token = this.iterator.current;\n      if (isDigit(token)) {\n        digitStr += this.iterator.currentAsString();\n      } else {\n        return digitStr == \"\" ? -1 : <i32>parseInt(digitStr);\n      }\n      this.eatToken();\n    }\n    return digitStr == \"\" ? -1 : <i32>parseInt(digitStr);\n  }\n\n  private maybeParseRepetitionRange(): Range | null {\n    // snapshot\n    const iteratorCopy = this.iterator.copy();\n    this.eatToken(Char.LeftCurlyBrace);\n\n    const from = this.maybeParseDigit();\n    if (from == -1) {\n      return null;\n    }\n    if (this.iterator.current == Char.RightCurlyBrace) {\n      this.eatToken();\n      return new Range(from, from);\n    } else if (this.iterator.current == Char.Comma) {\n      this.eatToken();\n      const to = this.maybeParseDigit();\n      // @ts-ignore\n      if (this.iterator.current == Char.RightCurlyBrace) {\n        this.eatToken();\n        return new Range(from, to);\n      }\n    }\n\n    this.iterator = iteratorCopy;\n    return null;\n  }\n\n  private isGreedy(): bool {\n    if (this.iterator.current == Char.Question) {\n      this.eatToken();\n      return false;\n    }\n    return true;\n  }\n\n  private isCapturing(): bool {\n    if (\n      this.iterator.current == Char.Question &&\n      this.iterator.lookahead(1) == Char.Colon\n    ) {\n      this.eatToken(Char.Question);\n      this.eatToken(Char.Colon);\n      return false;\n    }\n    return true;\n  }\n\n  // parses a sequence of chars\n  private parseSequence(): Node {\n    let nodes = new Array<Node>();\n    while (this.iterator.more()) {\n      const token = this.iterator.current;\n      if (token == Char.RightParenthesis) break;\n      // @ts-ignore\n      if (token == Char.VerticalBar) {\n        this.eatToken(Char.VerticalBar);\n        const left = nodes.length > 1 ? new ConcatenationNode(nodes) : nodes[0];\n        nodes = [new AlternationNode(left, this.parseSequence())];\n        // @ts-ignore\n      } else if (token == Char.LeftParenthesis) {\n        this.eatToken(Char.LeftParenthesis);\n        const capturing = this.isCapturing();\n        nodes.push(new GroupNode(this.parseSequence(), capturing));\n        this.eatToken(Char.RightParenthesis);\n        // @ts-ignore\n      } else if (token == Char.LeftCurlyBrace) {\n        const range = this.maybeParseRepetitionRange();\n        if (range != null) {\n          const expression = nodes.pop();\n          nodes.push(\n            new RangeRepetitionNode(\n              expression,\n              range.from,\n              range.to,\n              this.isGreedy()\n            )\n          );\n        } else {\n          // this is not the start of a repetition, it's just a char!\n          nodes.push(this.parseCharacter());\n        }\n      } else if (isQuantifier(token)) {\n        if (nodes.length === 0) {\n          throw new Error(\"Invalid regular expression: Nothing to repeat\");\n        }\n\n        const expression = nodes.pop();\n        const quantifier = this.eatToken();\n        nodes.push(new RepetitionNode(expression, quantifier, this.isGreedy()));\n        // @ts-ignore\n      } else if (token == Char.LeftSquareBracket) {\n        nodes.push(this.parseCharacterClass());\n      } else {\n        nodes.push(this.parseCharacter());\n      }\n    }\n\n    return nodes.length > 1 ? new ConcatenationNode(nodes) : nodes[0];\n  }\n\n  private parseCharacterRange(): Node {\n    const from = this.eatToken();\n    this.eatToken(Char.Minus);\n    const to = this.eatToken();\n    return new CharacterRangeNode(from, to);\n  }\n\n  private parseCharacterClass(): CharacterClassNode {\n    this.eatToken(Char.LeftSquareBracket);\n\n    const negated = this.iterator.current == Char.Caret;\n    if (negated) {\n      this.eatToken(Char.Caret);\n    }\n\n    const nodes = new Array<Node>();\n    while (\n      this.iterator.current != Char.RightSquareBracket ||\n      nodes.length == 0\n    ) {\n      // lookahead for character range\n      if (\n        this.iterator.current != Char.Backslash &&\n        this.iterator.lookahead(1) == Char.Minus &&\n        this.iterator.lookahead(2) != Char.RightSquareBracket\n      ) {\n        nodes.push(this.parseCharacterRange());\n      } else {\n        // have we encountered a backslash?\n        if (this.iterator.current == Char.Backslash) {\n          this.eatToken();\n          if (isCharacterSetSpecialChar(this.iterator.current)) {\n            // if it was a backslashed special char, treat as a regular char\n            nodes.push(new CharacterNode(this.eatToken()));\n          } else {\n            // otherwise this is a character class\n            nodes.push(new CharacterSetNode(this.eatToken()));\n          }\n        } else {\n          nodes.push(new CharacterNode(this.eatToken()));\n        }\n      }\n\n      if (!this.iterator.more()) {\n        throw new SyntaxError(\"Unterminated character class\");\n      }\n    }\n    this.eatToken(Char.RightSquareBracket);\n    return new CharacterClassNode(nodes, negated);\n  }\n}\n","import { Char } from \"../char\";\nimport { replaceAtIndex } from \"../util\";\n\nexport const enum NodeType {\n  AST,\n  Assertion,\n  Alternation,\n  Concatenation,\n  Character,\n  CharacterClass,\n  CharacterSet,\n  CharacterRange,\n  Repetition,\n  RangeRepetition,\n  Group,\n}\n\nexport abstract class Node {\n  @lazy static readonly emptyArray: Node[] = new Array<Node>();\n  constructor(public type: NodeType) {}\n\n  children(): Node[] {\n    return Node.emptyArray;\n  }\n\n  abstract clone(): Node;\n\n  replace(node: Node, replacement: Node): void {\n    throw new Error(\"replace not implemented for this node type\");\n  }\n}\n\nexport class AST extends Node {\n  constructor(public body: Node | null) {\n    super(NodeType.AST);\n  }\n\n  children(): Node[] {\n    return this.body != null ? [this.body as Node] : Node.emptyArray;\n  }\n\n  clone(): Node {\n    const body = this.body;\n    return new AST(body != null ? body.clone() : null);\n  }\n\n  replace(node: Node, replacement: Node): void {\n    this.body = replacement;\n  }\n}\n\nexport class ConcatenationNode extends Node {\n  constructor(public expressions: Node[]) {\n    super(NodeType.Concatenation);\n  }\n\n  children(): Node[] {\n    return this.expressions;\n  }\n\n  clone(): Node {\n    return new ConcatenationNode(\n      this.expressions.slice(0).map<Node>((s) => s.clone())\n    );\n  }\n\n  replace(node: Node, replacement: Node): void {\n    const expressions = this.expressions;\n    const index = expressions.indexOf(node);\n    this.expressions = replaceAtIndex(expressions, index, replacement);\n  }\n}\n\nexport class CharacterClassNode extends Node {\n  constructor(public expressions: Node[], public negated: bool) {\n    super(NodeType.CharacterClass);\n  }\n\n  clone(): Node {\n    return new CharacterClassNode(\n      this.expressions.slice(0).map<Node>((s) => s.clone()),\n      this.negated\n    );\n  }\n}\n\nexport class CharacterRangeNode extends Node {\n  constructor(public from: u32, public to: u32) {\n    super(NodeType.CharacterRange);\n  }\n\n  static is(node: Node): bool {\n    return node.type == NodeType.CharacterRange;\n  }\n\n  clone(): Node {\n    return new CharacterRangeNode(this.from, this.to);\n  }\n}\n\nexport class CharacterNode extends Node {\n  constructor(public char: u32) {\n    super(NodeType.Character);\n  }\n\n  clone(): Node {\n    return new CharacterNode(this.char);\n  }\n}\n\nexport class AssertionNode extends Node {\n  constructor(public kind: Char) {\n    super(NodeType.Assertion);\n  }\n\n  static is(node: Node, kind: Char = Char.None): bool {\n    return (\n      node.type == NodeType.Assertion &&\n      ((node as AssertionNode).kind == kind || kind == Char.None)\n    );\n  }\n\n  clone(): Node {\n    return new AssertionNode(this.kind);\n  }\n}\n\nexport class CharacterSetNode extends Node {\n  constructor(public charClass: Char) {\n    super(NodeType.CharacterSet);\n  }\n\n  clone(): Node {\n    return new CharacterSetNode(this.charClass);\n  }\n}\n\nexport class RepetitionNode extends Node {\n  constructor(\n    public expression: Node,\n    public quantifier: Char,\n    public greedy: bool = true\n  ) {\n    super(NodeType.Repetition);\n  }\n\n  clone(): Node {\n    return new RepetitionNode(this.expression.clone(), this.quantifier);\n  }\n\n  replace(node: Node, replacement: Node): void {\n    this.expression = replacement;\n  }\n\n  children(): Node[] {\n    return [this.expression];\n  }\n}\n\nexport class RangeRepetitionNode extends Node {\n  constructor(\n    public expression: Node,\n    public from: i32,\n    public to: i32,\n    public greedy: bool = true\n  ) {\n    super(NodeType.RangeRepetition);\n    if (expression.type == NodeType.RangeRepetition) {\n      throw new Error(\"The preceding token is not quantifiable\");\n    }\n  }\n\n  clone(): Node {\n    return new RangeRepetitionNode(this.expression.clone(), this.from, this.to);\n  }\n\n  replace(node: Node, replacement: Node): void {\n    this.expression = replacement;\n  }\n\n  children(): Node[] {\n    return [this.expression];\n  }\n}\n\nexport class AlternationNode extends Node {\n  constructor(public left: Node, public right: Node) {\n    super(NodeType.Alternation);\n  }\n\n  static is(node: Node): bool {\n    return node.type == NodeType.Alternation;\n  }\n\n  children(): Node[] {\n    return [this.left, this.right];\n  }\n\n  clone(): Node {\n    return new AlternationNode(this.left.clone(), this.right.clone());\n  }\n\n  replace(node: Node, replacement: Node): void {\n    if (this.left === node) {\n      this.left = replacement;\n    } else {\n      this.right = replacement;\n    }\n  }\n}\n\nexport class GroupNode extends Node {\n  @lazy static _id: i32 = 0;\n\n  constructor(\n    public expression: Node,\n    public capturing: bool,\n    public id: i32 = -1\n  ) {\n    super(NodeType.Group);\n    if (id == -1) {\n      this.id = GroupNode._id++;\n    }\n  }\n\n  children(): Node[] {\n    return [this.expression];\n  }\n\n  clone(): Node {\n    return new GroupNode(this.expression.clone(), this.capturing, this.id);\n  }\n\n  replace(node: Node, replacement: Node): void {\n    this.expression = replacement;\n  }\n}\n","// @ts-ignore\n@lazy\nexport const enum Char {\n  None = -1,\n  HorizontalTab = 0x09,\n  LineFeed = 0x0a,\n  VerticalTab = 0x0b,\n  FormFeed = 0x0c,\n  CarriageReturn = 0x0d,\n  Space = 0x20,\n  Dollar = 0x24, // \"$\"\n  LeftParenthesis = 0x28,\n  RightParenthesis = 0x29,\n  Asterisk = 0x2a, // \"*\"\n  Plus = 0x2b, // \"+\"\n  Comma = 0x2c, // \"*\"\n  Minus = 0x2d, // \"-\"\n  Dot = 0x2e, // \".\"\n  Zero = 0x30,\n  Nine = 0x39,\n  Colon = 0x3a,\n  Question = 0x3f, // \"?\"\n  A = 0x41,\n  D = 0x44,\n  S = 0x53,\n  W = 0x57,\n  Z = 0x5a,\n  LeftSquareBracket = 0x5b, // \"[\"\n  Backslash = 0x5c, // \"\\\"\n  RightSquareBracket = 0x5d, // \"]\"\n  Caret = 0x5e, // \"^\"\n  Underscore = 0x5f,\n  a = 0x61,\n  d = 0x64,\n  f = 0x66,\n  n = 0x6e,\n  r = 0x72,\n  s = 0x73,\n  t = 0x74,\n  u = 0x75,\n  v = 0x76,\n  w = 0x77,\n  x = 0x78,\n  z = 0x7a,\n  LeftCurlyBrace = 0x7b /* { */,\n  VerticalBar = 0x7c /* | */,\n  RightCurlyBrace = 0x7d /* { */,\n  NonBreakingSpace = 0xa0,\n}\n\n// @ts-ignore \n@inline\nfunction inRange(value: u32, from: u32, to: u32): bool {\n  if (ASC_TARGET == 1) {\n    // makes use of unsigned integer operations, making this\n    // approach a little faster when compiled to WASM\n    return value - from < (to - from + 1);\n  } else {\n    return value >= from && value <= to;\n  }\n}\n\nexport function isDigit(code: u32): bool {\n  return inRange(code, Char.Zero, Char.Nine);\n}\n\nexport function isHexadecimalDigit(code: u32): bool {\n  return isDigit(code) || inRange(code, Char.a, Char.f);\n}\n\nexport function isLowercaseAlpha(code: u32): bool {\n  return inRange(code, Char.a, Char.z);\n}\n\nexport function isUppercaseAlpha(code: u32): bool {\n  return inRange(code, Char.A, Char.Z);\n}\n\nexport function isAlpha(code: u32): bool {\n  if (ASC_TARGET == 1) {\n    return (code | 32) - Char.a < 26;\n  } else {\n    return inRange(code, Char.a, Char.z) || inRange(code, Char.A, Char.Z);\n  }\n}\n\nexport function isWhitespace(code: u32): bool {\n  switch (code) {\n    case Char.Space:\n    case Char.HorizontalTab:\n    case Char.VerticalTab:\n    case Char.FormFeed:\n    case Char.LineFeed:\n    case Char.CarriageReturn:\n    case Char.NonBreakingSpace:\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202f: // <NNS>\n    case 0x205f: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xfeff:\n      return true; // <ZWNBSP>\n  }\n  if (inRange(code, 0x2000, 0x200a)) {\n    return true;\n  }\n  return false;\n}\n","export function last<T>(arr: T[]): T {\n  return unchecked(arr[arr.length - 1]);\n}\n\nexport function first<T>(arr: T[]): T {\n  return unchecked(arr[0]);\n}\n\nexport function replaceAtIndex<T>(arr: T[], index: u32, item: T): T[] {\n  let res = arr.slice(0);\n  unchecked((res[index] = item));\n  return res;\n}\n\nexport class Range {\n  constructor(public from: i32, public to: i32) {}\n\n  intersection(other: Range): Range | null {\n    const lower = i32(Math.max(this.from, other.from));\n    const upper = i32(Math.min(this.to, other.to));\n    return lower < upper ? new Range(lower, upper) : null;\n  }\n\n  offset(value: i32): Range {\n    return new Range(this.from + value, this.to + value);\n  }\n\n  contains(value: i32): bool {\n    return value >= this.from && value <= this.to;\n  }\n}\n","import { Char } from \"../char\";\nimport {\n  AST,\n  ConcatenationNode,\n  Node,\n  NodeType,\n  RangeRepetitionNode,\n  RepetitionNode,\n} from \"./node\";\n\nexport class NodeVisitor {\n  constructor(public node: Node, public parentNode: Node) {}\n}\n\nfunction walkNode(\n  node: Node,\n  parentNode: Node,\n  visitor: (node: NodeVisitor) => void\n): void {\n  const children = node.children();\n  for (let i = children.length - 1; i >= 0; i--) {\n    walkNode(children[i], node, visitor);\n  }\n\n  const nodeVisitor = new NodeVisitor(node, parentNode);\n  visitor(nodeVisitor);\n}\n\n// depth first, right-left walker\nexport function walker(ast: AST, visitor: (node: NodeVisitor) => void): void {\n  let node = ast.body;\n  if (node != null) {\n    walkNode(node, ast, visitor);\n  }\n}\n\n/**\n range quantifiers are implemented via 'expansion', which significantly \n increases the size of the AST. This imposes a hard limit to prevent \n memory-related issues\n*/\n// @ts-ignore\n@lazy const QUANTIFIER_LIMIT = 1000;\n\nfunction parentAsConcatNode(visitor: NodeVisitor): ConcatenationNode {\n  let concatNode: ConcatenationNode | null = null;\n  let parentNode = visitor.parentNode;\n  if (parentNode.type != NodeType.Concatenation) {\n    let node = visitor.node;\n    concatNode = new ConcatenationNode([node]);\n    parentNode.replace(node, concatNode);\n    return concatNode;\n  }\n  return parentNode as ConcatenationNode;\n}\n\n// take each range repetition and replace with a concatenation\n// of cloned nodes, e.g. a{2} becomes aa\nexport function expandRepetitions(visitor: NodeVisitor): void {\n  let node = visitor.node;\n  if (node.type == NodeType.RangeRepetition) {\n    // find the parent\n    const rangeRepNode = node as RangeRepetitionNode;\n\n    if (rangeRepNode.to > QUANTIFIER_LIMIT) {\n      throw new Error(\n        \"Cannot handle range quantifiers > \" + QUANTIFIER_LIMIT.toString()\n      );\n    }\n    const concatNode = parentAsConcatNode(visitor);\n    const expressions = concatNode.expressions;\n\n    // locate the original index\n    const index = expressions.indexOf(rangeRepNode);\n\n    const from = rangeRepNode.from;\n    const expression = rangeRepNode.expression;\n    // create multiple clones\n    const clones = new Array<Node>(from);\n    // a{4} => aaaa\n    if (from > 0) {\n      clones[0] = expression;\n      for (let i = 1; i < from; i++) {\n        clones[i] = expression.clone();\n      }\n    }\n\n    if (rangeRepNode.to == -1) {\n      // a{4,} => aaaaa*\n      clones.push(\n        new RepetitionNode(\n          expression.clone(),\n          Char.Asterisk,\n          rangeRepNode.greedy\n        )\n      );\n    } else {\n      // a{4,6} => aaaaa?a?\n      const count = rangeRepNode.to - rangeRepNode.from;\n      for (let i = 0; i < count; i++) {\n        clones.push(\n          new RepetitionNode(\n            expression.clone(),\n            Char.Question,\n            rangeRepNode.greedy\n          )\n        );\n      }\n    }\n\n    // replace the rangeRepNode with the clones\n    concatNode.expressions = expressions\n      .slice(0, index)\n      .concat(clones)\n      .concat(expressions.slice(index + 1));\n  }\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol, strtod } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f64 {\n    return strtod(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","import {\n  AST,\n  CharacterNode,\n  Node,\n  ConcatenationNode,\n  RepetitionNode,\n  AlternationNode,\n  CharacterClassNode,\n  CharacterSetNode,\n  GroupNode,\n  NodeType,\n} from \"../parser/node\";\n\nimport { Char } from \"../char\";\nimport { Matcher } from \"./matcher\";\nimport { Flags } from \"../regexp\";\nimport { MatchResult } from \"./types\";\n\n/* eslint @typescript-eslint/no-empty-function: [\"error\", { \"allow\": [\"constructors\", \"methods\"] }] */\nexport class State {\n  @lazy static _stateId: u32 = 0;\n  constructor(\n    public transitions: State[] = [],\n    public id: u32 = State._stateId++\n  ) {}\n\n  matches(input: string, position: u32): MatchResult {\n    return MatchResult.Ignore;\n  }\n}\n\nexport class GroupStartMarkerState extends State {\n  location: i32 = -1;\n  // a bit yucky - storing transient state in the state machine!\n  capture: string = \"\";\n  // captures from the path through the NFA that reaches the end are flagged\n  flagged: bool = false;\n\n  constructor(next: State, public capturing: bool, public groupId: i32) {\n    super();\n    this.transitions.push(next);\n  }\n\n  matches(input: string, position: u32): MatchResult {\n    this.location = position;\n    return MatchResult.Ignore;\n  }\n}\n\nexport class GroupEndMarkerState extends State {\n  constructor(next: State, public startMarker: GroupStartMarkerState) {\n    super();\n    this.transitions.push(next);\n  }\n\n  matches(input: string, position: u32): MatchResult {\n    if (this.startMarker.capturing) {\n      this.startMarker.capture = input.substring(\n        this.startMarker.location,\n        position\n      );\n    }\n    return MatchResult.Ignore;\n  }\n}\n\nexport class MatcherState<T extends Matcher> extends State {\n  ignoreCase: bool = false;\n\n  constructor(private matcher: T, next: State) {\n    super();\n    this.transitions.push(next);\n  }\n\n  matches(input: string, position: u32): MatchResult {\n    return this.matcher.matches(input.charCodeAt(position))\n      ? MatchResult.Match\n      : MatchResult.Fail;\n  }\n}\n\nexport class Automata {\n  static toNFA(ast: AST, flags: Flags): Automata {\n    return new AutomataFactor(flags).automataForNode(ast.body);\n  }\n\n  static fromEpsilon(): Automata {\n    const start = new State();\n    const end = new State();\n    start.transitions.push(end);\n    return new Automata(start, end);\n  }\n\n  static fromMatcher<T extends Matcher>(matcher: T): Automata {\n    const end = new State();\n    const start = new MatcherState<T>(matcher, end);\n    return new Automata(start, end);\n  }\n\n  constructor(public start: State, public end: State) {}\n}\n\nfunction concat(first: Automata, second: Automata): Automata {\n  first.end.transitions.push(second.start);\n  return new Automata(first.start, second.end);\n}\n\nfunction union(first: Automata, second: Automata): Automata {\n  const start = new State();\n  start.transitions.push(first.start);\n  start.transitions.push(second.start);\n  const end = new State();\n  first.end.transitions.push(end);\n  second.end.transitions.push(end);\n  return new Automata(start, end);\n}\n\nfunction closure(nfa: Automata, greedy: bool): Automata {\n  const start = new State();\n  const end = new State();\n  if (greedy) {\n    nfa.end.transitions.push(nfa.start);\n    nfa.end.transitions.push(end);\n    start.transitions.push(nfa.start);\n    start.transitions.push(end);\n  } else {\n    nfa.end.transitions.push(end);\n    nfa.end.transitions.push(nfa.start);\n    start.transitions.push(end);\n    start.transitions.push(nfa.start);\n  }\n  return new Automata(start, end);\n}\n\nfunction zeroOrOne(nfa: Automata, greedy: bool): Automata {\n  const start = new State();\n  const end = new State();\n  if (greedy) {\n    start.transitions.push(nfa.start);\n    start.transitions.push(end);\n  } else {\n    start.transitions.push(end);\n    start.transitions.push(nfa.start);\n  }\n  nfa.end.transitions.push(end);\n  return new Automata(start, end);\n}\n\nfunction oneOrMore(nfa: Automata, greedy: bool): Automata {\n  const start = new State();\n  const end = new State();\n  start.transitions.push(nfa.start);\n  if (greedy) {\n    nfa.end.transitions.push(nfa.start);\n    nfa.end.transitions.push(end);\n  } else {\n    nfa.end.transitions.push(end);\n    nfa.end.transitions.push(nfa.start);\n  }\n  return new Automata(start, end);\n}\n\nfunction group(nfa: Automata, capturing: bool, id: i32): Automata {\n  // groups are implemented by wrapping the automata with\n  // a pair of markers that record matches\n  const startMarker = new GroupStartMarkerState(nfa.start, capturing, id);\n  const end = new State();\n  const endMarker = new GroupEndMarkerState(end, startMarker);\n  nfa.end.transitions.push(endMarker);\n  return new Automata(startMarker, end);\n}\n\nclass AutomataFactor {\n  constructor(private flags: Flags) {}\n\n  // recursively builds an automata for the given AST\n  automataForNode(expression: Node | null): Automata {\n    if (expression == null) {\n      return Automata.fromEpsilon();\n    }\n\n    switch (expression.type) {\n      case NodeType.Repetition: {\n        const node = expression as RepetitionNode;\n        const automata = this.automataForNode(node.expression);\n        const quantifier = node.quantifier;\n        if (quantifier == Char.Question) {\n          return zeroOrOne(automata, node.greedy);\n        } else if (quantifier == Char.Plus) {\n          return oneOrMore(automata, node.greedy);\n        } else if (quantifier == Char.Asterisk) {\n          return closure(automata, node.greedy);\n        } else {\n          throw new Error(\n            \"unsupported quantifier - \" + String.fromCharCode(quantifier)\n          );\n        }\n      }\n      case NodeType.Character:\n        return Automata.fromMatcher(\n          Matcher.fromCharacterNode(expression as CharacterNode, this.flags)\n        );\n      case NodeType.Concatenation: {\n        const expressions = (expression as ConcatenationNode).expressions;\n        if (expressions.length == 0) {\n          return Automata.fromEpsilon();\n        }\n        let automata = this.automataForNode(expressions[0]);\n        for (let i = 1, len = expressions.length; i < len; i++) {\n          automata = concat(automata, this.automataForNode(expressions[i]));\n        }\n        return automata;\n      }\n      case NodeType.Alternation: {\n        const node = expression as AlternationNode;\n        return union(\n          this.automataForNode(node.left),\n          this.automataForNode(node.right)\n        );\n      }\n      case NodeType.CharacterClass:\n        return Automata.fromMatcher(\n          Matcher.fromCharacterSetNode(\n            expression as CharacterClassNode,\n            this.flags\n          )\n        );\n      case NodeType.CharacterSet:\n        return Automata.fromMatcher(\n          Matcher.fromCharacterClassNode(\n            expression as CharacterSetNode,\n            this.flags\n          )\n        );\n      case NodeType.Group: {\n        const node = expression as GroupNode;\n        return group(\n          this.automataForNode(node.expression),\n          node.capturing,\n          node.id\n        );\n      }\n      case NodeType.Assertion:\n        return Automata.fromEpsilon();\n      default:\n        throw new Error(\"un-recognised AST node\");\n    }\n  }\n}\n\nexport { MatchResult } from \"./types\";\n","import { isDigit, isAlpha, isWhitespace, Char } from \"../char\";\n\nimport {\n  CharacterNode,\n  CharacterClassNode,\n  CharacterSetNode,\n  CharacterRangeNode,\n  NodeType,\n} from \"../parser/node\";\nimport { Flags } from \"../regexp\";\nimport { Range } from \"../util\";\n\nconst enum MatcherType {\n  Character,\n  CharacterRange,\n  CharacterSet,\n  CharacterClass,\n}\nexport class Matcher {\n  @lazy static _flags!: Flags;\n\n  constructor(readonly type: MatcherType) {}\n\n  matches(code: u32): bool {\n    return false;\n  }\n\n  static fromCharacterClassNode(\n    node: CharacterSetNode,\n    flags: Flags\n  ): CharacterSetMatcher {\n    return new CharacterSetMatcher(node.charClass, flags.dotAll);\n  }\n\n  static fromCharacterRangeNode(\n    node: CharacterRangeNode,\n    flags: Flags\n  ): CharacterRangeMatcher {\n    return new CharacterRangeMatcher(\n      new Range(node.from, node.to),\n      flags.ignoreCase\n    );\n  }\n\n  static fromCharacterSetNode(\n    node: CharacterClassNode,\n    flags: Flags\n  ): CharacterClassMatcher {\n    Matcher._flags = flags;\n    const matchers = node.expressions.map<Matcher>((exp) => {\n      switch (exp.type) {\n        case NodeType.CharacterRange:\n          return Matcher.fromCharacterRangeNode(\n            exp as CharacterRangeNode,\n            Matcher._flags\n          );\n        case NodeType.Character:\n          return Matcher.fromCharacterNode(\n            exp as CharacterNode,\n            Matcher._flags\n          );\n        case NodeType.CharacterSet:\n          return Matcher.fromCharacterClassNode(\n            exp as CharacterSetNode,\n            Matcher._flags\n          );\n        default:\n          throw new Error(\"unsupported node type within character set\");\n      }\n    });\n    return new CharacterClassMatcher(matchers, node.negated);\n  }\n\n  static fromCharacterNode(\n    node: CharacterNode,\n    flags: Flags\n  ): CharacterMatcher {\n    return new CharacterMatcher(node.char, flags.ignoreCase);\n  }\n}\n\nexport class CharacterMatcher extends Matcher {\n  constructor(private character: Char, private ignoreCase: bool) {\n    super(MatcherType.Character);\n    if (ignoreCase) {\n      this.character |= 0x20;\n    }\n  }\n\n  matches(code: u32): bool {\n    if (this.ignoreCase) {\n      code |= 0x20;\n    }\n    return this.character == code;\n  }\n}\n\n// @ts-ignore\n@lazy const LOWERCASE_LETTERS = new Range(Char.a, Char.z);\n// @ts-ignore\n@lazy const UPPERCASE_LETTERS = new Range(Char.A, Char.Z);\n// @ts-ignore\n@lazy const UPPER_LOWER_OFFSET = Char.a - Char.A;\n\nexport class CharacterRangeMatcher extends Matcher {\n  private ranges: Range[];\n\n  constructor(private range: Range, ignoreCase: bool) {\n    super(MatcherType.CharacterRange);\n    this.ranges = [range];\n\n    if (ignoreCase) {\n      const lowerIntersect = range.intersection(LOWERCASE_LETTERS);\n      if (lowerIntersect) {\n        this.ranges.push(lowerIntersect.offset(-UPPER_LOWER_OFFSET));\n      }\n      const upperIntersect = range.intersection(UPPERCASE_LETTERS);\n      if (upperIntersect) {\n        this.ranges.push(upperIntersect.offset(UPPER_LOWER_OFFSET));\n      }\n    }\n  }\n\n  matches(code: u32): bool {\n    for (let i = 0, len = this.ranges.length; i < len; i++) {\n      if (this.ranges[i].contains(code)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport class CharacterSetMatcher extends Matcher {\n  constructor(public charClass: Char, private dotAll: bool) {\n    super(MatcherType.CharacterSet);\n  }\n\n  matches(code: u32): bool {\n    switch (this.charClass) {\n      case Char.d:\n        return isDigit(code);\n      case Char.D:\n        return !isDigit(code);\n      case Char.Dot:\n        return this.dotAll\n          ? true\n          : code != Char.CarriageReturn &&\n              code != Char.LineFeed &&\n              code != 8232 &&\n              code != 8233;\n      case Char.w:\n        return isAlpha(code) || code == Char.Underscore || isDigit(code);\n      case Char.W:\n        return !(isAlpha(code) || code == Char.Underscore || isDigit(code));\n      case Char.s:\n        return isWhitespace(code);\n      case Char.S:\n        return !isWhitespace(code);\n      case Char.t:\n        return code == Char.HorizontalTab;\n      case Char.r:\n        return code == Char.CarriageReturn;\n      case Char.n:\n        return code == Char.LineFeed;\n      case Char.v:\n        return code == Char.VerticalTab;\n      case Char.f:\n        return code == Char.FormFeed;\n\n      default:\n        throw new Error(\n          \"unsupported character class - \" + String.fromCharCode(this.charClass)\n        );\n    }\n  }\n}\n\nexport class CharacterClassMatcher extends Matcher {\n  constructor(public matchers: Matcher[], public negated: bool) {\n    super(MatcherType.CharacterClass);\n  }\n\n  matches(code: u32): bool {\n    let match: bool = false;\n    for (let i = 0, len = this.matchers.length; i < len; i++) {\n      let matcher = this.matchers[i];\n      switch (matcher.type) {\n        case MatcherType.Character:\n          match = (matcher as CharacterMatcher).matches(code);\n          break;\n\n        case MatcherType.CharacterRange:\n          match = (matcher as CharacterRangeMatcher).matches(code);\n          break;\n\n        case MatcherType.CharacterSet:\n          match = (matcher as CharacterSetMatcher).matches(code);\n          break;\n\n        case MatcherType.CharacterClass:\n          match = (matcher as CharacterClassMatcher).matches(code);\n          break;\n      }\n      if (match) break;\n    }\n    return this.negated ? !match : match;\n  }\n}\n","import { Math as JSMath } from \"./bindings/dom\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of π/2 * |x|\n *\n * y = π/4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of π/4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  let shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  let lo = umuldi(p1, q1);\n  let hi = res128_hi;\n\n  let ahi = hi >> 11;\n  let alo = lo >> 11 | hi << 53;\n  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  let magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  let offset = (magnitude >> 52) - 1045;\n  let shift  = offset & 63;\n  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  let s0: u64, s1: u64, s2: u64;\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 / π with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2π)\n  let blo = umuldi(s1, significand);\n  let bhi = res128_hi;\n\n  let ahi = s0 * significand;\n  let clo = (s2 >> 32) * (significand >> 32);\n  let plo = blo + clo;\n  let phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  let rlo = plo << 2;\n  let rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  let slo = <i64>rhi >> 63;\n  let shi = slo >> 1;\n  let q   = (<i64>phi >> 62) - slo;\n\n  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  let signbit = (u ^ rhi) & 0x8000000000000000;\n  let coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  let ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  let q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  let z = x * x;\n  let w = z * z;\n  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  let v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  let z = x * x;\n  let w = z * z;\n  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  let hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  let z: f64, r: f64, v: f64, w: f64, s: f64;\n  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  let ix = hx & 0x7FFFFFFF; // high word of |x|\n  let big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  let a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, <i64>u < 0);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy let random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy let random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    let s: f64, w: f64, z: f64;\n    if (<i32>hx < 0) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    let c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    let u = reinterpret<u64>(x);\n    // Prevent propagation for all input values less than 1.0.\n    // Note musl lib didn't fix this yet.\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\n    let e = u >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    let z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z);\n    let r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    return select(-x, x, <i32>hx < 0);\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let ix = <u32>(reinterpret<u64>(x) >> 32);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let u = reinterpret<u64>(x);\n    let ix = <u32>(u >> 32);\n    let lx = <u32>u;\n    u = reinterpret<u64>(y);\n    let iy = <u32>(u >> 32);\n    let ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    let z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    let t = reinterpret<f64>(u);\n    let r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    let s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    let w = <u32>(u >> 32);\n    let t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = u32(reinterpret<u64>(x) >> 32);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32) & 0x7FFFFFFF;\n    let sign = u32(u >> 63);\n    let k = 0;\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    let c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    let hfx = 0.5 * x;\n    let hxs = x * hfx;\n    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    let hxq = hxs * hxs;\n    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    let twopk = reinterpret<f64>(u);\n    let y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    let ex = i32(ux >> 52);\n    let ey = i32(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    let z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    let c = x * SPLIT;\n    let h = x - c + c;\n    let l = x - h;\n    let hx = x * x;\n    let lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    let hy = y * y;\n    let ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 0;\n    let sign = hx >> 31;\n    if (sign || hx < 0x00100000) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = u32(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += i32(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    let f = x - 1.0;\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let val_hi = hi * ivln10hi;\n    let dk = <f64>k;\n    let y = dk * log10_2hi;\n    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 1;\n    let c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || bool(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = u32(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = i32(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += i32(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = i32(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = i32(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = u32(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = u32(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    // Instead zero seed use golden ratio:\n    // phi = (1 + sqrt(5)) / 2\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\n    if (value == 0) value = 0x9e3779b97f4a7c15;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    random_seeded = true;\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    let s1 = random_state0_64;\n    let s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    let r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  export function round(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f64>(x);\n      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return bool(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    let a = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >>> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    let n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    let y = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    let y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    let sx = ux >> 63;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= u64(-1) >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    let shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    let uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u64(-1) >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    let q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return <i64>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3FE921FB) {  // |x| ~<= π/4\n      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n    let s = sin_kern(y0, y1, 1);\n    let c = cos_kern(y0, y1);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  let p = z * (pS0 + z * (pS1 + z * pS2));\n  let q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n\n  let offset = (u >> 23) - 152;\n  let shift  = u64(offset & 63);\n  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  let hi = (b1 >> (64 - shift)) | (b0 << shift);\n  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  let product = mantissa * hi + (mantissa * lo >> 32);\n  let r: i64 = product << 2;\n  let q = i32((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { // π * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  let q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  let z = x * x;\n  let w = z * z;\n  let r = S3 + z * S4;\n  let s = z * x;\n  return f32((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  let z = x * x;\n  let w = z * z;\n  let r = C2 + z * C3;\n  return f32(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  let z = x * x;\n  let r = T4 + z * T5;\n  let t = T2 + z * T3;\n  let w = z * z;\n  let s = z * x;\n  let u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return f32(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  let i = reinterpret<i64>(x);\n  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  let xx = x * x;\n  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  let n = nearest(x);\n  x -= n;\n  let xx = x * x;\n  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let hx = reinterpret<u32>(x);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    let z: f32, w: f32, s: f32;\n    if (<i32>hx < 0) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    let df = reinterpret<f32>(hx & 0xFFFFF000);\n    let c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x);\n    let a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let sx = x;\n    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z); // sic\n    x = f32(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    let ix = reinterpret<u32>(x);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * aT4));\n    let s2 = w * (aT1 + w * aT3);\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    let u = reinterpret<u32>(x);\n    let y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let ix = reinterpret<u32>(x);\n    let iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    let z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    let t = <f64>reinterpret<f32>(u);\n    let r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {  // |x| ~<= 5π/4\n        if (ux > 0x4016CBE3) { // |x|  ~> 3π/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ux <= 0x40E231D5) {  // |x| ~<= 9π/4\n        if (ux > 0x40AFEDDF) { // |x|  ~> 7π/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    let sign = u >> 31;\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    let c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    let hfx: f32 = 0.5 * x;\n    let hxs: f32 = x * hfx;\n    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    let twopk = reinterpret<f32>(u);\n    let y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    let z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      let sign = u >> 31;\n      if (sign || u < 0x00800000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += i32(u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    let ux = reinterpret<u32>(x);\n    let k = 0;\n    let sign = ux >> 31;\n    if (sign || ux < 0x00800000) {\n      if (ux << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ux = reinterpret<u32>(x);\n    } else if (ux >= 0x7F800000) {\n      return x;\n    } else if (ux == 0x3F800000) {\n      return 0;\n    }\n    ux += 0x3F800000 - 0x3F3504F3;\n    k += i32(ux >> 23) - 0x7F;\n    ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ux);\n    let f = x - 1.0;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let hi = f - hfsq;\n    ux = reinterpret<u32>(hi);\n    ux &= 0xFFFFF000;\n    hi = reinterpret<f32>(ux);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    let ix = reinterpret<u32>(x);\n    let c: f32 = 0;\n    let f: f32 = 0;\n    let k = 1;\n    if (ix < 0x3ED413D0 || bool(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = i32(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ux = reinterpret<u32>(x);\n      let k = 0;\n      let sign = ux >> 31;\n      if (sign || ux < 0x00800000) {\n        if (ux << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ux = reinterpret<u32>(x);\n      } else if (ux >= 0x7F800000) {\n        return x;\n      } else if (ux == 0x3F800000) {\n        return 0;\n      }\n      ux += 0x3F800000 - 0x3F3504F3;\n      k += i32(ux >> 23) - 0x7F;\n      ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ux);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = <i32>uy < 0 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = <i32>uy < 0 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    let s0 = random_state0_32;\n    let s1 = random_state1_32;\n    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  export function round(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f32>(x);\n      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let a = reinterpret<f32>(u);\n    let h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // argument reduction\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    let t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    let y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let sm = ux & 0x80000000;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    let shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u32(-1) >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    let q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return <i32>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3π/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    let s = sin_kernf(y);\n    let c = cos_kernf(y);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  let out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  let out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","import { State } from \"./nfa\";\n\nexport function walker(\n  state: State,\n  visitor: (state: State) => void,\n  visited: State[] = []\n): void {\n  if (visited.includes(state)) return;\n  visitor(state);\n  visited.push(state);\n  const nextStates = state.transitions;\n  for (let i = 0, len = nextStates.length; i < len; i++) {\n    walker(nextStates[i], visitor, visited);\n  }\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport { first, last } from '../helpers/lodashHelpers'\nimport {\n    ConfigBodyV2 as ConfigBody,\n    TargetV2 as PublicTarget,\n    FeatureV2 as PublicFeature,\n    BucketedUserConfig,\n    Rollout as PublicRollout,\n    DVCPopulatedUser,\n    SDKVariable,\n    SDKFeature,\n    RolloutStage,\n    TargetV2 as Target,\n    Variation,\n    FeatureVariation,\n    FeatureV2 as Feature,\n    EvalReason,\n    EVAL_REASONS,\n    EVAL_REASON_DETAILS,\n} from '../types'\n\nimport { murmurhashV3 } from '../helpers/murmurhash'\nimport { _evaluateOperator } from './segmentation'\nimport {\n    getStringFromJSONOptional,\n    getValueFromJSONOptional,\n} from '../helpers/jsonHelpers'\n\n// Max value of an unsigned 32-bit integer, which is what murmurhash returns\nconst MAX_HASH_VALUE: f64 = 4294967295\nconst baseSeed: i32 = 1\nconst DEFAULT_BUCKETING_VALUE = 'null'\n\nexport class BoundedHash {\n    public rolloutHash: f64\n    public bucketingHash: f64\n}\n\nexport function _generateBoundedHashes(\n    user_id: string,\n    target_id: string,\n): BoundedHash {\n    // The seed provided to murmurhash must be a number\n    // So we first hash the target_id with a constant seed\n\n    const targetHash = murmurhashV3(target_id, baseSeed)\n    return {\n        rolloutHash: generateBoundedHash(user_id + '_rollout', targetHash),\n        bucketingHash: generateBoundedHash(user_id, targetHash),\n    }\n}\n\nexport function generateBoundedHash(input: string, hashSeed: i32): f64 {\n    const hash = murmurhashV3(input, hashSeed) as f64\n    return hash / MAX_HASH_VALUE\n}\n\nexport function getCurrentRolloutPercentage(\n    rollout: PublicRollout,\n    currentDate: Date,\n): f64 {\n    const start = rollout.startPercentage\n    const startDateTime = rollout.startDate.getTime()\n    const currentDateTime = currentDate.getTime()\n\n    if (rollout.type === 'schedule') {\n        return currentDateTime >= startDateTime ? 1 : 0\n    }\n\n    const stages = rollout.stages\n    const currentStages: RolloutStage[] = []\n    const nextStages: RolloutStage[] = []\n\n    if (stages) {\n        for (let i = 0; i < stages.length; i++) {\n            const stage = stages[i]\n            const stageTime = stage.date.getTime()\n            if (stageTime <= currentDateTime) {\n                currentStages.push(stage)\n            } else {\n                nextStages.push(stage)\n            }\n        }\n    }\n\n    const _currentStage = last(currentStages)\n    const nextStage = first(nextStages)\n\n    let currentStage = _currentStage\n    if (!_currentStage && startDateTime < currentDateTime) {\n        const jsonObj = new JSON.Obj()\n        jsonObj.set('type', 'discrete')\n        jsonObj.set('percentage', start)\n        jsonObj.set('date', rollout.startDate.toISOString())\n        currentStage = new RolloutStage(jsonObj)\n    }\n\n    if (!currentStage) {\n        return 0\n    }\n\n    if (!nextStage || nextStage.type === 'discrete') {\n        return currentStage.percentage\n    }\n\n    const currentDatePercentage: f64 =\n        ((currentDateTime - currentStage.date.getTime()) as f64) /\n        ((nextStage.date.getTime() - currentStage.date.getTime()) as f64)\n\n    if (currentDatePercentage === 0) {\n        return 0\n    }\n\n    return (\n        (currentStage.percentage +\n            (nextStage.percentage - currentStage.percentage)) *\n        f64(currentDatePercentage)\n    )\n}\n\nexport function _doesUserPassRollout(\n    rollout: PublicRollout | null,\n    boundedHash: f64,\n): bool {\n    if (!rollout) return true\n\n    const rolloutPercentage = getCurrentRolloutPercentage(\n        rollout,\n        new Date(Date.now()),\n    )\n    return !!rolloutPercentage && boundedHash <= rolloutPercentage\n}\n\nclass SegmentedFeatureData {\n    public feature: PublicFeature\n    public target: PublicTarget\n    public reasonDetails: string | null\n}\n\nclass TargetResult { \n    public target: PublicTarget\n    public reasonDetails: string\n}\n\nfunction evaluateSegmentationForFeature(\n    config: ConfigBody,\n    feature: Feature,\n    user: DVCPopulatedUser,\n    clientCustomData: JSON.Obj,\n): TargetResult | null {\n    // Returns the first target for which the user passes segmentation\n    for (let i = 0; i < feature.configuration.targets.length; i++) {\n        const target = feature.configuration.targets[i]\n        const passthroughRolloutEnabled = !config.project.settings.disablePassthroughRollouts\n        let doesUserPassRollout = true\n        if (target.rollout && passthroughRolloutEnabled) {\n            const bucketingValue = _getUserValueForBucketingKey(user, target)\n            const boundedHashData = _generateBoundedHashes(bucketingValue, target._id)\n            const rolloutHash = boundedHashData.rolloutHash\n            doesUserPassRollout = _doesUserPassRollout(target.rollout, rolloutHash)\n        }\n\n        if (doesUserPassRollout) {\n            const evalResult = _evaluateOperator(\n                target._audience.filters,\n                config.audiences,\n                user,\n                clientCustomData,\n            )\n            if (evalResult.result) {\n                return {\n                    target,\n                    reasonDetails: evalResult.reasonDetails || \"\"\n                }\n            }\n        }\n    }\n    return null\n}\n\nexport function getSegmentedFeatureDataFromConfig(\n    config: ConfigBody,\n    user: DVCPopulatedUser,\n    clientCustomData: JSON.Obj,\n): SegmentedFeatureData[] {\n    const accumulator: SegmentedFeatureData[] = []\n\n    for (let y = 0; y < config.features.length; y++) {\n        const feature = config.features[y]\n\n        // Returns the first target for which the user passes segmentation\n        const segmentedFeatureTarget: Target | null =\n            evaluateSegmentationForFeature(\n                config,\n                feature,\n                user,\n                clientCustomData,\n            )\n\n        if (segmentedFeatureTarget) {\n            const featureData: SegmentedFeatureData = {\n                feature,\n                target: segmentedFeatureTarget,\n            }\n            accumulator.push(featureData)\n        }\n    }\n    return accumulator\n}\n\nclass TargetAndHashes {\n    public target: Target\n    public boundedHashData: BoundedHash\n    public reasonDetails: string\n}\n\nfunction doesUserQualifyForFeature(\n    config: ConfigBody,\n    feature: Feature,\n    user: DVCPopulatedUser,\n    clientCustomData: JSON.Obj,\n): TargetAndHashes | null {\n    const targetResult = evaluateSegmentationForFeature(\n        config,\n        feature,\n        user,\n        clientCustomData,\n    )\n    if (!targetResult) return null\n    const target = targetResult.target\n    const reasonDetails = targetResult.reasonDetails\n\n    const bucketingValue = _getUserValueForBucketingKey( user, target )\n    const boundedHashData = _generateBoundedHashes(bucketingValue, target._id)\n    const rolloutHash = boundedHashData.rolloutHash\n    const passthroughRolloutEnabled = !config.project.settings.disablePassthroughRollouts\n    if (target.rollout && !passthroughRolloutEnabled && !_doesUserPassRollout(target.rollout, rolloutHash)) {\n        return null\n    }\n    return {\n        target,\n        boundedHashData,\n        reasonDetails\n    }\n}\n\nexport function bucketUserForVariation(\n    feature: Feature,\n    targetAndHashes: TargetAndHashes,\n): Variation {\n    const variation_id = targetAndHashes.target.decideTargetVariation(\n        targetAndHashes.boundedHashData.bucketingHash,\n    )\n    const variation = feature.getVariationById(variation_id)\n    if (variation) {\n        return variation\n    } else {\n        throw new Error(`Config missing variation: ${variation_id}`)\n    }\n}\n\nfunction _getEvalReason(\n    targetAndHashes: TargetAndHashes \n): EvalReason {\n    const target = targetAndHashes.target\n    const hasRollout = target.rollout !== null\n    const hasMultipleDistributions = target.distribution.length !== 1\n    let reason = EVAL_REASONS.TARGETING_MATCH\n    let reasonDetails =  targetAndHashes.reasonDetails\n\n    if (hasMultipleDistributions || hasRollout) {\n        reason = EVAL_REASONS.SPLIT\n        const evalReasonPrefix =\n            hasMultipleDistributions && hasRollout\n                ? `${EVAL_REASON_DETAILS.RANDOM_DISTRIBUTION} | ${EVAL_REASON_DETAILS.ROLLOUT}`\n                : hasMultipleDistributions\n                ? EVAL_REASON_DETAILS.RANDOM_DISTRIBUTION\n                : EVAL_REASON_DETAILS.ROLLOUT\n        reasonDetails = `${evalReasonPrefix} | ${reasonDetails}`\n    }\n    return  new EvalReason(reason, reasonDetails, target._id)\n}\n\nexport function _generateBucketedConfig(\n    config: ConfigBody,\n    user: DVCPopulatedUser,\n    clientCustomData: JSON.Obj,\n    overrides: JSON.Obj | null,\n): BucketedUserConfig {\n    const variableMap = new Map<string, SDKVariable>()\n    const featureKeyMap = new Map<string, SDKFeature>()\n    const featureVariationMap = new Map<string, string>()\n    const variableVariationMap = new Map<string, FeatureVariation>()\n\n    for (let i = 0; i < config.features.length; i++) {\n        const feature = config.features[i]\n        const targetAndHashes = doesUserQualifyForFeature(\n            config,\n            feature,\n            user,\n            clientCustomData,\n        )\n\n        const featureOverride = overrides\n            ? getStringFromJSONOptional(overrides, feature._id)\n            : null\n\n        if (!targetAndHashes && !featureOverride) {\n            continue\n        }\n\n        const bucketedVariation = targetAndHashes\n            ? bucketUserForVariation(feature, targetAndHashes)\n            : null\n\n        const overrideVariation = featureOverride\n            ? feature.getVariationById(featureOverride)\n            : null\n\n        const variation = overrideVariation || bucketedVariation\n\n        if (!variation) {\n            continue\n        }\n\n        const evalReason = featureOverride \n            ? new EvalReason(EVAL_REASONS.OVERRIDE, EVAL_REASON_DETAILS.OVERRIDE)\n            : _getEvalReason(targetAndHashes!)\n\n        featureKeyMap.set(\n            feature.key,\n            new SDKFeature(\n                feature._id,\n                feature.type,\n                feature.key,\n                variation._id,\n                variation.name,\n                variation.key,\n                evalReason,\n            ),\n        )\n        featureVariationMap.set(feature._id, variation._id)\n\n        for (let y = 0; y < variation.variables.length; y++) {\n            const variationVar = variation.variables[y]\n\n            // Find variable\n            const variable = config.getVariableForId(variationVar._var)\n            if (!variable) {\n                throw new Error(`Config missing variable: ${variationVar._var}`)\n            }\n\n            variableVariationMap.set(\n                variable.key,\n                new FeatureVariation(feature._id, variation._id),\n            )\n\n            const newVar = new SDKVariable(\n                variable._id,\n                variable.type,\n                variable.key,\n                variationVar.value,\n                feature._id,\n                evalReason, \n            )\n            variableMap.set(variable.key, newVar)\n        }\n    }\n\n    return new BucketedUserConfig(\n        config.project,\n        config.environment,\n        featureKeyMap,\n        featureVariationMap,\n        variableVariationMap,\n        variableMap,\n    )\n}\n\nclass BucketedVariableResponse {\n    public variable: SDKVariable\n    public variation: Variation\n    public feature: Feature\n}\n\nexport function _generateBucketedVariableForUser(\n    config: ConfigBody,\n    user: DVCPopulatedUser,\n    key: string,\n    clientCustomData: JSON.Obj,\n): BucketedVariableResponse | null {\n    const variable = config.getVariableForKey(key)\n    if (!variable) {\n        return null\n    }\n    const featureForVariable = config.getFeatureForVariableId(variable._id)\n    if (!featureForVariable) return null\n\n    const targetAndHashes = doesUserQualifyForFeature(\n        config,\n        featureForVariable,\n        user,\n        clientCustomData,\n    )\n    if (!targetAndHashes) return null\n\n    const variation = bucketUserForVariation(\n        featureForVariable,\n        targetAndHashes,\n    )\n    const variationVar = variation.getVariableById(variable._id)\n    if (!variationVar) {\n        throw new Error('Internal error processing configuration')\n    }\n\n    const evalReason = _getEvalReason(targetAndHashes)\n\n    const sdkVar = new SDKVariable(\n        variable._id,\n        variable.type,\n        variable.key,\n        variationVar.value,\n        featureForVariable._id,\n        evalReason,\n    )\n    return { variable: sdkVar, variation, feature: featureForVariable }\n}\n\nexport function _getUserValueForBucketingKey(\n    user: DVCPopulatedUser,\n    target: PublicTarget\n): string {\n    if (target.bucketingKey && target.bucketingKey !== 'user_id') {\n        let bucketingValue: string = DEFAULT_BUCKETING_VALUE\n        const customData = user.getCombinedCustomData()\n        if (customData) {\n            const customDataValue = getValueFromJSONOptional(customData, target.bucketingKey)\n            bucketingValue = customDataValue\n                ? customDataValue.toString()\n                : DEFAULT_BUCKETING_VALUE\n        }\n        if (\n            typeof bucketingValue !== 'string' &&\n            typeof bucketingValue !== 'number' &&\n            typeof bucketingValue !== 'boolean'\n        ) {\n            return DEFAULT_BUCKETING_VALUE\n        } else {\n            return bucketingValue.toString()\n        }\n    }\n    return user.user_id\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    let entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) != null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    let hashCode = HASH<K>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let keys = new Array<K>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(keys[length++] = entry.key);\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<V>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.value);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","import { ConfigBodyV2 as ConfigBody, ConfigMetadata, ProjectMetadata, EnvironmentMetadata } from '../types'\n\nconst _configData: Map<string, ConfigBody> = new Map()\nconst _configMetadata: Map<string, string> = new Map()\n\nexport function _setConfigData(sdkKey: string, configData: ConfigBody): void {\n    _configData.set(sdkKey, configData)\n    _configMetadata.set(sdkKey, new ConfigMetadata(configData.project, configData.environment).stringify())\n}\n\nexport function _getConfigData(sdkKey: string): ConfigBody {\n    if (!_configData.has(sdkKey)) {\n        throw new Error('Config data is not set.')\n    } else {\n        return _configData.get(sdkKey)\n    }\n}\n\nexport function _hasConfigData(sdkKey: string): bool {\n    return _configData.has(sdkKey)\n}\n\nexport function _getConfigMetadata(sdkKey: string): string {\n    if (_configMetadata.has(sdkKey)) {\n        return _configMetadata.get(sdkKey)\n    } else {\n        if(_configData.has(sdkKey)){\n            const config = _getConfigData(sdkKey)\n            const metadata = new ConfigMetadata(config.project, config.environment).stringify()\n            _configMetadata.set(sdkKey, metadata)\n            return metadata\n        }\n        return '{}'\n    }\n}","import { JSON } from '@devcycle/assemblyscript-json/assembly'\n\nconst _clientCustomData: Map<string, JSON.Obj> = new Map()\n\nexport function _setClientCustomData(sdkKey: string, clientCustomData: JSON.Obj): void {\n    _clientCustomData.set(sdkKey, clientCustomData)\n}\n\nexport function _getClientCustomData(sdkKey: string): JSON.Obj {\n    if (_clientCustomData.has(sdkKey)) {\n        return _clientCustomData.get(sdkKey)\n    }\n    const clientCustomData = new JSON.Obj()\n    _setClientCustomData(sdkKey, clientCustomData)\n    return clientCustomData\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    DVCEvent,\n    DVCPopulatedUser,\n    EventQueueOptions,\n    DVCRequestEvent,\n    UserEventsBatchRecord,\n    FeatureVariation\n} from '../types'\n\nexport type EvalReasonAggMap = Map<string, i64>\nexport type VariationAggMap = Map<string, EvalReasonAggMap>\nexport type FeatureAggMap = Map<string, VariationAggMap>\nexport type VariableAggMap = Map<string, FeatureAggMap>\nexport type AggEventQueue = Map<string, VariableAggMap>\nexport type UserEventQueue = Map<string, UserEventsBatchRecord>\n\nexport class FlushEventQueues {\n    public userEventQueue: UserEventQueue\n    public aggEventQueue: AggEventQueue\n}\n\nconst EventTypesSet = new Set<string>()\nEventTypesSet.add('variableEvaluated')\nEventTypesSet.add('aggVariableEvaluated')\nEventTypesSet.add('variableDefaulted')\nEventTypesSet.add('aggVariableDefaulted')\n\nexport class EventQueue {\n    private sdkKey: string\n    options: EventQueueOptions\n\n    /**\n     * Map<user_id, UserEventsBatchRecord>\n     */\n    private userEventQueue: UserEventQueue\n\n    /**\n     * Map<'aggVariableDefaulted',\n     *      Map<variable.key,\n     *          Map<'value',\n     *              Map<'value', Map<\n     *                  defaultReason, counter>\n     *              >\n     *          >\n     *      >\n     * >\n     *\n     * Map<'aggVariableEvaluated',\n     *      Map<variable.key,\n     *          Map<feature._id,\n     *              Map<variation_id,\n     *                  Map<\n     *                      evalReason, counter>\n     *                  >\n     *              >\n     *          >\n     *      >\n     * >\n     */\n    private aggEventQueue: AggEventQueue\n\n    public eventQueueCount: i32\n\n    constructor(sdkKey: string, options: EventQueueOptions) {\n        this.sdkKey = sdkKey\n        this.options = options\n        this.userEventQueue = new Map<string, UserEventsBatchRecord>()\n        this.aggEventQueue = new Map<string, VariableAggMap>()\n        this.eventQueueCount = 0\n    }\n\n    flushAndResetEventQueue(): FlushEventQueues {\n        const userEventQueue = this.userEventQueue\n        const aggEventQueue = this.aggEventQueue\n        this.userEventQueue = new Map<string, UserEventsBatchRecord>()\n        this.aggEventQueue = new Map<string, VariableAggMap>()\n        this.eventQueueCount = 0\n        return { userEventQueue, aggEventQueue }\n    }\n\n    checkIfEventLoggingDisabled(event: DVCEvent): bool {\n        if (!EventTypesSet.has(event.type)) {\n            return this.options.disableCustomEventLogging\n        } else {\n            return this.options.disableAutomaticEventLogging\n        }\n    }\n\n    queueEvent(user: DVCPopulatedUser, event: DVCEvent, featureVariationMap: Map<string, string>): void {\n        if (this.checkIfEventLoggingDisabled(event)) {\n            return\n        }\n\n        const requestEvent = new DVCRequestEvent(event, user.user_id, featureVariationMap)\n        const user_id = user.user_id\n        let userEvents: UserEventsBatchRecord\n        if (!this.userEventQueue.has(user_id)) {\n            userEvents = new UserEventsBatchRecord(user, [])\n            this.userEventQueue.set(user_id, userEvents)\n        } else {\n            userEvents = this.userEventQueue.get(user_id)\n            userEvents.user = user\n        }\n\n        userEvents.events.push(requestEvent)\n        this.eventQueueCount++\n    }\n\n    queueAggregateEvent(\n        event: DVCEvent,\n        variableVariationMap: Map<string, FeatureVariation>,\n        aggByVariation: boolean\n    ): void {\n        if (this.checkIfEventLoggingDisabled(event)) {\n            return\n        }\n\n        const type = event.type\n        const target = event.target\n        if (!target) {\n            throw new Error('Event missing target to save aggregate event')\n        }\n\n        let variableFeatureVarAggMap: VariableAggMap\n        if (this.aggEventQueue.has(type)) {\n            variableFeatureVarAggMap = this.aggEventQueue.get(type)\n        } else {\n            variableFeatureVarAggMap = new Map<string, FeatureAggMap>()\n            this.aggEventQueue.set(type, variableFeatureVarAggMap)\n        }\n\n        let featureVarAggMap: FeatureAggMap\n        if (variableFeatureVarAggMap.has(target)) {\n            featureVarAggMap = variableFeatureVarAggMap.get(target)\n        } else {\n            featureVarAggMap = new Map<string, VariationAggMap>()\n            variableFeatureVarAggMap.set(target, featureVarAggMap)\n        }\n\n        if (aggByVariation) {\n            if (!variableVariationMap.has(target)) {\n                throw new Error(`Missing variableVariationMap mapping for target: ${target} to aggregate by variation`)\n            }\n            const featureVariation: FeatureVariation = variableVariationMap.get(target)\n\n            let evalReasonAggMap: EvalReasonAggMap = new Map<string, i64>()\n            let variationAggMap: VariationAggMap\n\n            if (featureVarAggMap.has(featureVariation._feature)) {\n                variationAggMap = featureVarAggMap.get(featureVariation._feature)\n            } else {\n                variationAggMap = new Map<string, EvalReasonAggMap>()\n                featureVarAggMap.set(featureVariation._feature, variationAggMap)\n            }\n\n            if (variationAggMap.has(featureVariation._variation)) {\n                evalReasonAggMap = variationAggMap.get(featureVariation._variation)\n            } else {\n                variationAggMap.set(featureVariation._variation, evalReasonAggMap)\n                this.eventQueueCount++\n            }\n\n            this.addEvalReasonToVariationAggMap(evalReasonAggMap, event.metaData)\n        } else {\n            /**\n             * Because `aggEventQueue` is now aggregated by both feature and variation,\n             * we need to set an empty map here to fit the same schema for tracking `aggVariableDefaulted` events.\n             */\n            if (featureVarAggMap.has('value')) {\n                const variationAggMap: VariationAggMap = featureVarAggMap.get('value')\n                if (variationAggMap.has('value')) {\n                    const evalReasonAggMap: EvalReasonAggMap = variationAggMap.get('value')\n                    this.addEvalReasonToVariationAggMap(evalReasonAggMap, event.metaData)\n                } else {\n                    throw new Error('Missing second value map for aggVariableDefaulted')\n                }\n            } else {\n                const evalReasonAggMap: EvalReasonAggMap = new Map<string, i64>()\n                this.addEvalReasonToVariationAggMap(evalReasonAggMap, event.metaData)\n\n                const variationAggMap = new Map<string, EvalReasonAggMap>()\n                variationAggMap.set('value', evalReasonAggMap)\n                featureVarAggMap.set('value', variationAggMap)\n                this.eventQueueCount++\n            }\n\n        }\n    }\n\n    private addEvalReasonToVariationAggMap(evalReasonAggMap: EvalReasonAggMap, eventMetadata: JSON.Obj | null): void {\n        if (eventMetadata && eventMetadata.has('evalReason')) {\n            const evalReason = eventMetadata.getString('evalReason')\n            if (evalReason) {\n                const evalReasonString = evalReason.valueOf()\n                if (evalReasonAggMap.has(evalReasonString)) {\n                    const evalReasonCount: i64 = evalReasonAggMap.get(evalReasonString)\n                    evalReasonAggMap.set(evalReason.valueOf(), evalReasonCount + 1)\n                } else {\n                    evalReasonAggMap.set(evalReason.valueOf(), 1)\n                }\n            }\n        }\n    }\n}\n","import { EventQueue } from '../eventQueue/eventQueue'\nimport {\n    EventQueueOptions,\n    DVCPopulatedUser,\n    DVCEvent,\n    FeatureVariation,\n    SDKVariable,\n} from '../types'\nimport { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport { _getConfigData } from './configDataManager'\nimport { _generateBucketedConfig } from '../bucketing'\nimport { RequestPayloadManager } from '../eventQueue/requestPayloadManager'\nimport { jsonArrFromValueArray } from '../helpers/jsonHelpers'\nimport { _getClientCustomData } from './clientCustomDataManager'\n\n/**\n * Map<sdkKey, EventQueue>\n */\nconst _eventQueueMap = new Map<string, EventQueue>()\n\nfunction getEventQueue(sdkKey: string): EventQueue {\n    if (!_eventQueueMap.has(sdkKey)) {\n        throw new Error(`No Event Queue found for sdkKey: ${sdkKey}`)\n    }\n    return _eventQueueMap.get(sdkKey)\n}\n\nconst _requestPayloadMap = new Map<string, RequestPayloadManager>()\n\nfunction getRequestPayloadManager(sdkKey: string): RequestPayloadManager {\n    if (!_requestPayloadMap.has(sdkKey)) {\n        throw new Error(\n            `No Request Payload Manager found for sdkKey: ${sdkKey}`,\n        )\n    }\n    return _requestPayloadMap.get(sdkKey)\n}\n\n/**\n * This should be called from the Native code where the existing EventQueue Class is setup.\n * This creates the WASM EventQueue class and stores it in a map by env sdkKey,\n * this is needed because our SDKs support creating multiple DevCycleClient objects by sdkKey.\n */\nexport function initEventQueue(sdkKey: string, clientUUID: string, optionsStr: string): void {\n    if (!sdkKey) {\n        throw new Error('Missing sdkKey to initialize Event Queue')\n    }\n    if (_eventQueueMap.has(sdkKey) || _requestPayloadMap.has(sdkKey)) {\n        throw new Error(\n            `Event Queue already exists for sdkKey: ${sdkKey}, ` +\n                'you can only initialize the DevCycle SDK once per sdkKey',\n        )\n    }\n\n    const options = new EventQueueOptions(optionsStr)\n\n    const queue = new EventQueue(sdkKey, options)\n    _eventQueueMap.set(sdkKey, queue)\n\n    const requestPayloadManager = new RequestPayloadManager(\n        options,\n        clientUUID\n    )\n    _requestPayloadMap.set(sdkKey, requestPayloadManager)\n}\n\n/**\n * This should be called by the native code on an interval set by the `eventFlushIntervalMS` option.\n * It will generate an array of payloads, with each payload up to a maximum batch size\n * (should be configurable by an option, nodejs uses 100).\n *\n * It should take the data from the eventQueue and aggregate events and generate request payloads.\n * After generating these payloads it should clear the data from the eventQueue and aggregate events queues.\n * The payload objects should be stored in a sending paylods queue with their status of 'inProgress'.\n * Each Payload object should generate a unique payloadId that will be used for the onPayloadSuccess() and\n * onPayloadFailure() methods.\n *\n * If onPayloadSuccess() is called for a payloadId, it can be removed from the sending payloads queue.\n *\n * If onPayloadFailure() is called for a payloadId and retryable = true, it should be marked as 'failed'.\n * If it retryable = false, it should be removed from the sending payload queue.\n * Then on subsequent calls to `flush()` the 'failed' payloads should be marked as 'inProgress' and returned\n * as payloads to be sent by the Native code again.\n *\n * If there are payloads that are still marked as `inProgress` when `flush()` is called, it should return an\n * exception to the native code.\n */\nexport function flushEventQueue(sdkKey: string): string {\n    const eventQueue = getEventQueue(sdkKey)\n    const requestPayloadManager = getRequestPayloadManager(sdkKey)\n\n    const eventQueues = eventQueue.flushAndResetEventQueue()\n    const payloads = requestPayloadManager.constructFlushPayloads(\n        eventQueues.userEventQueue,\n        eventQueues.aggEventQueue,\n    )\n    return jsonArrFromValueArray(payloads).stringify()\n}\n\nexport function onPayloadSuccess(sdkKey: string, payloadId: string): void {\n    const requestPayloadManager = getRequestPayloadManager(sdkKey)\n    requestPayloadManager.markPayloadSuccess(payloadId)\n}\n\nexport function onPayloadFailure(\n    sdkKey: string,\n    payloadId: string,\n    retryable: boolean,\n): void {\n    const requestPayloadManager = getRequestPayloadManager(sdkKey)\n    requestPayloadManager.markPayloadFailure(payloadId, retryable)\n}\n\nexport function queueEvent(\n    sdkKey: string,\n    userStr: string,\n    eventStr: string,\n): void {\n    const eventQueue = getEventQueue(sdkKey)\n    const dvcUser = DVCPopulatedUser.fromJSONString(userStr)\n    const event = DVCEvent.fromJSONString(eventStr)\n    dvcUser.mergeClientCustomData(_getClientCustomData(sdkKey))\n    const bucketedConfig = _generateBucketedConfig(\n        _getConfigData(sdkKey),\n        dvcUser,\n        _getClientCustomData(sdkKey),\n        null,\n    )\n    eventQueue.queueEvent(dvcUser, event, bucketedConfig.featureVariationMap)\n}\n\nexport function queueAggregateEvent(\n    sdkKey: string,\n    eventStr: string,\n    variableVariationMapStr: string,\n): void {\n    const eventQueue = getEventQueue(sdkKey)\n    if (eventQueue.options.disableAutomaticEventLogging) return\n\n    const event = DVCEvent.fromJSONString(eventStr)\n\n    const variableVariationMapJSON = JSON.parse(variableVariationMapStr)\n    if (!variableVariationMapJSON.isObj)\n        throw new Error('variableVariationMap is not a JSON Object')\n    const variableVariationMap =\n        FeatureVariation.getVariableVariationMapFromJSONObj(\n            variableVariationMapJSON as JSON.Obj,\n        )\n\n    const aggByVariation = event.type === 'aggVariableEvaluated'\n    eventQueue.queueAggregateEvent(event, variableVariationMap, aggByVariation)\n}\n\n/**\n * Use for testing to pass in JSON strings to be parsed and call queueVariableEvaluatedEvent() with.\n */\nexport function queueVariableEvaluatedEvent_JSON(\n    sdkKey: string,\n    varVariationMapString: string,\n    variable: string | null,\n    variableKey: string,\n): void {\n    const varVariationMapJSON = JSON.parse(varVariationMapString)\n    if (!varVariationMapJSON.isObj)\n        throw new Error('varVariationMap is not a JSON Object')\n    const varVariationObj = varVariationMapJSON as JSON.Obj\n\n    const varVariationMap = new Map<string, FeatureVariation>()\n    for (let i = 0; i < varVariationObj.keys.length; i++) {\n        const key = varVariationObj.keys[i]\n        const value = varVariationObj.get(key)\n        if (!value || !value.isObj)\n            throw new Error('FeatureVariation value is not a JSON Object')\n        varVariationMap.set(\n            key,\n            FeatureVariation.fromJSONObj(value as JSON.Obj),\n        )\n    }\n\n    return queueVariableEvaluatedEvent(\n        sdkKey,\n        varVariationMap,\n        variable !== null ? SDKVariable.fromJSONString(variable) : null,\n        variableKey,\n    )\n}\n\nexport function queueVariableEvaluatedEvent(\n    sdkKey: string,\n    variableVariationMap: Map<string, FeatureVariation>,\n    variable: SDKVariable | null,\n    variableKey: string,\n): void {\n    const eventQueue = getEventQueue(sdkKey)\n    if (eventQueue.options.disableAutomaticEventLogging) return\n\n    const eventType =\n        variable !== null ? 'aggVariableEvaluated' : 'aggVariableDefaulted'\n\n    const metaData = new JSON.Obj()\n    if (variable) {\n        metaData.set('evalReason', variable.evalReason.reason)\n    } else {\n        metaData.set('evalReason', 'DEFAULT')\n    }\n\n    const event = new DVCEvent(eventType, variableKey, null, NaN, metaData)\n\n    const aggByVariation = eventType === 'aggVariableEvaluated'\n    eventQueue.queueAggregateEvent(event, variableVariationMap, aggByVariation)\n}\n\nexport function cleanupEventQueue(sdkKey: string): void {\n    if (_eventQueueMap.has(sdkKey)) {\n        _eventQueueMap.delete(sdkKey)\n    }\n    if (_requestPayloadMap.has(sdkKey)) {\n        _requestPayloadMap.delete(sdkKey)\n    }\n}\n\nexport function eventQueueSize(sdkKey: string): i32 {\n    const eventQueue = getEventQueue(sdkKey)\n    const requestPayloadManager = getRequestPayloadManager(sdkKey)\n    return (\n        eventQueue.eventQueueCount + requestPayloadManager.payloadEventCount()\n    )\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    ConfigBodyV2 as ConfigBody,\n    DVCPopulatedUser,\n    FeatureVariation,\n    PlatformData,\n    DVCUser,\n    SDKVariable,\n    VariableForUserParams_PB,\n    decodeVariableForUserParams_PB,\n    VariableType_PB,\n} from './types'\nimport {\n    _generateBoundedHashes,\n    _generateBucketedConfig,\n    _generateBucketedVariableForUser,\n} from './bucketing'\nimport {\n    _clearPlatformData,\n    _setPlatformData,\n} from './managers/platformDataManager'\nimport {\n    _getConfigData,\n    _hasConfigData,\n    _setConfigData,\n    _getConfigMetadata,\n} from './managers/configDataManager'\nimport {\n    _getClientCustomData,\n    _setClientCustomData,\n} from './managers/clientCustomDataManager'\nimport { queueVariableEvaluatedEvent } from './managers/eventQueueManager'\n\nexport function generateBoundedHashesFromJSON(\n    user_id: string,\n    target_id: string,\n): string {\n    const boundedHash = _generateBoundedHashes(user_id, target_id)\n    const json = new JSON.Obj()\n    json.set('rolloutHash', boundedHash.rolloutHash)\n    json.set('bucketingHash', boundedHash.bucketingHash)\n    return json.stringify()\n}\n\n/**\n * Generate a full bucketed config for a user JSON string.\n * This is not performant, and most SDKs should use variableForUser instead for `dvcClient.variable()` calls.\n * @param sdkKey\n * @param userJSONStr\n */\nexport function generateBucketedConfigForUser(\n    sdkKey: string,\n    userJSONStr: string,\n): string {\n    const config = _getConfigData(sdkKey)\n    const user = DVCPopulatedUser.fromJSONString(userJSONStr)\n\n    const bucketedConfig = _generateBucketedConfig(\n        config,\n        user,\n        _getClientCustomData(sdkKey),\n        null,\n    )\n    return bucketedConfig.stringify()\n}\n\nexport function generateBucketedConfigForUserUTF8(\n    sdkKey: string,\n    userJSONStr: Uint8Array,\n): Uint8Array {\n    const config = _getConfigData(sdkKey)\n    const user = DVCPopulatedUser.fromUTF8(userJSONStr)\n    const bucketedConfig = _generateBucketedConfig(\n        config,\n        user,\n        _getClientCustomData(sdkKey),\n        null,\n    )\n    return Uint8Array.wrap(String.UTF8.encode(bucketedConfig.stringify()))\n}\n\nexport function generateBucketedConfigForUserWithOverrides(\n    sdkKey: string,\n    userJSONStr: Uint8Array,\n    overridesJSONStr: Uint8Array,\n): Uint8Array {\n    const config = _getConfigData(sdkKey)\n    const user = DVCPopulatedUser.fromUTF8(userJSONStr)\n\n    const overridesJSON = JSON.parse(overridesJSONStr)\n    const overrides = overridesJSON.isObj ? (overridesJSON as JSON.Obj) : null\n\n    const bucketedConfig = _generateBucketedConfig(\n        config,\n        user,\n        _getClientCustomData(sdkKey),\n        overrides,\n    )\n    return Uint8Array.wrap(String.UTF8.encode(bucketedConfig.stringify()))\n}\n\nexport enum VariableType {\n    Boolean,\n    Number,\n    String,\n    JSON,\n}\nexport const VariableTypeStrings = ['Boolean', 'Number', 'String', 'JSON']\n\n/**\n * Convert PB VariableType to SDK VariableType\n * @param pbVariableType\n */\nfunction variableTypeFromPB(pbVariableType: VariableType_PB): VariableType {\n    switch (pbVariableType) {\n        case VariableType_PB.Boolean:\n            return VariableType.Boolean\n        case VariableType_PB.Number:\n            return VariableType.Number\n        case VariableType_PB.String:\n            return VariableType.String\n        case VariableType_PB.JSON:\n            return VariableType.JSON\n        default:\n            throw new Error(`Unknown variable type: ${pbVariableType}`)\n    }\n}\n\n/**\n * Preallocated memory version of variableForUser_PB. Returns a protobuf encoded SDKVariable object.\n * @param protobuf\n * @param length\n */\nexport function variableForUser_PB_Preallocated(\n    protobuf: Uint8Array,\n    length: i32,\n): Uint8Array | null {\n    return variableForUser_PB(protobuf.slice(0, length))\n}\n\n/**\n * Protobuf version of variableForUser. Returns a protobuf encoded SDKVariable object.\n * @param protobuf Protobuf encoded VariableForUserParams_PB object\n */\nexport function variableForUser_PB(protobuf: Uint8Array): Uint8Array | null {\n    const params: VariableForUserParams_PB =\n        decodeVariableForUserParams_PB(protobuf)\n    const user = params.user\n    if (!user) throw new Error('Missing user from variableForUser_PB protobuf')\n    const dvcUser = new DVCPopulatedUser(DVCUser.fromPBUser(user))\n\n    const variable = _variableForDVCUser(\n        params.sdkKey,\n        dvcUser,\n        params.variableKey,\n        variableTypeFromPB(params.variableType),\n        params.shouldTrackEvent,\n    )\n    return variable ? variable.toProtobuf() : null\n}\n\n/**\n * Internal method that returns the variable value for the given DVCPopulatedUser and variable key and variable type.\n * Returns a SDKVariable object.\n * @param sdkKey\n * @param dvcUser\n * @param variableKey\n * @param variableType\n * @param shouldTrackEvent\n */\nfunction _variableForDVCUser(\n    sdkKey: string,\n    dvcUser: DVCPopulatedUser,\n    variableKey: string,\n    variableType: VariableType,\n    shouldTrackEvent: boolean,\n): SDKVariable | null {\n    const config = _getConfigData(sdkKey)\n    const response = _generateBucketedVariableForUser(\n        config,\n        dvcUser,\n        variableKey,\n        _getClientCustomData(sdkKey),\n    )\n\n    let variable: SDKVariable | null =\n        response && response.variable ? response.variable : null\n    if (variable && variable.type !== VariableTypeStrings[variableType]) {\n        variable = null\n    }\n\n    if (shouldTrackEvent) {\n        const variableVariationMap = new Map<string, FeatureVariation>()\n        if (response) {\n            variableVariationMap.set(\n                variableKey,\n                new FeatureVariation(\n                    response.feature._id,\n                    response.variation._id,\n                ),\n            )\n        }\n\n        queueVariableEvaluatedEvent(\n            sdkKey,\n            variableVariationMap,\n            variable,\n            variableKey,\n        )\n    }\n    return variable\n}\n\n/**\n * Returns the variable value for the given user and variable key and variable type.\n * @param sdkKey\n * @param userJSONStr\n * @param variableKey\n * @param variableType\n * @param shouldTrackEvent should we track an event for this variable evaluation\n */\nexport function variableForUser(\n    sdkKey: string,\n    userJSONStr: string,\n    variableKey: string,\n    variableType: VariableType,\n    shouldTrackEvent: boolean,\n): string | null {\n    const user = DVCPopulatedUser.fromJSONString(userJSONStr)\n    const variable = _variableForDVCUser(\n        sdkKey,\n        user,\n        variableKey,\n        variableType,\n        shouldTrackEvent,\n    )\n    return variable ? variable.stringify() : null\n}\n\n/**\n * A version of the variableForUser function that takes a preallocated string for the user and variable keys.\n * The allocated string may be larger than the real set of bytes we are about reading, so it takes a size to read until\n * @param sdkKey\n * @param userStr\n * @param userStrLength\n * @param variableKey\n * @param variableKeyLength\n * @param variableType\n */\nexport function variableForUserPreallocated(\n    sdkKey: string,\n    userStr: string,\n    // pass in length of actual underlying string\n    // (the userStr starts with that and may contain extra preallocated bytes)\n    userStrLength: i32,\n    variableKey: string,\n    // ditto\n    variableKeyLength: i32,\n    variableType: VariableType,\n    shouldTrackEvent: boolean,\n): string | null {\n    return variableForUser(\n        sdkKey,\n        userStr.substr(0, userStrLength),\n        variableKey.substr(0, variableKeyLength),\n        variableType,\n        shouldTrackEvent,\n    )\n}\n\n/**\n * Set the platform data for the given SDK key.\n * @param platformDataJSONStr\n */\nexport function setPlatformData(platformDataJSONStr: string): void {\n    const platformData = PlatformData.fromString(platformDataJSONStr)\n    _setPlatformData(platformData)\n}\n\n/**\n * Same interfaces as `setPlatformData()` but with a UTF8 buffer instead of a string.\n * This is to avoid issues encoding / decoding between UTF8 and UTF16.\n * @param platformDataJSONStr\n */\nexport function setPlatformDataUTF8(platformDataJSONStr: Uint8Array): void {\n    const platformData = PlatformData.fromUTF8(platformDataJSONStr)\n    _setPlatformData(platformData)\n}\n\n/**\n * Clear the platform data for the given SDK key.\n * @param empty Add empty input string to make AS compiler work\n */\nexport function clearPlatformData(empty: string | null = null): void {\n    _clearPlatformData()\n}\n\n/**\n * Same interfaces as `setConfigDataUTF8()` but with a preallocated buffer.\n * @param sdkKey\n * @param configDataJSONStr\n * @param length\n */\nexport function setConfigDataUTF8Preallocated(\n    sdkKey: string,\n    configDataJSONStr: Uint8Array,\n    length: i32,\n): void {\n    setConfigDataUTF8(sdkKey, configDataJSONStr.slice(0, length))\n}\n\n/**\n * Same interfaces as `setConfigData()` but with a UTF8 buffer instead of a string.\n * This is to avoid issues encoding / decoding between UTF8 and UTF16.\n * @param sdkKey\n * @param configDataJSONStr\n */\nexport function setConfigDataUTF8(\n    sdkKey: string,\n    configDataJSONStr: Uint8Array,\n): void {\n    const configData = ConfigBody.fromUTF8(configDataJSONStr)\n    _setConfigData(sdkKey, configData)\n}\n\n/**\n * Set the config data for the given SDK key and JSON String config data.\n * @param sdkKey\n * @param configDataJSONStr\n */\nexport function setConfigData(sdkKey: string, configDataJSONStr: string): void {\n    const configData = ConfigBody.fromString(configDataJSONStr)\n    _setConfigData(sdkKey, configData)\n}\n\n/**\n * Set the config data for the given SDK key and JSON String config data and etag.\n * To be used in CF workers along with `hasConfigDataForEtag()` to avoid unnecessary re-setting of config data.\n * @param sdkKey\n * @param configDataJSONStr\n * @param etag\n */\nexport function setConfigDataWithEtag(\n    sdkKey: string,\n    configDataJSONStr: string,\n    etag: string,\n): void {\n    const configData = ConfigBody.fromString(configDataJSONStr, etag)\n    _setConfigData(sdkKey, configData)\n}\n\n/**\n * Returns true if the config data for the given SDK key and the given etag.\n * @param sdkKey\n * @param etag\n */\nexport function hasConfigDataForEtag(sdkKey: string, etag: string): bool {\n    if (!_hasConfigData(sdkKey)) return false\n    const configData = _getConfigData(sdkKey)\n    return configData && configData.etag !== null && configData.etag === etag\n}\n\n/**\n * Set the client custom data for the given SDK key and JSON String custom data.\n * @param sdkKey\n * @param clientCustomDataJSONStr\n */\nexport function setClientCustomData(\n    sdkKey: string,\n    clientCustomDataJSONStr: string,\n): void {\n    const parsed = JSON.parse(clientCustomDataJSONStr)\n    if (!parsed.isObj) {\n        throw new Error('invalid global clientCustomDataJSONStr')\n    }\n\n    _setClientCustomData(sdkKey, parsed as JSON.Obj)\n}\n\n/**\n * Set the client custom data for the given SDK key and JSON String custom data.\n * Same interfaces as `setClientCustomData()` but with a UTF8 buffer instead of a string.\n * This is to avoid issues encoding / decoding between UTF8 and UTF16.\n * @param sdkKey\n * @param clientCustomDataUTF8\n */\nexport function setClientCustomDataUTF8(\n    sdkKey: string,\n    clientCustomDataUTF8: Uint8Array,\n): void {\n    const parsed = JSON.parse(clientCustomDataUTF8)\n    if (!parsed.isObj) {\n        throw new Error('invalid global clientCustomDataJSONStr')\n    }\n\n    _setClientCustomData(sdkKey, parsed as JSON.Obj)\n}\n\n/**\n * return the SDK key that is stored in the config. Normally this would be the same as the passed-in SDK key, but for\n * bootstrapping configs it's actually the client SDK key, while the config is stored under the server SDK key\n * @param sdkKey\n */\nexport function getSDKKeyFromConfig(sdkKey: string): string | null {\n    const config = _getConfigData(sdkKey)\n    return config.clientSDKKey\n}\n\n/**\n * Returns the config metadata for the given SDK key.\n * @param sdkKey\n */\nexport function getConfigMetadata(sdkKey: string): string {\n    return _getConfigMetadata(sdkKey)\n}\n\nexport * from './managers/eventQueueManager'\n\nexport * from './testHelpers'\n\nexport {\n    murmurhashV3,\n    murmurhashV3_js,\n    murmurhashBufferSize,\n} from './helpers/murmurhash'\n","\nfunction padWithLeadingZeros(str: string): string {\n    const length = 5 - str.length\n    const array = length > 0 ? new Array<string>(length) : []\n    return array.join('0') + str\n}\n\nexport function unicodeCharEscape(charCode: i32): string {\n    // Ignore TS error, it builds / compiles / tests fine.\n    return '\\\\u' + padWithLeadingZeros(charCode.toString(16))\n}\n","import { Buffer } from \"./util\";\nimport { JSONDecoder, JSONHandler } from './decoder';\n\nclass Handler extends JSONHandler {\n  stack: Value[] = new Array<Value>();\n\n  reset(): void {\n    while (this.stack.length > 0) {\n      this.stack.pop();\n    }\n  }\n\n  get peek(): Value {\n    return this.stack[this.stack.length - 1];\n  }\n\n  setString(name: string, value: string): void {\n    const obj: Value = Value.String(value);\n    this.addValue(name, obj);\n  }\n\n  setBoolean(name: string, value: bool): void {\n    const obj = Value.Bool(value);\n    this.addValue(name, obj);\n  }\n\n  setNull(name: string): void {\n    const obj = Value.Null();\n    this.addValue(name, obj);\n  }\n\n  setInteger(name: string, value: i64): void {\n    const obj = Value.Integer(value);\n    this.addValue(name, obj);\n  }\n\n  setFloat(name: string, value: f64): void {\n    const obj = Value.Float(value);\n    this.addValue(name, obj);\n  }\n\n  pushArray(name: string): bool {\n    const obj: Value = Value.Array();\n    if (this.stack.length == 0) {\n      this.stack.push(obj);\n    } else {\n      this.addValue(name, obj);\n      this.stack.push(obj);\n    }\n    return true;\n  }\n\n  popArray(): void {\n    if (this.stack.length > 1) {\n      this.stack.pop();\n    }\n  }\n\n  pushObject(name: string): bool {\n    const obj: Value = Value.Object();\n    this.addValue(name, obj);\n    this.stack.push(obj);\n    return true;\n  }\n\n  popObject(): void {\n    if (this.stack.length > 1) {\n      this.stack.pop();\n    }\n  }\n\n  addValue(name: string, obj: Value): void {\n    if (name.length == 0 && this.stack.length == 0) {\n      this.stack.push(obj);\n      return;\n    }\n    if (this.peek instanceof Obj) {\n      (this.peek as Obj).set(name, obj);\n    } else if (this.peek instanceof Arr) {\n      (<Arr>this.peek).push(obj);\n    }\n  }\n}\n\nnamespace _JSON {\n  // @ts-ignore decorator is valid\n  @lazy\n  export const handler: Handler = new Handler();\n  // @ts-ignore decorator is valid\n  @lazy\n  export const decoder: JSONDecoder<Handler> = new JSONDecoder<Handler>(\n    _JSON.handler\n  );\n\n  /** Parses a string or Uint8Array and returns a Json Value. */\n  export function parse<T = Uint8Array>(str: T): Value {\n    var arr: Uint8Array;\n    if (isString<T>(str)) {\n      arr = Buffer.fromString(<string>str);\n    } else {\n      arr = changetype<Uint8Array>(str);\n    }\n    _JSON.decoder.deserialize(arr);\n    const res = _JSON.decoder.handler.peek;\n    _JSON.decoder.handler.reset();\n    return res;\n  }\n}\n\n// @ts-ignore\n@lazy const NULL: Null = new Null();\n\nexport abstract class Value {\n  static String(str: string): Str {\n    return new Str(str);\n  }\n  static Number(num: f64): Num {\n    return new Num(num);\n  }\n  static Float(num: f64): Float {\n    return new Float(num);\n  }\n  static Integer(num: i64): Integer {\n    return new Integer(num);\n  }\n  static Bool(b: bool): Bool {\n    return new Bool(b);\n  }\n  static Null(): Null {\n    return NULL;\n  }\n  static Array(): Arr {\n    return new Arr();\n  }\n  static Object(): Obj {\n    return new Obj();\n  }\n\n  get isString(): boolean {\n    return this instanceof Str;\n  }\n\n  get isNum(): boolean {\n    return this instanceof Num;\n  }\n\n  get isFloat(): boolean {\n    return this instanceof Float;\n  }\n\n  get isInteger(): boolean {\n    return this instanceof Integer;\n  }\n\n  get isBool(): boolean {\n    return this instanceof Bool;\n  }\n\n  get isNull(): boolean {\n    return this instanceof Null;\n  }\n\n  get isArr(): boolean {\n    return this instanceof Arr;\n  }\n\n  get isObj(): boolean {\n    return this instanceof Obj;\n  }\n\n  /**\n   * @returns A valid JSON string of the value\n   */\n  abstract stringify(): string;\n\n  /**\n   *\n   * @returns A AS string corresponding to the value.\n   */\n  toString(): string {\n    return this.stringify();\n  }\n}\n\nfunction escapeChar(char: string): string {\n  const charCode = char.charCodeAt(0);\n  switch (charCode) {\n    case 0x22: return '\\\\\"';\n    case 0x5C: return \"\\\\\\\\\";\n    case 0x08: return \"\\\\b\";\n    case 0x0A: return \"\\\\n\";\n    case 0x0D: return \"\\\\r\";\n    case 0x09: return \"\\\\t\";\n    case 0x0C: return \"\\\\f\";\n    case 0x0B: return \"\\\\u000b\";\n    default: return char;\n  }\n}\n\nexport class Str extends Value {\n\n  constructor(public _str: string) {\n    super();\n  }\n\n  stringify(): string {\n    let escaped: string[] = new Array(this._str.length);\n    for (let i = 0; i < this._str.length; i++) {\n      const char = this._str.at(i);\n      escaped[i] = escapeChar(char);\n    }\n    return '\"' + escaped.join('') + '\"';\n  }\n\n  toString(): string {\n    return this._str;\n  }\n\n  valueOf(): string {\n    return this._str;\n  }\n}\n\nexport class Num extends Value {\n  constructor(public _num: f64) {\n    super();\n  }\n\n  stringify(): string {\n    return this._num.toString();\n  }\n\n  valueOf(): f64 {\n    return this._num;\n  }\n}\n\nexport class Float extends Num {\n}\n\nexport class Integer extends Value {\n  constructor(public _num: i64) {\n    super();\n  }\n\n  stringify(): string {\n    return this._num.toString();\n  }\n\n  valueOf(): i64 {\n    return this._num;\n  }\n}\n\nexport class Null extends Value {\n  constructor() {\n    super();\n  }\n\n  stringify(): string {\n    return \"null\";\n  }\n\n  valueOf(): null {\n    return null;\n  }\n}\n\nexport class Bool extends Value {\n  constructor(public _bool: bool) {\n    super();\n  }\n\n  stringify(): string {\n    return this._bool.toString();\n  }\n\n  valueOf(): bool {\n    return this._bool;\n  }\n}\n\nexport class Arr extends Value {\n    _arr: Array<Value>;\n    constructor() {\n      super();\n      this._arr = new Array<Value>();\n    }\n\n    push(obj: Value): void {\n      this._arr.push(obj);\n    }\n\n    stringify(): string {\n      return (\n        \"[\" +\n        this._arr\n          .map<string>((val: Value, i: i32, _arr: Value[]): string =>\n            val.stringify()\n          )\n          .join(\",\") +\n        \"]\"\n      );\n    }\n\n    valueOf(): Array<Value> {\n      return this._arr;\n    }\n}\n\nexport class Obj extends Value {\n    _obj: Map<string, Value>;\n\n    constructor() {\n      super();\n      this._obj = new Map();\n    }\n\n    get keys(): string[] {\n      return this._obj.keys();\n    }\n\n    stringify(): string {\n      const keys = this._obj.keys();\n      const objs: string[] = new Array<string>(keys.length);\n      for (let i: i32 = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const value = this._obj.get(key);\n        // Currently must get the string value before interpolation\n        // see: https://github.com/AssemblyScript/assemblyscript/issues/1944\n        const valStr = value.stringify();\n        objs[i] = '\"' + key + '\":' + valStr;\n      }\n\n      return \"{\" + objs.join(\",\") + \"}\";\n    }\n\n    valueOf(): Map<string, Value> {\n      return this._obj;\n    }\n\n    set<T>(key: string, value: T): void {\n      if (isReference<T>(value)) {\n        if (value instanceof Value) {\n          this._obj.set(key, <Value>value);\n          return;\n        }\n      }\n      this._obj.set(key, from<T>(value));\n    }\n\n    has(key: string): bool {\n      return this._obj.has(key);\n    }\n\n    get(key: string): Value | null {\n      if (!this._obj.has(key)) {\n        return null;\n      }\n      return this._obj.get(key);\n    }\n\n    getValue(key: string): Value | null {\n      return this.get(key);\n    }\n\n    getString(key: string): Str | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isString) {\n        return <Str>jsonValue;\n      }\n      return null;\n    }\n\n    getNum(key: string): Num | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isNum) {\n        return <Num>jsonValue;\n      }\n      return null;\n    }\n\n    getFloat(key: string): Float | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isFloat) {\n        return <Float>jsonValue;\n      }\n      return null;\n    }\n\n    getInteger(key: string): Integer | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isInteger) {\n        return <Integer>jsonValue;\n      }\n      return null;\n    }\n\n    getBool(key: string): Bool | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isBool) {\n        return <Bool>jsonValue;\n      }\n      return null;\n    }\n\n    getArr(key: string): Arr | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isArr) {\n        return <Arr>jsonValue;\n      }\n      return null;\n    }\n\n    getObj(key: string): Obj | null {\n      let jsonValue = this.get(key);\n      if (jsonValue != null && jsonValue.isObj) {\n        return <Obj>jsonValue;\n      }\n      return null;\n    }\n}\n\nexport function from<T>(val: T): Value {\n  if (isBoolean<T>(val)) {\n    return Value.Bool(<bool>val);\n  }\n  if (isInteger<T>(val)) {\n    return Value.Integer(val);\n  }\n  if (isFloat<T>(val)) {\n    return Value.Float(val);\n  }\n  if (isString<T>(val)) {\n    return Value.String(<string>val);\n  }\n  if (val == null) {\n    return Value.Null();\n  }\n  if (isArrayLike<T>(val)) {\n    const arr = Value.Array();\n    for (let i: i32 = 0; i < val.length; i++) {\n      // @ts-ignore\n      arr.push(from<valueof<T>>(val[i]));\n    }\n    return arr;\n  }\n  /**\n     * TODO: add object support.\n     */\n  return Value.Object();\n}\n\n// @ts-ignore\n@inline\n/** Parses a string or Uint8Array and returns a Json Value. */\nexport function parse<T = Uint8Array>(str: T): Value {\n  return _JSON.parse(str);\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getF64FromJSONOptional, getStringFromJSON, getStringFromJSONOptional, isFlatJSONObj\n} from '../helpers/jsonHelpers'\nimport { _getPlatformData } from '../managers/platformDataManager'\nimport {\n    DVCUser_PB,\n    encodeDVCUser_PB,\n    NullableString,\n    NullableDouble,\n    NullableCustomData,\n    CustomDataValue,\n    CustomDataType\n} from './'\n\ninterface DVCUserInterface {\n    user_id: string\n    email: string | null\n    name: string | null\n    language: string | null\n    country: string | null\n    appVersion: string | null\n    appBuild: f64\n    deviceModel: string | null\n    customData: JSON.Obj | null\n    privateCustomData: JSON.Obj | null\n}\n\nfunction getJSONObjFromPBCustomData(nullableCustomData: NullableCustomData | null): JSON.Obj | null  {\n    if (!nullableCustomData || nullableCustomData.isNull) return null\n\n    const customDataObj = new JSON.Obj()\n    const keys = nullableCustomData.value.keys()\n\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        const value: CustomDataValue = nullableCustomData.value.get(key)\n        if (value && value.type === CustomDataType.Bool) {\n            customDataObj.set(key, value.boolValue)\n        } else if (value && value.type === CustomDataType.Num) {\n            customDataObj.set(key, value.doubleValue)\n        } else if (value && value.type === CustomDataType.Str) {\n            customDataObj.set(key, value.stringValue)\n        } else if (value && value.type === CustomDataType.Null) {\n            customDataObj.set(key, new JSON.Null())\n        } else {\n            throw new Error('DVCUser customData can\\'t contain nested objects or arrays')\n        }\n    }\n\n    return customDataObj\n}\n\nfunction nullableCustomDataFromJSONObj(jsonObj: JSON.Obj | null): NullableCustomData {\n    if (!jsonObj) return new NullableCustomData(new Map(), true)\n\n    const keys = jsonObj.keys\n    const customDataMap = new Map<string, CustomDataValue>()\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        const value = jsonObj.get(key)\n        if (!value) continue\n\n        if (value.isBool) {\n            customDataMap.set(key, new CustomDataValue(CustomDataType.Bool, (value as JSON.Bool).valueOf()))\n        } else if (value.isNum) {\n            customDataMap.set(key, new CustomDataValue(CustomDataType.Num, false, (value as JSON.Num).valueOf()))\n        } else if (value.isString) {\n            customDataMap.set(key, new CustomDataValue(CustomDataType.Str, false, 0, (value as JSON.Str).valueOf()))\n        } else if (value.isNull) {\n            customDataMap.set(key, new CustomDataValue(CustomDataType.Null))\n        }\n    }\n    return new NullableCustomData(customDataMap, false)\n}\n\nexport class DVCUser extends JSON.Obj implements DVCUserInterface {\n    constructor(\n        public readonly user_id: string,\n        public readonly email: string | null,\n        public readonly name: string | null,\n        public readonly language: string | null,\n        public readonly country: string | null,\n        public readonly appBuild: f64,\n        public readonly appVersion: string | null,\n        public readonly deviceModel: string | null,\n        public readonly customData: JSON.Obj | null,\n        public readonly privateCustomData: JSON.Obj | null\n    ) {\n        super()\n    }\n\n    static fromPBUser(userPB: DVCUser_PB): DVCUser {\n        const nullableEmail = userPB.email\n        const nullableName = userPB.name\n        const nullableLanguage = userPB.language\n        const nullableCountry = userPB.country\n        const nullableAppBuild = userPB.appBuild\n        const nullableAppVersion = userPB.appVersion\n        const nullableDeviceModel = userPB.deviceModel\n        const nullableCustomData = userPB.customData\n        const nullablePrivateCustomData = userPB.privateCustomData\n\n        return new DVCUser(\n            userPB.userId,\n            (nullableEmail && !nullableEmail.isNull) ? nullableEmail.value : null,\n            (nullableName && !nullableName.isNull) ? nullableName.value : null,\n            (nullableLanguage && !nullableLanguage.isNull) ? nullableLanguage.value : null,\n            (nullableCountry && !nullableCountry.isNull) ? nullableCountry.value : null,\n            (nullableAppBuild && !nullableAppBuild.isNull) ? nullableAppBuild.value : NaN,\n            (nullableAppVersion && !nullableAppVersion.isNull) ? nullableAppVersion.value : null,\n            (nullableDeviceModel && !nullableDeviceModel.isNull) ? nullableDeviceModel.value : null,\n            getJSONObjFromPBCustomData(nullableCustomData),\n            getJSONObjFromPBCustomData(nullablePrivateCustomData),\n        )\n    }\n\n    toProtoBuf(): Uint8Array {\n        const emptyString = ''\n        return encodeDVCUser_PB(new DVCUser_PB(\n            this.user_id,\n            new NullableString(this.email || emptyString, this.email === null),\n            new NullableString(this.name || emptyString, this.name === null),\n            new NullableString(this.language || emptyString, this.language === null),\n            new NullableString(this.country || emptyString, this.country === null),\n            new NullableDouble(this.appBuild || 0.0, isNaN(this.appBuild)),\n            new NullableString(this.appVersion || emptyString, this.appVersion === null),\n            new NullableString(this.deviceModel || emptyString, this.deviceModel === null),\n            nullableCustomDataFromJSONObj(this.customData),\n            nullableCustomDataFromJSONObj(this.privateCustomData)\n        ))\n    }\n\n    static fromJSONString(userStr: string): DVCUser {\n        const userJSON = JSON.parse(userStr)\n        if (!userJSON.isObj) throw new Error('dvcUserFromJSONString not a JSON Object')\n        return this.fromJSONObj(userJSON as JSON.Obj)\n    }\n\n    static fromUTF8(userStr: Uint8Array): DVCUser {\n        const userJSON = JSON.parse(userStr)\n        if (!userJSON.isObj) throw new Error('dvcUserFromUTF8 not a JSON Object')\n        return this.fromJSONObj(userJSON as JSON.Obj)\n    }\n\n    static fromJSONObj(user: JSON.Obj): DVCUser {\n        const customData = user.getObj('customData')\n        if (!isFlatJSONObj(customData)) {\n            throw new Error('DVCUser customData can\\'t contain nested objects or arrays')\n        }\n\n        const privateCustomData = user.getObj('privateCustomData')\n        if (!isFlatJSONObj(privateCustomData)) {\n            throw new Error('DVCUser privateCustomData can\\'t contain nested objects or arrays')\n        }\n\n        return new DVCUser(\n            getStringFromJSON(user, 'user_id'),\n            getStringFromJSONOptional(user, 'email'),\n            getStringFromJSONOptional(user, 'name'),\n            getStringFromJSONOptional(user, 'language'),\n            getStringFromJSONOptional(user, 'country'),\n            getF64FromJSONOptional(user, 'appBuild', NaN),\n            getStringFromJSONOptional(user, 'appVersion'),\n            getStringFromJSONOptional(user, 'deviceModel'),\n            customData,\n            privateCustomData\n        )\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('user_id', this.user_id)\n        if (this.email) json.set('email', this.email)\n        if (this.name) json.set('name', this.name)\n        if (this.language) json.set('language', this.language)\n        if (this.country) json.set('country', this.country)\n        if (this.appVersion) json.set('appVersion', this.appVersion)\n        if (!isNaN(this.appBuild)) json.set('appBuild', this.appBuild)\n        if (this.deviceModel) json.set('deviceModel', this.deviceModel)\n        if (this.customData) json.set('customData', this.customData)\n        if (this.privateCustomData) json.set('privateCustomData', this.privateCustomData)\n        return json.stringify()\n    }\n}\n\nexport class DVCPopulatedUser extends JSON.Value implements DVCUserInterface {\n    readonly user_id: string\n    readonly email: string | null\n    readonly name: string | null\n    readonly language: string | null\n    readonly country: string | null\n    readonly appVersion: string | null\n    readonly appBuild: f64\n    customData: JSON.Obj | null\n    privateCustomData: JSON.Obj | null\n    private _combinedCustomData: JSON.Obj\n    readonly deviceModel: string | null\n\n    readonly createdDate: Date\n    readonly lastSeenDate: Date\n    readonly platform: string\n    readonly platformVersion: string\n    readonly sdkType: string\n    readonly sdkVersion: string\n    readonly sdkPlatform: string | null\n    readonly hostname: string | null\n\n    constructor(user: DVCUser) {\n        super()\n        this.user_id = user.user_id\n        this.email = user.email\n        this.name = user.name\n        this.language = user.language\n        this.country = user.country\n        this.appVersion = user.appVersion\n        this.appBuild = user.appBuild\n        this.customData = user.customData\n        this.privateCustomData = user.privateCustomData\n        this.deviceModel = user.deviceModel\n\n        const combinedCustomData = new JSON.Obj()\n\n        const customData = user.customData\n        if (customData) {\n            for (let i = 0; i < customData.keys.length; i++) {\n                const key = customData.keys[i]\n                combinedCustomData.set(key, customData.get(key))\n            }\n        }\n\n        const privateCustomData = user.privateCustomData\n        if (privateCustomData) {\n            for (let i = 0; i < privateCustomData.keys.length; i++) {\n                const key = privateCustomData.keys[i]\n                combinedCustomData.set(key, privateCustomData.get(key))\n            }\n        }\n        this._combinedCustomData = combinedCustomData\n\n        this.createdDate = new Date(Date.now())\n        this.lastSeenDate = new Date(Date.now())\n\n        const platformData = _getPlatformData()\n        this.platform = platformData.platform\n        this.platformVersion = platformData.platformVersion\n        this.sdkType = platformData.sdkType\n        this.sdkVersion = platformData.sdkVersion\n        this.sdkPlatform = platformData.sdkPlatform\n        this.hostname = platformData.hostname\n\n        return this\n    }\n\n    static fromJSONString(userStr: string): DVCPopulatedUser {\n        return new DVCPopulatedUser(DVCUser.fromJSONString(userStr))\n    }\n\n    static fromUTF8(userBytes: Uint8Array): DVCPopulatedUser {\n        return new DVCPopulatedUser(DVCUser.fromUTF8(userBytes))\n    }\n\n    getCombinedCustomData(): JSON.Obj {\n        return this._combinedCustomData\n    }\n\n    mergeClientCustomData(clientCustomData: JSON.Obj): void {\n        if (!this.customData && clientCustomData.keys.length > 0) {\n            this.customData = new JSON.Obj()\n        }\n\n        for (let i = 0; i < clientCustomData.keys.length; i++) {\n            if (!this.customData!.has(clientCustomData.keys[i])\n                    && (this.privateCustomData && !this.privateCustomData!.has(clientCustomData.keys[i]))) {\n                this.customData!.set(clientCustomData.keys[i], clientCustomData.get(clientCustomData.keys[i]))\n            }\n        }\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('user_id', this.user_id)\n        if (this.email) json.set('email', this.email)\n        if (this.name) json.set('name', this.name)\n        if (this.language) json.set('language', this.language)\n        if (this.country) json.set('country', this.country)\n        if (this.appVersion) json.set('appVersion', this.appVersion)\n        if (!isNaN(this.appBuild)) json.set('appBuild', this.appBuild)\n        if (this.deviceModel) json.set('deviceModel', this.deviceModel)\n\n        if (this.customData) {\n            json.set('customData', this.customData)\n        }\n        if (this.privateCustomData) {\n            json.set('privateCustomData', this.privateCustomData)\n        }\n\n        json.set('createdDate', (this.createdDate as Date).toISOString())\n        json.set('lastSeenDate', (this.lastSeenDate as Date).toISOString())\n        json.set('platform', this.platform)\n        json.set('platformVersion', this.platformVersion)\n        json.set('sdkType', this.sdkType)\n        json.set('sdkVersion', this.sdkVersion)\n        if (this.sdkPlatform) json.set('sdkPlatform', this.sdkPlatform)\n        if (this.hostname) json.set('hostname', this.hostname)\n\n        return json.stringify()\n    }\n}\n","import { E_INVALIDDATE } from \"util/error\";\nimport { Date as Date_binding } from \"./bindings/dom\";\n\n// @ts-ignore: decorator\n@inline const\n  MILLIS_PER_DAY    = 1000 * 60 * 60 * 24,\n  MILLIS_PER_HOUR   = 1000 * 60 * 60,\n  MILLIS_PER_MINUTE = 1000 * 60,\n  MILLIS_PER_SECOND = 1000,\n\n  YEARS_PER_EPOCH = 400,\n  DAYS_PER_EPOCH = 146097,\n  EPOCH_OFFSET = 719468, // Jan 1, 1970\n  MILLIS_LIMIT = 8640000000000000;\n\n// ymdFromEpochDays returns values via globals to avoid allocations\n// @ts-ignore: decorator\n@lazy let _month: i32, _day: i32;\n\nexport class Date {\n  private year: i32 = 0;\n  private month: i32 = 0;\n  private day: i32 = 0;\n\n  @inline static UTC(\n    year: i32,\n    month: i32 = 0,\n    day: i32 = 1,\n    hour: i32 = 0,\n    minute: i32 = 0,\n    second: i32 = 0,\n    millisecond: i32 = 0\n  ): i64 {\n    if (year >= 0 && year <= 99) year += 1900;\n    let ms = epochMillis(year, month + 1, day, hour, minute, second, millisecond);\n    if (invalidDate(ms)) throw new RangeError(E_INVALIDDATE);\n    return ms;\n  }\n\n  @inline static now(): i64 {\n    return <i64>Date_binding.now();\n  }\n\n  // It can parse only ISO 8601 inputs like YYYY-MM-DDTHH:MM:SS.000Z\n  @inline static parse(dateString: string): Date {\n    return this.fromString(dateString);\n  }\n\n  static fromString(dateTimeString: string): Date {\n    if (!dateTimeString.length) throw new RangeError(E_INVALIDDATE);\n    var\n      hour: i32 = 0,\n      min: i32 = 0,\n      sec: i32 = 0,\n      ms: i32 = 0;\n\n    let dateString = dateTimeString;\n    let posT = dateTimeString.indexOf(\"T\");\n    if (~posT) {\n      // includes a time component\n      let timeString: string;\n      dateString = dateTimeString.substring(0, posT);\n      timeString = dateTimeString.substring(posT + 1);\n      // parse the HH-MM-SS component\n      let timeParts = timeString.split(\":\");\n      let len = timeParts.length;\n      if (len <= 1) throw new RangeError(E_INVALIDDATE);\n\n      hour = I32.parseInt(timeParts[0]);\n      min  = I32.parseInt(timeParts[1]);\n      if (len >= 3) {\n        let secAndMs = timeParts[2];\n        let posDot = secAndMs.indexOf(\".\");\n        if (~posDot) {\n          // includes milliseconds\n          sec = I32.parseInt(secAndMs.substring(0, posDot));\n          ms  = I32.parseInt(secAndMs.substring(posDot + 1));\n        } else {\n          sec = I32.parseInt(secAndMs);\n        }\n      }\n    }\n    // parse the YYYY-MM-DD component\n    let parts = dateString.split(\"-\");\n    let year = I32.parseInt(parts[0]);\n    let month = 1, day = 1;\n    let len = parts.length;\n    if (len >= 2) {\n      month = I32.parseInt(parts[1]);\n      if (len >= 3) {\n        day = I32.parseInt(parts[2]);\n      }\n    }\n    return new Date(epochMillis(year, month, day, hour, min, sec, ms));\n  }\n\n  constructor(private epochMillis: i64) {\n    // this differs from JavaScript which prefer return NaN or \"Invalid Date\" string\n    // instead throwing exception.\n    if (invalidDate(epochMillis)) throw new RangeError(E_INVALIDDATE);\n\n    this.year = dateFromEpoch(epochMillis);\n    this.month = _month;\n    this.day = _day;\n  }\n\n  @inline getTime(): i64 {\n    return this.epochMillis;\n  }\n\n  setTime(time: i64): i64 {\n    if (invalidDate(time)) throw new RangeError(E_INVALIDDATE);\n\n    this.epochMillis = time;\n    this.year = dateFromEpoch(time);\n    this.month = _month;\n    this.day = _day;\n\n    return time;\n  }\n\n  @inline getUTCFullYear(): i32 {\n    return this.year;\n  }\n\n  @inline getUTCMonth(): i32 {\n    return this.month - 1;\n  }\n\n  @inline getUTCDate(): i32 {\n    return this.day;\n  }\n\n  @inline getUTCDay(): i32 {\n    return dayOfWeek(this.year, this.month, this.day);\n  }\n\n  getUTCHours(): i32 {\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_DAY)) / MILLIS_PER_HOUR;\n  }\n\n  getUTCMinutes(): i32 {\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_HOUR)) / MILLIS_PER_MINUTE;\n  }\n\n  getUTCSeconds(): i32 {\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_MINUTE)) / MILLIS_PER_SECOND;\n  }\n\n  getUTCMilliseconds(): i32 {\n    return i32(euclidRem(this.epochMillis, MILLIS_PER_SECOND));\n  }\n\n  setUTCMilliseconds(millis: i32): void {\n    this.setTime(this.epochMillis + (millis - this.getUTCMilliseconds()));\n  }\n\n  setUTCSeconds(seconds: i32): void {\n    this.setTime(this.epochMillis + (seconds - this.getUTCSeconds()) * MILLIS_PER_SECOND);\n  }\n\n  setUTCMinutes(minutes: i32): void {\n    this.setTime(this.epochMillis + (minutes - this.getUTCMinutes()) * MILLIS_PER_MINUTE);\n  }\n\n  setUTCHours(hours: i32): void {\n    this.setTime(this.epochMillis + (hours - this.getUTCHours()) * MILLIS_PER_HOUR);\n  }\n\n  setUTCDate(day: i32): void {\n    if (this.day == day) return;\n    this.setTime(join(this.year, this.month, day, this.epochMillis));\n  }\n\n  setUTCMonth(month: i32, day: i32 = this.day): void {\n    if (this.month == month + 1) return;\n    this.setTime(join(this.year, month + 1, day, this.epochMillis));\n  }\n\n  setUTCFullYear(year: i32): void {\n    if (this.year == year) return;\n    this.setTime(join(year, this.month, this.day, this.epochMillis));\n  }\n\n  toISOString(): string {\n    // TODO: add more low-level helper which combine toString and padStart without extra allocation\n\n    let yr = this.year;\n    let isNeg = yr < 0;\n    let year = (isNeg || yr >= 10000)\n      ? (isNeg ? \"-\" : \"+\") + stringify(abs(yr), 6)\n      : stringify(yr, 4);\n    let month = stringify(this.month, 2);\n    let day = stringify(this.day);\n    let hours = stringify(this.getUTCHours());\n    let mins = stringify(this.getUTCMinutes());\n    let secs = stringify(this.getUTCSeconds());\n    let ms = stringify(this.getUTCMilliseconds(), 3);\n\n    return `${year}-${month}-${day}T${hours}:${mins}:${secs}.${ms}Z`;\n  }\n\n  toUTCString(): string {\n    const\n      weeks: StaticArray<string> = [\n        \"Sun, \", \"Mon, \", \"Tue, \", \"Wed, \", \"Thu, \", \"Fri, \", \"Sat, \"\n      ],\n      months: StaticArray<string> = [\n        \" Jan \", \" Feb \", \" Mar \", \" Apr \", \" May \", \" Jun \",\n        \" Jul \", \" Aug \", \" Sep \", \" Oct \", \" Nov \", \" Dec \"\n      ];\n\n    let mo = this.month;\n    let da = this.day;\n    let yr = this.year;\n    let wd = dayOfWeek(yr, mo, da);\n    let year = stringify(abs(yr), 4);\n    let month = unchecked(months[mo - 1]);\n    let week = unchecked(weeks[wd]);\n    let day = stringify(da);\n    let hours = stringify(this.getUTCHours());\n    let mins = stringify(this.getUTCMinutes());\n    let secs = stringify(this.getUTCSeconds());\n\n    return `${week}${day}${month}${yr < 0 ? \"-\" : \"\"}${year} ${hours}:${mins}:${secs} GMT`;\n  }\n\n  toDateString(): string {\n    // TODO: use u64 static data instead 4 chars\n    // also use stream itoa variants.\n    const\n      weeks: StaticArray<string> = [\n        \"Sun \", \"Mon \", \"Tue \", \"Wed \", \"Thu \", \"Fri \", \"Sat \"\n      ],\n      months: StaticArray<string> = [\n        \"Jan \", \"Feb \", \"Mar \", \"Apr \", \"May \", \"Jun \",\n        \"Jul \", \"Aug \", \"Sep \", \"Oct \", \"Nov \", \"Dec \"\n      ];\n\n    let mo = this.month;\n    let da = this.day;\n    let yr = this.year;\n    let wd = dayOfWeek(yr, mo, da);\n    let year = stringify(abs(yr), 4);\n    let month = unchecked(months[mo - 1]);\n    let week = unchecked(weeks[wd]);\n    let day = stringify(da);\n\n    return `${week}${month}${day}${yr < 0 ? \" -\" : \" \"}${year}`;\n  }\n\n  // Note: it uses UTC time instead local time (without timezone offset)\n  toTimeString(): string {\n    let hours = stringify(this.getUTCHours());\n    let mins = stringify(this.getUTCMinutes());\n    let secs = stringify(this.getUTCSeconds());\n    // TODO: add timezone\n    return `${hours}:${mins}:${secs}`;\n  }\n\n  // Note: it uses UTC datetime instead local datetime (without timezone offset)\n  toString(): string {\n    return `${this.toDateString()} ${this.toTimeString()}`;\n  }\n}\n\nfunction epochMillis(\n  year: i32,\n  month: i32,\n  day: i32,\n  hour: i32,\n  minute: i32,\n  second: i32,\n  milliseconds: i32\n): i64 {\n  return (\n    daysSinceEpoch(year, month, day) * MILLIS_PER_DAY +\n    hour * MILLIS_PER_HOUR +\n    minute * MILLIS_PER_MINUTE +\n    second * MILLIS_PER_SECOND +\n    milliseconds\n  );\n}\n\n// @ts-ignore: decorator\n@inline function floorDiv<T extends number>(a: T, b: T): T {\n  return (a - (a < 0 ? b - 1 : 0)) / b as T;\n}\n\n// @ts-ignore: decorator\n@inline function euclidRem<T extends number>(a: T, b: T): T {\n  let m = a % b;\n  return m + (m < 0 ? b : 0) as T;\n}\n\nfunction invalidDate(millis: i64): bool {\n  // @ts-ignore\n  return (millis < -MILLIS_LIMIT) | (millis > MILLIS_LIMIT);\n}\n\n// Based on \"Euclidean Affine Functions and Applications to Calendar Algorithms\"\n// Paper: https://arxiv.org/pdf/2102.06959.pdf\nfunction dateFromEpoch(ms: i64): i32 {\n  let da = (<i32>floorDiv(ms, MILLIS_PER_DAY) * 4 + EPOCH_OFFSET * 4) | 3;\n  let q0 = floorDiv(da, DAYS_PER_EPOCH); // [0, 146096]\n  let r1 = <u32>da - q0 * DAYS_PER_EPOCH;\n  let u1 = u64(r1 | 3) * 2939745;\n  let dm1 = <u32>u1 / 11758980;\n  let n1 = 2141 * dm1 + 197913;\n  let year = 100 * q0 + i32(u1 >>> 32);\n  let mo = n1 >>> 16;\n  _day = (n1 & 0xFFFF) / 2141 + 1; // [1, 31]\n  if (dm1 >= 306) { mo -= 12; ++year; }\n  _month = mo; // [1, 12]\n  return year;\n}\n\n// http://howardhinnant.github.io/date_algorithms.html#days_from_civil\nfunction daysSinceEpoch(y: i32, m: i32, d: i32): i64 {\n  y -= i32(m <= 2);\n  let era = <u32>floorDiv(y, YEARS_PER_EPOCH);\n  let yoe = <u32>y - era * YEARS_PER_EPOCH; // [0, 399]\n  let doy = <u32>(153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1; // [0, 365]\n  let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy; // [0, 146096]\n  return <i64><i32>(era * 146097 + doe - EPOCH_OFFSET);\n}\n\n// TomohikoSakamoto algorithm from https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week\nfunction dayOfWeek(year: i32, month: i32, day: i32): i32 {\n  const tab = memory.data<u8>([0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]);\n\n  year -= i32(month < 3);\n  year += floorDiv(year, 4) - floorDiv(year, 100) + floorDiv(year, YEARS_PER_EPOCH);\n  month = <i32>load<u8>(tab + month - 1);\n  return euclidRem(year + month + day, 7);\n}\n\nfunction stringify(value: i32, padding: i32 = 2): string {\n  return value.toString().padStart(padding, \"0\");\n}\n\nfunction join(year: i32, month: i32, day: i32, ms: i64): i64 {\n  return daysSinceEpoch(year, month, day) * MILLIS_PER_DAY + euclidRem(ms, MILLIS_PER_DAY);\n}\n","export namespace Buffer {\n  export function fromString(str: string): Uint8Array {\n    const buffer = String.UTF8.encode(str, false);\n\n    // Workaround for https://github.com/AssemblyScript/assemblyscript/issues/1066\n    if (buffer.byteLength === 0) return new Uint8Array(0);\n\n    return Uint8Array.wrap(buffer);\n  }\n\n  export function toString(arr: Uint8Array): string {\n    return String.UTF8.decode(arr.buffer, false);\n  }\n\n  /**\n   * Returns a pointer to the start of the raw data (i.e. after the header)\n   *\n   * @see https://docs.assemblyscript.org/details/memory#internals\n   */\n  export function getDataPtr(arr: Uint8Array): usize {\n    return changetype<usize>(arr.buffer) + arr.byteOffset;\n  }\n\n  export function readString(\n    arr: Uint8Array,\n    start: usize,\n    end: usize\n  ): string {\n    return String.UTF8.decodeUnsafe(getDataPtr(arr) + start, end - start);\n  }\n}\n","import { Buffer } from \"./util\";\n\n/**\n * Extend from this class to handle events from parser.\n * Default implementation traverses whole object tree and does nothing.\n */\nexport abstract class JSONHandler {\n  setString(name: string, value: string): void {}\n\n  setBoolean(name: string, value: bool): void {}\n\n  setNull(name: string): void {}\n\n  setInteger(name: string, value: i64): void {}\n\n  setFloat(name: string, value: f64): void {}\n\n  pushArray(name: string): bool {\n    return true;\n  }\n\n  popArray(): void {}\n\n  pushObject(name: string): bool {\n    return true;\n  }\n\n  popObject(): void {}\n}\n\n/**\n * Extend from this class to handle events from parser.\n * This implementation crashes on every unimplemented set/push method\n * to allow easier validation of input.\n */\nexport class ThrowingJSONHandler extends JSONHandler {\n  setString(name: string, value: string): void {\n    assert(false, \"Unexpected string field \" + name + ' : \"' + value + '\"');\n  }\n\n  setBoolean(name: string, value: bool): void {\n    assert(\n      false,\n      \"Unexpected bool field \" + name + \" : \" + (value ? \"true\" : \"false\")\n    );\n  }\n\n  setNull(name: string): void {\n    assert(false, \"Unexpected null field \" + name);\n  }\n\n  setInteger(name: string, value: i64): void {\n    // @ts-ignore integer does have toString\n    assert(\n      false,\n      \"Unexpected integer field \" + name + \" : \" + value.toString()\n    );\n  }\n\n  setFloat(name: string, value: f64): void {\n    // @ts-ignore integer does have toString\n    assert(\n      false,\n      \"Unexpected float field \" + name + \" : \" + value.toString()\n    );\n  }\n\n  pushArray(name: string): bool {\n    assert(false, \"Unexpected array field \" + name);\n    return true;\n  }\n\n  pushObject(name: string): bool {\n    assert(false, \"Unexpected object field \" + name);\n    return true;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy const TRUE_STR = \"true\";\n// @ts-ignore: decorator\n@lazy const FALSE_STR = \"false\";\n// @ts-ignore: decorator\n@lazy const NULL_STR = \"null\";\n// @ts-ignore: decorator\n@lazy const CHAR_0: i32 = 48; // \"0\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_9: i32 = 57; // \"9\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_A: i32 = 65; // \"A\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_A_LOWER: i32 = 97; // \"a\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_PERIOD: i32 = 46; // \".\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_MINUS: i32 = 45; // \"-\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_PLUS: i32 = 43; // \"+\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_E: i32 = 69; // \"E\".charCodeAt(0);\n// @ts-ignore: decorator\n@lazy const CHAR_E_LOWER: i32 = 101; // \"e\".charCodeAt(0);\n\nexport class DecoderState {\n  lastKey: string = \"\";\n  readIndex: i32 = 0;\n  constructor(public buffer: Uint8Array) {}\n\n  get ptr(): usize {\n    return Buffer.getDataPtr(this.buffer);\n  }\n\n  readString(start: usize, end: usize = this.readIndex): string {\n    return Buffer.readString(this.buffer, start, end - 1);\n  }\n}\n\nexport class JSONDecoder<JSONHandlerT extends JSONHandler> {\n  handler: JSONHandlerT;\n  _state: DecoderState | null = null;\n\n  constructor(handler: JSONHandlerT) {\n    this.handler = handler;\n  }\n\n  get state(): DecoderState {\n    return <DecoderState>this._state;\n  }\n\n  set state(state: DecoderState) {\n    this._state = state;\n  }\n\n  deserialize(\n    buffer: Uint8Array,\n    decoderState: DecoderState | null = null\n  ): void {\n    if (decoderState != null) {\n      this.state = decoderState;\n    } else {\n      this.state = new DecoderState(buffer);\n    }\n\n    assert(this.parseValue(), \"Cannot parse JSON\");\n    // TODO: Error if input left\n  }\n\n  private peekChar(): i32 {\n    if (this.state.readIndex >= this.state.buffer.length) {\n      return -1;\n    }\n    return this.state.buffer[this.state.readIndex];\n  }\n\n  private readChar(): i32 {\n    assert(\n      this.state.readIndex < this.state.buffer.length,\n      \"Unexpected input end\"\n    );\n    return this.state.buffer[this.state.readIndex++];\n  }\n\n  private parseValue(): bool {\n    this.skipWhitespace();\n    let result =\n      this.parseObject() ||\n      this.parseArray() ||\n      this.parseString() ||\n      this.parseBoolean() ||\n      this.parseNumber() ||\n      this.parseNull();\n    this.skipWhitespace();\n    return result;\n  }\n\n  private parseObject(): bool {\n    if (this.peekChar() != \"{\".charCodeAt(0)) {\n      return false;\n    }\n    let key = this.state.lastKey;\n    // @ts-ignore can be null\n    this.state.lastKey = \"\";\n    if (this.handler.pushObject(key)) {\n      this.readChar();\n      this.skipWhitespace();\n\n      let firstItem = true;\n      while (this.peekChar() != \"}\".charCodeAt(0)) {\n        if (!firstItem) {\n          assert(this.readChar() == \",\".charCodeAt(0), \"Expected ','\");\n        } else {\n          firstItem = false;\n        }\n        this.parseKey();\n        this.parseValue();\n      }\n      assert(this.readChar() == \"}\".charCodeAt(0), \"Unexpected end of object\");\n    }\n    this.handler.popObject();\n    return true;\n  }\n\n  private parseKey(): void {\n    this.skipWhitespace();\n    this.state.lastKey = this.readString();\n    this.skipWhitespace();\n    assert(this.readChar() == \":\".charCodeAt(0), \"Expected ':'\");\n  }\n\n  private parseArray(): bool {\n    if (this.peekChar() != \"[\".charCodeAt(0)) {\n      return false;\n    }\n    let key = this.state.lastKey;\n    // @ts-ignore can be null\n    this.state.lastKey = \"\";\n    if (this.handler.pushArray(key)) {\n      this.readChar();\n      this.skipWhitespace();\n\n      let firstItem = true;\n      while (this.peekChar() != \"]\".charCodeAt(0)) {\n        if (!firstItem) {\n          assert(this.readChar() == \",\".charCodeAt(0), \"Expected ','\");\n        } else {\n          firstItem = false;\n        }\n        this.parseValue();\n      }\n      assert(this.readChar() == \"]\".charCodeAt(0), \"Unexpected end of array\");\n    }\n    this.handler.popArray();\n    return true;\n  }\n\n  private parseString(): bool {\n    if (this.peekChar() != '\"'.charCodeAt(0)) {\n      return false;\n    }\n    this.handler.setString(this.state.lastKey, this.readString());\n    return true;\n  }\n\n  private readString(): string {\n    assert(\n      this.readChar() == '\"'.charCodeAt(0),\n      \"Expected double-quoted string\"\n    );\n    let savedIndex = this.state.readIndex;\n    // @ts-ignore can be null\n    let stringParts: Array<string> = new Array<string>();\n    for (;;) {\n      let byte = this.readChar();\n      assert(byte >= 0x20, \"Unexpected control character\");\n      if (byte == '\"'.charCodeAt(0)) {\n        let s = this.state.readString(savedIndex);\n        if (stringParts.length == 0) {\n          return s;\n        }\n        stringParts.push(s);\n        return stringParts.join(\"\");\n      } else if (byte == \"\\\\\".charCodeAt(0)) {\n        if (this.state.readIndex > savedIndex + 1) {\n          stringParts.push(this.state.readString(savedIndex));\n        }\n        stringParts.push(this.readEscapedChar());\n        savedIndex = this.state.readIndex;\n      }\n    }\n    // Should never happen\n    return \"\";\n  }\n\n  private readEscapedChar(): string {\n    let byte = this.readChar();\n    // TODO: Use lookup table for anything except \\u\n    if (byte == '\"'.charCodeAt(0)) {\n      return '\"';\n    }\n    if (byte == \"\\\\\".charCodeAt(0)) {\n      return \"\\\\\";\n    }\n    if (byte == \"/\".charCodeAt(0)) {\n      return \"/\";\n    }\n    if (byte == \"b\".charCodeAt(0)) {\n      return \"\\b\";\n    }\n    if (byte == \"n\".charCodeAt(0)) {\n      return \"\\n\";\n    }\n    if (byte == \"r\".charCodeAt(0)) {\n      return \"\\r\";\n    }\n    if (byte == \"t\".charCodeAt(0)) {\n      return \"\\t\";\n    }\n    if (byte == \"u\".charCodeAt(0)) {\n      let d1 = this.readHexDigit();\n      let d2 = this.readHexDigit();\n      let d3 = this.readHexDigit();\n      let d4 = this.readHexDigit();\n      let charCode = d1 * 0x1000 + d2 * 0x100 + d3 * 0x10 + d4;\n      return String.fromCodePoint(charCode);\n    }\n    assert(false, \"Unexpected escaped character: \" + String.fromCharCode(byte));\n    return \"\";\n  }\n\n  private readHexDigit(): i32 {\n    let byte = this.readChar();\n    let digit = byte - CHAR_0;\n    if (digit > 9) {\n      digit = byte - CHAR_A + 10;\n      if (digit < 10 || digit > 15) {\n        digit = byte - CHAR_A_LOWER + 10;\n      }\n    }\n    assert(digit >= 0 && digit < 16, \"Unexpected \\\\u digit\");\n    return digit;\n  }\n\n  private parseNumber(): bool {\n    let number: f64 = 0;\n    let sign: f64 = 1;\n    let isFloat: boolean = false;\n    // Also keeping the number as a string, because we will want to use the\n    // AS parseFloat as it handles precision best.\n    let numberAsString: string = \"\";\n\n    if (this.peekChar() == CHAR_MINUS) {\n      sign = -1;\n      numberAsString += String.fromCharCode(this.readChar());\n    }\n    let digits = 0;\n    while (\n      (CHAR_0 <= this.peekChar() && this.peekChar() <= CHAR_9) ||\n      CHAR_PERIOD == this.peekChar() ||\n      CHAR_MINUS == this.peekChar() ||\n      CHAR_PLUS == this.peekChar() ||\n      CHAR_E == this.peekChar() ||\n      CHAR_E_LOWER == this.peekChar()\n    ) {\n\n      let charCode = this.readChar();\n      numberAsString += String.fromCharCode(charCode);\n\n      if (charCode == CHAR_E || charCode == CHAR_E_LOWER || charCode == CHAR_PERIOD || charCode == CHAR_PLUS || charCode == CHAR_MINUS) {\n        isFloat = true;\n      } else {\n        if (!isFloat) {\n          let value: f64 = charCode - CHAR_0;\n          number *= 10;\n          number += value;\n        }\n        digits++;\n      }\n    }\n    if (digits > 0) {\n      if (isFloat || numberAsString == \"-0\") {\n        this.handler.setFloat(this.state.lastKey, parseFloat(numberAsString));\n      } else {\n        this.handler.setInteger(this.state.lastKey, <i64>(number * sign));\n      }\n      return true;\n    }\n    return false;\n  }\n\n  private parseBoolean(): bool {\n    if (this.peekChar() == FALSE_STR.charCodeAt(0)) {\n      this.readAndAssert(FALSE_STR);\n      this.handler.setBoolean(this.state.lastKey, false);\n      return true;\n    }\n    if (this.peekChar() == TRUE_STR.charCodeAt(0)) {\n      this.readAndAssert(TRUE_STR);\n      this.handler.setBoolean(this.state.lastKey, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseNull(): bool {\n    if (this.peekChar() == NULL_STR.charCodeAt(0)) {\n      this.readAndAssert(NULL_STR);\n      this.handler.setNull(this.state.lastKey);\n      return true;\n    }\n    return false;\n  }\n\n  private readAndAssert(str: string): void {\n    for (let i = 0; i < str.length; i++) {\n      assert(str.charCodeAt(i) == this.readChar(), \"Expected '\" + str + \"'\");\n    }\n  }\n\n  private skipWhitespace(): void {\n    while (this.isWhitespace(this.peekChar())) {\n      this.readChar();\n    }\n  }\n\n  private isWhitespace(charCode: i32): bool {\n    return (\n      charCode == 0x9 || charCode == 0xa || charCode == 0xd || charCode == 0x20\n    );\n  }\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\n\nexport function getJSONObjFromJSON(jsonObj: JSON.Obj, key: string): JSON.Obj {\n    const obj = jsonObj.getObj(key)\n    if (!obj) throw new Error(`Object not found for key: \"${key}\", obj: ${jsonObj.stringify()}`)\n    return obj\n}\n\nexport function getBoolFromJSON(jsonObj: JSON.Obj, key: string): bool {\n    const bool = jsonObj.getBool(key)\n    if (!bool) {\n        throw new Error(`Missing bool value for key: \"${key}\", obj: ${jsonObj.stringify()}`)\n    } else {\n        return bool.valueOf()\n    }\n}\n\nexport function getJSONObjFromJSONOptional(jsonObj: JSON.Obj, key: string): JSON.Obj | null {\n    const obj = jsonObj.getObj(key)\n    if (!obj) {\n        return null\n    }\n    return obj\n}\n\nexport function getJSONArrayFromJSON(jsonObj: JSON.Obj, key: string): JSON.Arr {\n    const obj = jsonObj.getArr(key)\n    if (!obj) throw new Error(`Array not found for key: \"${key}\", obj: ${jsonObj.stringify()}`)\n    return obj\n}\n\nexport function getValueFromJSONOptional(jsonObj: JSON.Obj, key: string): JSON.Value | null {\n    const value = jsonObj.get(key)\n    if (!value) {\n        return null\n    }\n    return value\n}\n\nexport function getStringFromJSON(jsonObj: JSON.Obj, key: string): string {\n    const str = jsonObj.getString(key)\n    if (!str) {\n        throw new Error(`Missing string value for key: \"${key}\", obj: ${jsonObj.stringify()}`)\n    } else {\n        return str.valueOf()\n    }\n}\n\nexport function getStringArrayFromJSON(jsonObj: JSON.Obj, key: string): string[] {\n    const strArray = getJSONArrayFromJSON(jsonObj, key).valueOf()\n    const strings = new Array<string>()\n    for (let i=0; i < strArray.length; i++) {\n        const value = strArray[i]\n        strings.push(value.toString())\n    }\n    return strings\n}\nexport function getArrayFromJSONOptional(jsonObj: JSON.Obj, key: string): JSON.Arr | null {\n    const array = jsonObj.getArr(key)\n    if (array) {\n        return array\n    } else {\n        return null\n    }\n}\nexport function getStringFromJSONOptional(jsonObj: JSON.Obj, key: string): string | null {\n    const str = jsonObj.getString(key)\n    if (!str) {\n        return null\n    } else {\n        return str.valueOf()\n    }\n}\n\nexport function isValidString(\n    jsonObj: JSON.Obj,\n    key: string,\n    validStrings: string[],\n    shouldThrow: bool = true\n): string {\n    const value = getStringFromJSON(jsonObj, key)\n    if (!validStrings.includes(value)) {\n        if (shouldThrow) {\n            throw new Error(\n                `Invalid string value: ${value}, for key: ${key}, must be one of: ${validStrings.join(', ')}`\n            )\n        } else {\n            console.log(`[DevCycle] Warning: String value: ${value}, for key: ${key} does not match a valid string.`)\n        }\n    }\n    return value\n}\n\nexport function isValidStringOptional(\n    jsonObj: JSON.Obj,\n    key: string,\n    validStrings: string[],\n    shouldThrow: bool = true\n): string | null {\n    const value = jsonObj.getString(key)\n    if (!value) {\n        return null\n    }\n\n    const str = value.toString()\n    if (!validStrings.includes(str)) {\n        if (shouldThrow) {\n            throw new Error(`Invalid string value: ${value}, for key: ${key}`)\n        } else {\n            console.log(`[DevCycle] Warning: String value: ${value}, for key: ${key} does not match a valid string.`)\n        }\n    }\n    return str\n}\n\nexport function getDateFromJSON(jsonObj: JSON.Obj, key: string): Date {\n    const dateStr = getStringFromJSON(jsonObj, key)\n    return Date.fromString(dateStr)\n}\n\nexport function getDateFromJSONOptional(jsonObj: JSON.Obj, key: string): Date | null {\n    const dateStr = getStringFromJSONOptional(jsonObj, key)\n    if (!dateStr) return null\n    return Date.fromString(dateStr as string)\n}\n\nexport function getF64FromJSONObj(jsonObj: JSON.Obj, key: string): f64 {\n    const value = jsonObj.get(key)\n    const num = value ? getF64FromJSONValue(value) : NaN\n    if (isNaN(num)) {\n        throw new Error(`Invalid number value: ${num}, for key: \"${key}\"`)\n    }\n    return num\n}\n\nexport function getF64FromJSONOptional(jsonObj: JSON.Obj, key: string, defaultValue: f64): f64 {\n    const num = jsonObj.get(key)\n    if (!num) return defaultValue\n\n    if (num && num.isFloat) {\n        return (num as JSON.Float).valueOf()\n    } else if (num && num.isInteger) {\n        const int = num as JSON.Integer\n        return f64(int.valueOf())\n    } else {\n        throw new Error(`Invalid number value: ${num}, for key: \"${key}\"`)\n    }\n}\n\nexport function jsonArrFromValueArray<T extends JSON.Value>(valueArr: Array<T>): JSON.Arr {\n    const jsonArr = new JSON.Arr()\n    for (let i = 0; i < valueArr.length; i++) {\n        jsonArr.push(valueArr[i])\n    }\n    return jsonArr\n}\n\nexport function jsonObjFromMap<T>(objMap: Map<string, T>): JSON.Obj {\n    const jsonObj = new JSON.Obj()\n    const keys = objMap.keys()\n\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        jsonObj.set(key, objMap.get(key))\n    }\n    return jsonObj\n}\n\nexport function getJSONValueFromJSON(jsonObj: JSON.Obj, key: string): JSON.Value {\n    const value = jsonObj.get(key)\n    if (!value) {\n        throw new Error(`Value missing for key: \"${key}\", obj: ${jsonObj.stringify()}`)\n    } else {\n        return value\n    }\n}\n\nexport function getF64FromJSONValue(jsonValue: JSON.Value): f64 {\n    const float = jsonValue.isFloat ? jsonValue as JSON.Float : null\n    const int = jsonValue.isInteger ? jsonValue as JSON.Integer : null\n    if (!float && !int) return NaN\n\n    return float\n        ? (float as JSON.Float).valueOf()\n        : (int ? f64((int as JSON.Integer).valueOf()) : NaN)\n}\n\nexport function getI32FromJSONValue(jsonValue: JSON.Value): i32 {\n    const int = jsonValue.isInteger ? jsonValue as JSON.Integer : null\n    if (!int) {\n        throw new Error(`Unable to get i32 value from JSON.Value: ${jsonValue.toString()}`)\n    }\n\n    return i32((int as JSON.Integer).valueOf())\n}\n\nexport function getStringMapFromJSONObj(jsonObj: JSON.Obj): Map<string, string> {\n    const stringMap = new Map<string, string>()\n    for (let i = 0; i < jsonObj.keys.length; i++) {\n        const key = jsonObj.keys[i]\n        const jsonString = jsonObj.get(key) as JSON.Str\n        stringMap.set(key, jsonString.valueOf())\n    }\n    return stringMap\n}\n\nexport function getStringArrayMapFromJSONObj(jsonObj: JSON.Obj): Map<string, string[]> {\n    const stringMap = new Map<string, string[]>()\n    for (let i = 0; i < jsonObj.keys.length; i++) {\n        const key = jsonObj.keys[i]\n        stringMap.set(key, getStringArrayFromJSON(jsonObj, key))\n    }\n    return stringMap\n}\n\nexport function isFlatJSONObj(json: JSON.Obj | null): bool {\n    if (!json) return true\n\n    const jsonObj = json as JSON.Obj\n    const keys = jsonObj.keys\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        const value = jsonObj.get(key)\n        if (value && (value.isObj || value.isArr)) {\n            return false\n        }\n    }\n    return true\n}\n","import { RegExp } from 'assemblyscript-regex/assembly'\n\nexport function find<T>(array: Array<T> | null, callbackfn: (value: T, index: i32, array: Array<T>) => bool): T | null {\n    if (!array) return null\n\n    const index = array.findIndex(callbackfn)\n    return index >= 0 ? array[index] : null\n}\n\nexport function findString(array: Array<string> | null, findStr: string): string | null {\n    if (!array) return null\n\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i]\n        if (findStr.includes(value)) {\n            return findStr\n        }\n    }\n    return null\n}\n\nexport function stringStartsWith(string: string, prefix: string): bool {\n    if(prefix === '') return false\n    if(prefix.length > string.length) return false\n\n    for (let i = 0; i < prefix.length; i++) {\n        if (string.charAt(i) !== prefix.charAt(i)) {\n            return false\n        }\n    }\n\n    return true\n}\n\nexport function stringEndsWith(string: string, suffix: string): bool {\n    if(suffix === '') return false\n    if(suffix.length > string.length) return false\n\n    for (let i = 0; i < suffix.length; i++) {\n        if (string.charAt(string.length - suffix.length + i) !== suffix.charAt(i)) {\n            return false\n        }\n    }\n\n    return true\n}\n\nexport function first<T>(array: Array<T> | null): T | null {\n    return (array && array.length > 0) ? array[0] : null\n}\n\nexport function last<T>(array: Array<T> | null): T | null {\n    return (array && array.length > 0) ? array[array.length - 1] : null\n}\n\nexport function includes(string: string | null, other: string): bool {\n    return string ? string.includes(other) : false\n}\n\nexport function replace(str: string, regex: RegExp, replaceStr: string): string {\n    const result = regex.exec(str)\n    const matches = (result && result.matches) ? result.matches : null\n    if (!result || !matches) return str\n\n    let replacedString = str\n    for (let i = 0; i < matches.length; i++) {\n        replacedString = replacedString.replace(matches[i], replaceStr)\n    }\n    return replacedString\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait32(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait64(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    let index: usize = 0;\n    let total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare let __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","import {\n  console as binding\n} from \"./bindings/dom\";\n\nexport namespace console {\n\n  export function assert<T>(condition: T, message: string = \"\"): void {\n    binding.assert(!!condition, message);\n  }\n\n  export function log(message: string = \"\"): void {\n    binding.log(message);\n  }\n\n  export function debug(message: string = \"\"): void {\n    binding.debug(message);\n  }\n\n  export function info(message: string = \"\"): void {\n    binding.info(message);\n  }\n\n  export function warn(message: string = \"\"): void {\n    binding.warn(message);\n  }\n\n  export function error(message: string = \"\"): void {\n    binding.error(message);\n  }\n\n  export function time(label: string = \"default\"): void {\n    binding.time(label);\n  }\n\n  export function timeLog(label: string = \"default\"): void {\n    binding.timeLog(label);\n  }\n\n  export function timeEnd(label: string = \"default\"): void {\n    binding.timeEnd(label);\n  }\n}\n","import { RegExp } from 'assemblyscript-regex/assembly'\nimport { findString, includes, replace, stringEndsWith, stringStartsWith } from '../helpers/lodashHelpers'\nimport { OptionsType, versionCompare } from './versionCompare'\nimport {\n    AudienceOperator,\n    AudienceFilter,\n    DVCPopulatedUser,\n    validSubTypes,\n    CustomDataFilter,\n    UserFilter,\n    AudienceMatchFilter,\n    Audience,\n    EVAL_REASON_DETAILS\n} from '../types'\nimport { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport { getF64FromJSONValue } from '../helpers/jsonHelpers'\n\nexport class SegmentationResult extends JSON.Value {\n    readonly result: bool\n    readonly reasonDetails: string | null\n\n    constructor(result: bool, reasonDetails: string | null = null) {\n        super()\n        this.result = result\n        this.reasonDetails = reasonDetails\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('result', this.result)\n        if (this.reasonDetails !== null) {\n            json.set('reasonDetails', this.reasonDetails!)\n        }\n        return json.stringify()\n    }\n}\n// TODO add support for OR/XOR as well as recursive filters\n/**\n * Evaluate an operator object based on its contained filters and the user data given\n * Returns true if the user's data allows them through the segmentation\n * @param operator - The set of filters to evaluate, and the boolean operator to follow (AND, OR, XOR)\n * @param audiences - a map of audience_id to audience, used for audienceMatch filters\n * @param user - The incoming user, device, and user agent data\n * @param clientCustomData - The custom data object associated with the client instance\n */\nexport function _evaluateOperator(\n    operator: AudienceOperator,\n    audiences: Map<string, Audience>,\n    user: DVCPopulatedUser,\n    clientCustomData: JSON.Obj\n): SegmentationResult {\n    if (!operator.filters.length) return new SegmentationResult(false)\n\n    if (operator.operator === 'or') {\n        // Replace Array.some() logic\n        for (let i = 0; i < operator.filters.length; i++) {\n            const filter = operator.filters[i]\n            if (filter.operatorClass !== null) {\n                const evalResult =\n                    _evaluateOperator(filter.operatorClass as AudienceOperator, audiences, user, clientCustomData)\n                // Instead of returning the value from only the first filter,\n                // we want to return true if any of the filters are true\n                if(evalResult.result) {\n                    return evalResult\n                }\n            } else if (filter.filterClass !== null) {\n                const evalResult = \n                    doesUserPassFilter(filter.filterClass as AudienceFilter, audiences, user, clientCustomData)\n                if(evalResult.result) {\n                    return evalResult\n                }\n            }\n        }\n        return new SegmentationResult(false) \n    } else if (operator.operator === 'and'){\n        const reasons = new Array<string>()\n        // Replace Array.every() logic\n        for (let i = 0; i < operator.filters.length; i++) {\n            const filter = operator.filters[i]\n            if (filter.operatorClass !== null) {\n               return _evaluateOperator(filter.operatorClass as AudienceOperator, audiences, user, clientCustomData)\n            } else if (filter.filterClass !== null) {\n                const evalResult = \n                    doesUserPassFilter(filter.filterClass as AudienceFilter, audiences, user, clientCustomData)\n                if(evalResult.result === false){\n                    return new SegmentationResult(false)\n                }\n                if(evalResult.reasonDetails !== null){ \n                    reasons.push(evalResult.reasonDetails!)\n                }\n            }\n        }\n        const allReasons = reasons.join(' AND ') \n        return new SegmentationResult(true, allReasons)\n    } else {\n        return new SegmentationResult(false) \n    }\n}\n\nfunction doesUserPassFilter(\n    filter: AudienceFilter,\n    audiences: Map<string, Audience>,\n    user: DVCPopulatedUser,\n    clientCustomData: JSON.Obj\n): SegmentationResult {\n    let isValid = true\n\n    if (filter.type === 'all') return new SegmentationResult(true, EVAL_REASON_DETAILS.ALL_USERS)\n    else if (filter.type === 'optIn') {\n            return new SegmentationResult(false)\n    } else if (filter.type === 'audienceMatch') {\n        if (!(filter as AudienceMatchFilter).isValid) {\n            isValid = false\n        } else {\n            return filterForAudienceMatch(filter as AudienceMatchFilter, audiences, user, clientCustomData)\n        }\n    } else if (!(filter instanceof UserFilter)) {\n        isValid = false\n    }\n\n    if (isValid) {\n        const userFilter = filter as UserFilter\n        if (userFilter.isValid) {\n            const subType = userFilter.subType\n            if (validSubTypes.includes(subType)) {\n                return filterFunctionsBySubtype(subType, user, userFilter, clientCustomData)\n            }\n        }\n    }\n\n    console.log(`[DevCycle] Warning: Invalid filter data ${filter}.\n        To leverage this new filter definition, please update to the latest version of the DevCycle SDK.`)\n    return new SegmentationResult(false)\n}\n\nfunction filterForAudienceMatch(\n    filter: AudienceMatchFilter,\n    configAudiences: Map<string, Audience>,\n    user: DVCPopulatedUser,\n    clientCustomData: JSON.Obj\n): SegmentationResult {\n    const audiences = getFilterAudiencesAsStrings(filter)\n    const comparator = filter.comparator\n    // Recursively evaluate every audience in the _audiences array\n    for (let i = 0; i < audiences.length; i++) {\n        if (!configAudiences.has(audiences[i])){\n            console.log(`\n            [DevCycle] Warning: Invalid audience referenced by audienceMatch filter.\n        `)\n            return new SegmentationResult(false)\n        }\n        const audience = configAudiences.get(audiences[i])\n        const result = _evaluateOperator(audience.filters, configAudiences, user, clientCustomData)\n        if (result.result) {\n            // If the user is in any of the audiences return early.\n            const matchResult = comparator === '='\n            const reasonDetails = matchResult \n                ? EVAL_REASON_DETAILS.AUDIENCE_MATCH + (result.reasonDetails ? ' -> ' + result.reasonDetails! : '')\n                : null\n            return new SegmentationResult(matchResult, reasonDetails)\n        }\n    }\n    // The user is not in any of the audiences.\n    const matchResult = comparator === '!='\n    const reasonDetails = matchResult ? EVAL_REASON_DETAILS.NOT_IN_AUDIENCE : null\n    return new SegmentationResult(matchResult, reasonDetails)\n}\n\nfunction filterFunctionsBySubtype(\n    subType: string,\n    user: DVCPopulatedUser,\n    filter: UserFilter,\n    clientCustomData: JSON.Obj\n): SegmentationResult {\n    if (subType === 'country') {\n        const result = _checkStringsFilter(user.country, filter)\n        return new SegmentationResult(result, result ? EVAL_REASON_DETAILS.COUNTRY : null)\n    } else if (subType === 'email') {\n        const result = _checkStringsFilter(user.email, filter)\n        return new SegmentationResult(result, result ? EVAL_REASON_DETAILS.EMAIL : null)\n    } else if (subType === 'user_id') {\n        const result = _checkStringsFilter(user.user_id, filter)\n        return new SegmentationResult(result, result ? EVAL_REASON_DETAILS.USER_ID : null)\n    } else if (subType === 'appVersion') {\n        const result = _checkVersionFilters(user.appVersion, filter)\n        return new SegmentationResult(result, result ? EVAL_REASON_DETAILS.APP_VERSION : null)\n    } else if (subType === 'platformVersion') {\n        const result = _checkVersionFilters(user.platformVersion, filter)\n        return new SegmentationResult(result, result ? EVAL_REASON_DETAILS.PLATFORM_VERSION : null)\n    } else if (subType === 'deviceModel') {\n        const result = _checkStringsFilter(user.deviceModel, filter)\n        return new SegmentationResult(result, result ? EVAL_REASON_DETAILS.DEVICE_MODEL : null)\n    } else if (subType === 'platform') {\n        const result = _checkStringsFilter(user.platform, filter)\n        return new SegmentationResult(result, result ? EVAL_REASON_DETAILS.PLATFORM : null)\n    } else if (subType === 'customData') {\n        if (!(filter instanceof CustomDataFilter)) {\n            throw new Error('Invalid filter data')\n        }\n        const result = _checkCustomData(user.getCombinedCustomData(), clientCustomData, filter as CustomDataFilter)\n        const reason = result ? `${EVAL_REASON_DETAILS.CUSTOM_DATA} -> ${(filter as CustomDataFilter).dataKey}` : null\n        return new SegmentationResult(result, reason)\n    } else {\n        return new SegmentationResult(false)\n    }\n}\n\nexport function convertToSemanticVersion(version: string): string {\n    const splitVersion = version.split('.')\n    if (splitVersion.length < 2) { splitVersion.push('0') }\n    if (splitVersion.length < 3) { splitVersion.push('0') }\n\n    for (let i = 0; i < splitVersion.length; i++) {\n        const value = splitVersion[i]\n        if (value === '') { splitVersion[i] = '0' }\n    }\n    return splitVersion.join('.')\n}\n\nexport function checkVersionValue(\n    filterVersion: string,\n    version: string | null,\n    operator: string\n): bool {\n    if (version && filterVersion.length > 0) {\n        const options: OptionsType = { zeroExtend: true, lexicographical: false }\n        const result = versionCompare(version, filterVersion, options)\n        if (isNaN(result)) {\n            return false\n        } else if (result === 0 && includes(operator, '=')) {\n            return true\n        } else if (result === 1 && includes(operator, '>')) {\n            return true\n        } else if (result === -1 && includes(operator, '<')) {\n            return true\n        }\n    }\n\n    return false\n}\n\nexport function checkVersionFilter(\n    version: string | null,\n    filterVersions: string[],\n    operator: string\n): bool {\n    if (!version) {\n        return false\n    }\n\n    let parsedVersion = version\n    let parsedOperator = operator\n\n    let not = false\n    if (parsedOperator === '!=') {\n        parsedOperator = '='\n        not = true\n    }\n\n    let parsedFilterVersions = filterVersions\n    if (parsedOperator !== '=') {\n        // remove any non-number and . characters, and remove everything after a hyphen\n        // eg. 1.2.3a-b6 becomes 1.2.3\n        const regex1 = new RegExp('[^(\\\\d|.|\\\\-)]', 'g')\n        const regex2 = new RegExp('-.*', 'g')\n        parsedVersion = replace(replace(parsedVersion, regex1, ''), regex2, '')\n\n        const mappedFilterVersions: string[] = []\n        // Replace Array.map(), because you can't access captured data in a closure\n        for (let i = 0; i < filterVersions.length; i++) {\n            mappedFilterVersions.push(replace(replace(filterVersions[i], regex1, ''), regex2, ''))\n        }\n        parsedFilterVersions = mappedFilterVersions\n    }\n\n    parsedVersion = convertToSemanticVersion(parsedVersion)\n\n    let passed = false\n    // Replace Array.some(), because you can't access captured data in a closure\n    for (let i = 0; i < parsedFilterVersions.length; i++) {\n        if (checkVersionValue(parsedFilterVersions[i], parsedVersion, operator)) {\n            passed = true\n            break\n        }\n    }\n\n    return !not ? passed : !passed\n}\n\nexport function _checkNumberFilter(num: f64, filterNums: f64[], operator: string | null): bool {\n    if (operator && isString(operator)) {\n        if (operator === 'exist') {\n            return !isNaN(num)\n        } else if (operator === '!exist') {\n            return isNaN(num)\n        }\n    }\n\n    if (isNaN(num)) {\n        return false\n    }\n\n    if (operator === '!=') {\n        let passesFilter = true\n        for (let i = 0; i < filterNums.length; i++) {\n            const filterNum = filterNums[i]\n            if (isNaN(filterNum) || num === filterNum) {\n                passesFilter = false\n            }\n        }\n        return passesFilter\n    }\n\n    // replace filterNums.some() logic\n    let someValue = false\n    for (let i = 0; i < filterNums.length; i++) {\n        const filterNum = filterNums[i]\n        if (isNaN(filterNum)) {\n            continue\n        }\n\n        if (operator === '=') {\n            someValue = num === filterNum\n        } else if (operator === '>') {\n            someValue = num > filterNum\n        } else if (operator === '>=') {\n            someValue = num >= filterNum\n        } else if (operator === '<') {\n            someValue = num < filterNum\n        } else if (operator === '<=') {\n            someValue = num <= filterNum\n        } else {\n            continue\n        }\n\n        if (someValue) {\n            return true\n        }\n    }\n    return someValue\n}\n\nexport function checkNumbersFilterJSONValue(jsonValue: JSON.Value, filter: UserFilter): bool {\n    return _checkNumbersFilter(getF64FromJSONValue(jsonValue), filter)\n}\n\nfunction _checkNumbersFilter(number: f64, filter: UserFilter): bool {\n    const operator = filter.comparator\n    const values = filter.getNumberValues()\n    return _checkNumberFilter(number, values, operator)\n}\n\nexport function _checkStringsFilter(string: string | null, filter: UserFilter): bool {\n    const operator = filter.comparator\n    const values = filter.getStringValues()\n\n    if (operator === '=') {\n        return string !== null && values.includes(string)\n    } else if (operator === '!=') {\n        return string !== null && !values.includes(string)\n    } else if (operator === 'exist') {\n        return string !== null && string !== ''\n    } else if (operator === '!exist') {\n        return string === null || string === ''\n    } else if (operator === 'contain') {\n        return string !== null && !!findString(values, string)\n    } else if (operator === '!contain') {\n        return string === null || !findString(values, string)\n    } else if (operator === 'startWith') {\n        return string !== null && _checkValueStartsWith(string, values)\n    } else if (operator === '!startWith') {\n        return string === null || !_checkValueStartsWith(string, values)\n    } else if (operator === 'endWith') {\n        return string !== null && _checkValueEndsWith(string, values)\n    } else if (operator === '!endWith') {\n        return string === null || !_checkValueEndsWith(string, values)\n    } else {\n        return isString(string)\n    }\n}\n\nfunction _checkValueStartsWith(string: string, values: string[] | null): bool {\n    if(!values) return false\n    for (let i = 0; i < values.length; i++) {\n        if (stringStartsWith(string, values[i])) {\n            return true\n        }\n    }\n    return false\n}\nfunction _checkValueEndsWith(string: string, values: string[]| null): bool {\n    if(!values) return false\n    for (let i = 0; i < values.length; i++) {\n        if (stringEndsWith(string, values[i])) {\n            return true\n        }\n    }\n    return false\n}\n\nexport function _checkBooleanFilter(bool: bool, filter: UserFilter): bool {\n    const operator = filter.comparator\n    const values = filter.getBooleanValues()\n\n    if (operator === 'contain' || operator === '=') {\n        return isBoolean(bool) && values.includes(bool)\n    } else if (operator === '!contain' || operator === '!=') {\n        return isBoolean(bool) && !values.includes(bool)\n    } else if (operator === 'exist') {\n        return isBoolean(bool)\n    } else if (operator === '!exist') {\n        return !isBoolean(bool)\n    } else {\n        return false\n    }\n}\n\nexport function _checkVersionFilters(appVersion: string | null, filter: UserFilter): bool {\n    const operator = filter.comparator\n    const values = filter.getStringValues()\n    // dont need to do semver if they're looking for an exact match. Adds support for non semver versions.\n    if (operator === '=') {\n        return _checkStringsFilter(appVersion, filter)\n    } else {\n        return checkVersionFilter(appVersion, values, operator)\n    }\n}\n\nexport function _checkCustomData(data: JSON.Obj | null, clientCustomData: JSON.Obj, filter: CustomDataFilter): bool {\n    const operator = filter.comparator\n\n    let dataValue = data ? data.get(filter.dataKey) : null\n    if (dataValue === null) {\n        dataValue = clientCustomData.get(filter.dataKey)\n    }\n\n    if (operator === 'exist') {\n        return checkValueExists(dataValue)\n    } else if (operator === '!exist') {\n        return !checkValueExists(dataValue)\n    } else if (filter.dataKeyType === 'String' && dataValue && (dataValue.isString || dataValue.isNull)) {\n        if (dataValue.isNull) {\n            return _checkStringsFilter(null, filter)\n        } else {\n            const jsonStr = dataValue as JSON.Str\n            return _checkStringsFilter(jsonStr.valueOf(), filter)\n        }\n    } else if (filter.dataKeyType === 'Number'\n        && dataValue && (dataValue.isFloat || dataValue.isInteger)) {\n        return checkNumbersFilterJSONValue(dataValue, filter)\n    } else if (filter.dataKeyType === 'Boolean' && dataValue && dataValue.isBool) {\n        const boolValue = dataValue as JSON.Bool\n        return _checkBooleanFilter(boolValue.valueOf(), filter)\n    } else if (!dataValue && operator === '!=') {\n        return true\n    } else {\n        return false\n    }\n}\n\nexport function getFilterAudiences(filter: AudienceMatchFilter): JSON.Value[] {\n    const _audiences = filter._audiences\n\n    return _audiences.valueOf().reduce((accumulator, audience) => {\n        if (audience !== null) {\n            accumulator.push(audience)\n        }\n        return accumulator\n    }, [] as JSON.Value[])\n}\n\nexport function getFilterAudiencesAsStrings(filter: AudienceMatchFilter): string[] {\n    const jsonAudiences = getFilterAudiences(filter)\n\n    return jsonAudiences.reduce((accumulator, audience) => {\n        const str = audience.isString ? audience as JSON.Str : null\n        if (str) {\n            accumulator.push(str.valueOf())\n        }\n        return accumulator\n    }, [] as string[])\n}\n\nexport function getFilterValues(filter: UserFilter): JSON.Value[] {\n    const values = filter.values\n\n    return values.valueOf().reduce((accumulator, value) => {\n        if (value !== null) {\n            accumulator.push(value)\n        }\n        return accumulator\n    }, [] as JSON.Value[])\n}\n\n/**\n * Returns true if the given value is not a type we define as \"nonexistent\" (NaN, empty string etc.)\n * Used only for values we don't have a specific datatype for (eg. customData values)\n * If value has a datatype, use one of the type checkers above (eg. checkStringFilter)\n * NOTE: The use of Number.isNaN is required over the global isNaN as the check it performs is more specific\n */\nfunction checkValueExists(value: JSON.Value | null): bool {\n    if (!value) return false\n    const stringValue = value.isString ? value as JSON.Str : null\n    const floatValue = value.isFloat ? value as JSON.Float : null\n    const intValue = value.isInteger ? value as JSON.Integer : null\n    const boolValue = value.isBool ? value as JSON.Bool : null\n\n    return value !== null\n        && !!(stringValue || floatValue || intValue || boolValue)\n        && (!stringValue || stringValue.valueOf() !== '')\n        && (!floatValue || !isNaN(floatValue.valueOf()))\n        && (!intValue || !isNaN(intValue.valueOf()))\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getJSONObjFromJSON,\n    getJSONArrayFromJSON,\n    jsonArrFromValueArray,\n    jsonObjFromMap,\n    getJSONObjFromJSONOptional,\n    getStringFromJSONOptional,\n} from '../helpers/jsonHelpers'\nimport { FeatureV2 } from './featureV2'\nimport { PublicEnvironment, PublicProject, Variable} from './configBody'\nimport { Audience } from './target'\n\nexport class ConfigBodyV2 {\n    readonly project: PublicProject\n    readonly audiences: Map<string, Audience>\n    readonly environment: PublicEnvironment\n    readonly features: FeatureV2[]\n    readonly variables: Variable[]\n    readonly etag: string | null\n    readonly clientSDKKey: string | null\n\n    private readonly _variableKeyMap: Map<string, Variable>\n    private readonly _variableIdMap: Map<string, Variable>\n    private readonly _variableIdToFeatureMap: Map<string, FeatureV2>\n\n    static fromUTF8(\n        configUTF8: Uint8Array,\n        etag: string | null = null,\n    ): ConfigBodyV2 {\n        const configJSON = JSON.parse(configUTF8)\n        if (!configJSON.isObj) {\n            throw new Error(\n                'generateBucketedConfig config param not a JSON Object',\n            )\n        }\n        const configJSONObj = configJSON as JSON.Obj\n        return new ConfigBodyV2(configJSONObj, etag)\n    }\n\n    static fromString(\n        configStr: string,\n        etag: string | null = null,\n    ): ConfigBodyV2 {\n        const configJSON = JSON.parse(configStr)\n        if (!configJSON.isObj) {\n            throw new Error(\n                'generateBucketedConfig config param not a JSON Object',\n            )\n        }\n        const configJSONObj = configJSON as JSON.Obj\n        return new ConfigBodyV2(configJSONObj, etag)\n    }\n\n    constructor(configJSONObj: JSON.Obj, etag: string | null = null) {\n        this.etag = etag\n        this.clientSDKKey = getStringFromJSONOptional(\n            configJSONObj,\n            'clientSDKKey'\n        )\n        this.project = new PublicProject(\n            getJSONObjFromJSON(configJSONObj, 'project'),\n        )\n\n        this.environment = new PublicEnvironment(\n            getJSONObjFromJSON(configJSONObj, 'environment'),\n        )\n\n        const featuresJSON = getJSONArrayFromJSON(\n            configJSONObj,\n            'features',\n        ).valueOf()\n        const features = new Array<FeatureV2>()\n        const _varIdToFeatureMap = new Map<string, FeatureV2>()\n        const _featureIdMap = new Map<string, FeatureV2>()\n\n        for (let i = 0; i < featuresJSON.length; i++) {\n            const feature = new FeatureV2(featuresJSON[i] as JSON.Obj)\n            features.push(feature)\n\n            if (!_featureIdMap.has(feature._id)) {\n                _featureIdMap.set(feature._id, feature)\n            }\n\n            for (let j = 0; j < feature.variations.length; j++) {\n                for (\n                    let k = 0;\n                    k < feature.variations[j].variables.length;\n                    k++\n                ) {\n                    if (\n                        !_varIdToFeatureMap.has(\n                            feature.variations[j].variables[k]._var,\n                        )\n                    ) {\n                        _varIdToFeatureMap.set(\n                            feature.variations[j].variables[k]._var,\n                            feature,\n                        )\n                    }\n                }\n            }\n        }\n        this.features = features\n        this._variableIdToFeatureMap = _varIdToFeatureMap\n\n        const audiencesJSON = getJSONObjFromJSONOptional(\n            configJSONObj,\n            'audiences',\n        )\n        const audiences = new Map<string, Audience>()\n        if (audiencesJSON) {\n            const audienceKeys = audiencesJSON.keys\n            for (let i = 0; i < audienceKeys.length; i++) {\n                const audience_id = audienceKeys[i]\n                const aud = audiencesJSON.get(audience_id)\n                audiences.set(audience_id, new Audience(aud as JSON.Obj))\n            }\n        }\n        this.audiences = audiences\n\n        const variablesJSON = getJSONArrayFromJSON(\n            configJSONObj,\n            'variables',\n        ).valueOf()\n        const variables = new Array<Variable>()\n        const _variableKeyMap = new Map<string, Variable>()\n        const _variableIdMap = new Map<string, Variable>()\n        for (let i = 0; i < variablesJSON.length; i++) {\n            const variable = new Variable(variablesJSON[i] as JSON.Obj)\n            variables.push(variable)\n            _variableKeyMap.set(variable.key, variable)\n            _variableIdMap.set(variable._id, variable)\n        }\n        this.variables = variables\n        this._variableKeyMap = _variableKeyMap\n        this._variableIdMap = _variableIdMap\n    }\n\n    stringify(): string {\n        const json: JSON.Obj = new JSON.Obj()\n        json.set('project', this.project)\n        json.set('environment', this.environment)\n        json.set('audiences', jsonObjFromMap(this.audiences))\n        json.set('features', jsonArrFromValueArray(this.features))\n        json.set('variables', jsonArrFromValueArray(this.variables))\n        if (this.clientSDKKey) {\n            json.set('clientSDKKey', this.clientSDKKey)\n        }\n        return json.stringify()\n    }\n\n    getVariableForId(variable_id: string): Variable | null {\n        return this._variableIdMap.has(variable_id)\n            ? this._variableIdMap.get(variable_id)\n            : null\n    }\n\n    getVariableForKey(variableKey: string): Variable | null {\n        return this._variableKeyMap.has(variableKey)\n            ? this._variableKeyMap.get(variableKey)\n            : null\n    }\n\n    getFeatureForVariableId(variable_id: string): FeatureV2 | null {\n        return this._variableIdToFeatureMap.has(variable_id)\n            ? this._variableIdToFeatureMap.get(variable_id)\n            : null\n    }\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nimport { Writer, Reader, Protobuf } from \"as-proto/assembly\";\nimport { DVCUser_PB } from \"./DVCUser_PB\";\nimport { VariableType_PB } from \"./VariableType_PB\";\n\nexport class VariableForUserParams_PB {\n  static encode(message: VariableForUserParams_PB, writer: Writer): void {\n    writer.uint32(10);\n    writer.string(message.sdkKey);\n\n    writer.uint32(18);\n    writer.string(message.variableKey);\n\n    writer.uint32(24);\n    writer.int32(message.variableType);\n\n    const user = message.user;\n    if (user !== null) {\n      writer.uint32(34);\n      writer.fork();\n      DVCUser_PB.encode(user, writer);\n      writer.ldelim();\n    }\n\n    writer.uint32(40);\n    writer.bool(message.shouldTrackEvent);\n  }\n\n  static decode(reader: Reader, length: i32): VariableForUserParams_PB {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new VariableForUserParams_PB();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sdkKey = reader.string();\n          break;\n\n        case 2:\n          message.variableKey = reader.string();\n          break;\n\n        case 3:\n          message.variableType = reader.int32();\n          break;\n\n        case 4:\n          message.user = DVCUser_PB.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.shouldTrackEvent = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  sdkKey: string;\n  variableKey: string;\n  variableType: VariableType_PB;\n  user: DVCUser_PB | null;\n  shouldTrackEvent: bool;\n\n  constructor(\n    sdkKey: string = \"\",\n    variableKey: string = \"\",\n    variableType: VariableType_PB = 0,\n    user: DVCUser_PB | null = null,\n    shouldTrackEvent: bool = false\n  ) {\n    this.sdkKey = sdkKey;\n    this.variableKey = variableKey;\n    this.variableType = variableType;\n    this.user = user;\n    this.shouldTrackEvent = shouldTrackEvent;\n  }\n}\n\nexport function encodeVariableForUserParams_PB(\n  message: VariableForUserParams_PB\n): Uint8Array {\n  return Protobuf.encode(message, VariableForUserParams_PB.encode);\n}\n\nexport function decodeVariableForUserParams_PB(\n  buffer: Uint8Array\n): VariableForUserParams_PB {\n  return Protobuf.decode<VariableForUserParams_PB>(\n    buffer,\n    VariableForUserParams_PB.decode\n  );\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nimport { Writer, Reader, Protobuf } from \"as-proto/assembly\";\nimport { NullableString } from \"./NullableString\";\nimport { NullableDouble } from \"./NullableDouble\";\nimport { NullableCustomData } from \"./NullableCustomData\";\n\nexport class DVCUser_PB {\n  static encode(message: DVCUser_PB, writer: Writer): void {\n    writer.uint32(10);\n    writer.string(message.userId);\n\n    const email = message.email;\n    if (email !== null) {\n      writer.uint32(18);\n      writer.fork();\n      NullableString.encode(email, writer);\n      writer.ldelim();\n    }\n\n    const name = message.name;\n    if (name !== null) {\n      writer.uint32(26);\n      writer.fork();\n      NullableString.encode(name, writer);\n      writer.ldelim();\n    }\n\n    const language = message.language;\n    if (language !== null) {\n      writer.uint32(34);\n      writer.fork();\n      NullableString.encode(language, writer);\n      writer.ldelim();\n    }\n\n    const country = message.country;\n    if (country !== null) {\n      writer.uint32(42);\n      writer.fork();\n      NullableString.encode(country, writer);\n      writer.ldelim();\n    }\n\n    const appBuild = message.appBuild;\n    if (appBuild !== null) {\n      writer.uint32(50);\n      writer.fork();\n      NullableDouble.encode(appBuild, writer);\n      writer.ldelim();\n    }\n\n    const appVersion = message.appVersion;\n    if (appVersion !== null) {\n      writer.uint32(58);\n      writer.fork();\n      NullableString.encode(appVersion, writer);\n      writer.ldelim();\n    }\n\n    const deviceModel = message.deviceModel;\n    if (deviceModel !== null) {\n      writer.uint32(66);\n      writer.fork();\n      NullableString.encode(deviceModel, writer);\n      writer.ldelim();\n    }\n\n    const customData = message.customData;\n    if (customData !== null) {\n      writer.uint32(74);\n      writer.fork();\n      NullableCustomData.encode(customData, writer);\n      writer.ldelim();\n    }\n\n    const privateCustomData = message.privateCustomData;\n    if (privateCustomData !== null) {\n      writer.uint32(82);\n      writer.fork();\n      NullableCustomData.encode(privateCustomData, writer);\n      writer.ldelim();\n    }\n  }\n\n  static decode(reader: Reader, length: i32): DVCUser_PB {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new DVCUser_PB();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.userId = reader.string();\n          break;\n\n        case 2:\n          message.email = NullableString.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.name = NullableString.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.language = NullableString.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.country = NullableString.decode(reader, reader.uint32());\n          break;\n\n        case 6:\n          message.appBuild = NullableDouble.decode(reader, reader.uint32());\n          break;\n\n        case 7:\n          message.appVersion = NullableString.decode(reader, reader.uint32());\n          break;\n\n        case 8:\n          message.deviceModel = NullableString.decode(reader, reader.uint32());\n          break;\n\n        case 9:\n          message.customData = NullableCustomData.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n\n        case 10:\n          message.privateCustomData = NullableCustomData.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  userId: string;\n  email: NullableString | null;\n  name: NullableString | null;\n  language: NullableString | null;\n  country: NullableString | null;\n  appBuild: NullableDouble | null;\n  appVersion: NullableString | null;\n  deviceModel: NullableString | null;\n  customData: NullableCustomData | null;\n  privateCustomData: NullableCustomData | null;\n\n  constructor(\n    userId: string = \"\",\n    email: NullableString | null = null,\n    name: NullableString | null = null,\n    language: NullableString | null = null,\n    country: NullableString | null = null,\n    appBuild: NullableDouble | null = null,\n    appVersion: NullableString | null = null,\n    deviceModel: NullableString | null = null,\n    customData: NullableCustomData | null = null,\n    privateCustomData: NullableCustomData | null = null\n  ) {\n    this.userId = userId;\n    this.email = email;\n    this.name = name;\n    this.language = language;\n    this.country = country;\n    this.appBuild = appBuild;\n    this.appVersion = appVersion;\n    this.deviceModel = deviceModel;\n    this.customData = customData;\n    this.privateCustomData = privateCustomData;\n  }\n}\n\nexport function encodeDVCUser_PB(message: DVCUser_PB): Uint8Array {\n  return Protobuf.encode(message, DVCUser_PB.encode);\n}\n\nexport function decodeDVCUser_PB(buffer: Uint8Array): DVCUser_PB {\n  return Protobuf.decode<DVCUser_PB>(buffer, DVCUser_PB.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nimport { Writer, Reader, Protobuf } from \"as-proto/assembly\";\n\nexport class NullableString {\n  static encode(message: NullableString, writer: Writer): void {\n    writer.uint32(10);\n    writer.string(message.value);\n\n    writer.uint32(16);\n    writer.bool(message.isNull);\n  }\n\n  static decode(reader: Reader, length: i32): NullableString {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new NullableString();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.value = reader.string();\n          break;\n\n        case 2:\n          message.isNull = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  value: string;\n  isNull: bool;\n\n  constructor(value: string = \"\", isNull: bool = false) {\n    this.value = value;\n    this.isNull = isNull;\n  }\n}\n\nexport function encodeNullableString(message: NullableString): Uint8Array {\n  return Protobuf.encode(message, NullableString.encode);\n}\n\nexport function decodeNullableString(buffer: Uint8Array): NullableString {\n  return Protobuf.decode<NullableString>(buffer, NullableString.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nimport { Writer, Reader, Protobuf } from \"as-proto/assembly\";\n\nexport class NullableDouble {\n  static encode(message: NullableDouble, writer: Writer): void {\n    writer.uint32(9);\n    writer.double(message.value);\n\n    writer.uint32(16);\n    writer.bool(message.isNull);\n  }\n\n  static decode(reader: Reader, length: i32): NullableDouble {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new NullableDouble();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.value = reader.double();\n          break;\n\n        case 2:\n          message.isNull = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  value: f64;\n  isNull: bool;\n\n  constructor(value: f64 = 0.0, isNull: bool = false) {\n    this.value = value;\n    this.isNull = isNull;\n  }\n}\n\nexport function encodeNullableDouble(message: NullableDouble): Uint8Array {\n  return Protobuf.encode(message, NullableDouble.encode);\n}\n\nexport function decodeNullableDouble(buffer: Uint8Array): NullableDouble {\n  return Protobuf.decode<NullableDouble>(buffer, NullableDouble.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nimport { Writer, Reader, Protobuf } from \"as-proto/assembly\";\nimport { CustomDataValue } from \"./CustomDataValue\";\n\nexport class NullableCustomData {\n  static encode(message: NullableCustomData, writer: Writer): void {\n    const value = message.value;\n    if (value !== null) {\n      const valueKeys = value.keys();\n      for (let i: i32 = 0; i < valueKeys.length; ++i) {\n        const valueKey = valueKeys[i];\n        writer.uint32(10);\n        writer.fork();\n        writer.uint32(10);\n        writer.string(valueKey);\n        writer.uint32(18);\n        writer.fork();\n        CustomDataValue.encode(value.get(valueKey), writer);\n        writer.ldelim();\n        writer.ldelim();\n      }\n    }\n\n    writer.uint32(16);\n    writer.bool(message.isNull);\n  }\n\n  static decode(reader: Reader, length: i32): NullableCustomData {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new NullableCustomData();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          let valueKey: string = \"\";\n          let valueValue: CustomDataValue | null = null;\n          let valueHasKey: bool = false;\n          let valueHasValue: bool = false;\n          for (\n            const end: usize = reader.ptr + reader.uint32();\n            reader.ptr < end;\n\n          ) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                valueKey = reader.string();\n                valueHasKey = true;\n                break;\n\n              case 2:\n                valueValue = CustomDataValue.decode(reader, reader.uint32());\n                valueHasValue = true;\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n            if (message.value === null) {\n              message.value = new Map<string, CustomDataValue>();\n            }\n            const value = message.value;\n            if (\n              value !== null &&\n              valueHasKey &&\n              valueHasValue &&\n              valueValue !== null\n            ) {\n              value.set(valueKey, valueValue);\n            }\n          }\n          break;\n\n        case 2:\n          message.isNull = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  value: Map<string, CustomDataValue>;\n  isNull: bool;\n\n  constructor(\n    value: Map<string, CustomDataValue> = new Map(),\n    isNull: bool = false\n  ) {\n    this.value = value;\n    this.isNull = isNull;\n  }\n}\n\nexport function encodeNullableCustomData(\n  message: NullableCustomData\n): Uint8Array {\n  return Protobuf.encode(message, NullableCustomData.encode);\n}\n\nexport function decodeNullableCustomData(\n  buffer: Uint8Array\n): NullableCustomData {\n  return Protobuf.decode<NullableCustomData>(buffer, NullableCustomData.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nimport { Writer, Reader, Protobuf } from \"as-proto/assembly\";\nimport { CustomDataType } from \"./CustomDataType\";\n\nexport class CustomDataValue {\n  static encode(message: CustomDataValue, writer: Writer): void {\n    writer.uint32(8);\n    writer.int32(message.type);\n\n    writer.uint32(16);\n    writer.bool(message.boolValue);\n\n    writer.uint32(25);\n    writer.double(message.doubleValue);\n\n    writer.uint32(34);\n    writer.string(message.stringValue);\n  }\n\n  static decode(reader: Reader, length: i32): CustomDataValue {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new CustomDataValue();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32();\n          break;\n\n        case 2:\n          message.boolValue = reader.bool();\n          break;\n\n        case 3:\n          message.doubleValue = reader.double();\n          break;\n\n        case 4:\n          message.stringValue = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  type: CustomDataType;\n  boolValue: bool;\n  doubleValue: f64;\n  stringValue: string;\n\n  constructor(\n    type: CustomDataType = 0,\n    boolValue: bool = false,\n    doubleValue: f64 = 0.0,\n    stringValue: string = \"\"\n  ) {\n    this.type = type;\n    this.boolValue = boolValue;\n    this.doubleValue = doubleValue;\n    this.stringValue = stringValue;\n  }\n}\n\nexport function encodeCustomDataValue(message: CustomDataValue): Uint8Array {\n  return Protobuf.encode(message, CustomDataValue.encode);\n}\n\nexport function decodeCustomDataValue(buffer: Uint8Array): CustomDataValue {\n  return Protobuf.decode<CustomDataValue>(buffer, CustomDataValue.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nimport { Writer, Reader, Protobuf } from \"as-proto/assembly\";\n\nexport class EvalReason_PB {\n  static encode(message: EvalReason_PB, writer: Writer): void {\n    writer.uint32(10);\n    writer.string(message.reason);\n\n    writer.uint32(18);\n    writer.string(message.details);\n\n    writer.uint32(26);\n    writer.string(message.targetId);\n  }\n\n  static decode(reader: Reader, length: i32): EvalReason_PB {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new EvalReason_PB();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.reason = reader.string();\n          break;\n\n        case 2:\n          message.details = reader.string();\n          break;\n\n        case 3:\n          message.targetId = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  reason: string;\n  details: string;\n  targetId: string;\n\n  constructor(\n    reason: string = \"\",\n    details: string = \"\",\n    targetId: string = \"\"\n  ) {\n    this.reason = reason;\n    this.details = details;\n    this.targetId = targetId;\n  }\n}\n\nexport function encodeEvalReason_PB(message: EvalReason_PB): Uint8Array {\n  return Protobuf.encode(message, EvalReason_PB.encode);\n}\n\nexport function decodeEvalReason_PB(buffer: Uint8Array): EvalReason_PB {\n  return Protobuf.decode<EvalReason_PB>(buffer, EvalReason_PB.decode);\n}\n","// Code generated by protoc-gen-as. DO NOT EDIT.\n// Versions:\n//   protoc-gen-as v1.3.0\n//   protoc        v5.29.3\n\nimport { Writer, Reader, Protobuf } from \"as-proto/assembly\";\nimport { NullableString } from \"./NullableString\";\nimport { EvalReason_PB } from \"./EvalReason_PB\";\nimport { VariableType_PB } from \"./VariableType_PB\";\n\nexport class SDKVariable_PB {\n  static encode(message: SDKVariable_PB, writer: Writer): void {\n    writer.uint32(10);\n    writer.string(message.id);\n\n    writer.uint32(16);\n    writer.int32(message.type);\n\n    writer.uint32(26);\n    writer.string(message.key);\n\n    writer.uint32(32);\n    writer.bool(message.boolValue);\n\n    writer.uint32(41);\n    writer.double(message.doubleValue);\n\n    writer.uint32(50);\n    writer.string(message.stringValue);\n\n    const evalReason = message.evalReason;\n    if (evalReason !== null) {\n      writer.uint32(58);\n      writer.fork();\n      NullableString.encode(evalReason, writer);\n      writer.ldelim();\n    }\n\n    const feature = message.feature;\n    if (feature !== null) {\n      writer.uint32(66);\n      writer.fork();\n      NullableString.encode(feature, writer);\n      writer.ldelim();\n    }\n\n    const eval = message.eval;\n    if (eval !== null) {\n      writer.uint32(74);\n      writer.fork();\n      EvalReason_PB.encode(eval, writer);\n      writer.ldelim();\n    }\n  }\n\n  static decode(reader: Reader, length: i32): SDKVariable_PB {\n    const end: usize = length < 0 ? reader.end : reader.ptr + length;\n    const message = new SDKVariable_PB();\n\n    while (reader.ptr < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n\n        case 2:\n          message.type = reader.int32();\n          break;\n\n        case 3:\n          message.key = reader.string();\n          break;\n\n        case 4:\n          message.boolValue = reader.bool();\n          break;\n\n        case 5:\n          message.doubleValue = reader.double();\n          break;\n\n        case 6:\n          message.stringValue = reader.string();\n          break;\n\n        case 7:\n          message.evalReason = NullableString.decode(reader, reader.uint32());\n          break;\n\n        case 8:\n          message.feature = NullableString.decode(reader, reader.uint32());\n          break;\n\n        case 9:\n          message.eval = EvalReason_PB.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  }\n\n  id: string;\n  type: VariableType_PB;\n  key: string;\n  boolValue: bool;\n  doubleValue: f64;\n  stringValue: string;\n  evalReason: NullableString | null;\n  feature: NullableString | null;\n  eval: EvalReason_PB | null;\n\n  constructor(\n    id: string = \"\",\n    type: VariableType_PB = 0,\n    key: string = \"\",\n    boolValue: bool = false,\n    doubleValue: f64 = 0.0,\n    stringValue: string = \"\",\n    evalReason: NullableString | null = null,\n    feature: NullableString | null = null,\n    eval: EvalReason_PB | null = null\n  ) {\n    this.id = id;\n    this.type = type;\n    this.key = key;\n    this.boolValue = boolValue;\n    this.doubleValue = doubleValue;\n    this.stringValue = stringValue;\n    this.evalReason = evalReason;\n    this.feature = feature;\n    this.eval = eval;\n  }\n}\n\nexport function encodeSDKVariable_PB(message: SDKVariable_PB): Uint8Array {\n  return Protobuf.encode(message, SDKVariable_PB.encode);\n}\n\nexport function decodeSDKVariable_PB(buffer: Uint8Array): SDKVariable_PB {\n  return Protobuf.decode<SDKVariable_PB>(buffer, SDKVariable_PB.decode);\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    getStringFromJSON,\n    getStringFromJSONOptional\n} from '../helpers/jsonHelpers'\n\nexport class PlatformData extends JSON.Obj {\n    readonly platform: string\n    readonly platformVersion: string\n    readonly sdkType: string\n    readonly sdkVersion: string\n    readonly sdkPlatform: string | null\n    readonly hostname: string | null\n\n    static fromUTF8(platformDataUTF8: Uint8Array): PlatformData {\n        const platformJSON = JSON.parse(platformDataUTF8)\n        if (!platformJSON.isObj) throw new Error('platformData param not a JSON Object')\n        const platformJSONObj = platformJSON as JSON.Obj\n        return new PlatformData(platformJSONObj)\n    }\n\n    static fromString(platformDataStr: string): PlatformData {\n        const platformJSON = JSON.parse(platformDataStr)\n        if (!platformJSON.isObj) throw new Error('platformData config param not a JSON Object')\n        const platformJSONObj = platformJSON as JSON.Obj\n        return new PlatformData(platformJSONObj)\n    }\n\n    constructor(platformJSONObj: JSON.Obj) {\n        super()\n\n        this.platform = getStringFromJSON(platformJSONObj, 'platform')\n        this.platformVersion = getStringFromJSON(platformJSONObj, 'platformVersion')\n        this.sdkType = getStringFromJSON(platformJSONObj, 'sdkType')\n        this.sdkVersion = getStringFromJSON(platformJSONObj, 'sdkVersion')\n        this.sdkPlatform = getStringFromJSONOptional(platformJSONObj, 'sdkPlatform')\n        this.hostname = getStringFromJSONOptional(platformJSONObj, 'hostname')\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('platform', this.platform)\n        json.set('platformVersion', this.platformVersion)\n        json.set('sdkType', this.sdkType)\n        json.set('sdkVersion', this.sdkVersion)\n        if (this.sdkPlatform) json.set('sdkPlatform', this.sdkPlatform)\n        if (this.hostname) json.set('hostname', this.hostname)\n        return json.stringify()\n    }\n}\n\nexport function testPlatformDataClass(dataStr: string): string {\n    const platformData = PlatformData.fromString(dataStr)\n    return platformData.stringify()\n}\n\nexport function testPlatformDataClassFromUTF8(dataStr: Uint8Array): string {\n    const platformData = PlatformData.fromUTF8(dataStr)\n    return platformData.stringify()\n}\n","class SortingArrayItem<T> {\n    value: string\n    entry: T\n}\n\nexport type SortingArray<T> = SortingArrayItem<T>[]\n\n/**\n * Sorts an array of objects that have been preformatted to the \"SortingArrayItem\" format which includes the original\n * item under the \"entry\" field, and the value to sort by under the \"value\" field. Returns a sorted array of \"entries\"\n * @param arr\n * @param direction - direction to sort by, either 'asc' or 'desc'\n */\nexport function sortObjectsByString<T>(arr: SortingArray<T>, direction: string): T[] {\n    const sorted = arr.sort((a, b) => {\n        let cursor = 0\n\n        // advance cursor while characters are the same\n        while (a.value.charCodeAt(cursor) === b.value.charCodeAt(cursor) && cursor < a.value.length) {\n            cursor++\n        }\n\n        // check if we're out of bounds on the first string\n        if (isNaN(a.value.charCodeAt(cursor))) {\n            // check if we're out of bounds on the second string\n            if (isNaN(b.value.charCodeAt(cursor))) {\n                // strings are the same length and all characters are identical\n                return 0\n            } else {\n                // second string is longer\n                return -1\n            }\n        }\n\n        if (isNaN(b.value.charCodeAt(cursor))) {\n            // first string is longer\n            return 1\n        }\n\n        // return subtraction of the current cursor position's character codes (which must be different)\n        return a.value.charCodeAt(cursor) - b.value.charCodeAt(cursor)\n    })\n\n    const result: T[] = []\n    for (let i = 0; i < sorted.length; i++) {\n        result.push(sorted[i].entry)\n    }\n\n    return direction === 'desc' ? result.reverse() : result\n}\n","export function REVERSE<T>(ptr: usize, len: usize): void {\n  if (len > 1) {\n    let\n      i: usize = 0,\n      tail: usize,\n      hlen: usize = len >> 1;\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (sizeof<T>() == 1) {\n        // TODO: Decide later: Does we need this fast path cases?\n        //\n        // if (len == 4) {\n        //   store<u32>(ptr, bswap(load<u32>(ptr)));\n        //   return;\n        // }\n        // if (len == 8) {\n        //   store<u64>(ptr, bswap(load<u64>(ptr)));\n        //   return;\n        // }\n        tail = len - 8;\n        while (i + 7 < hlen) {\n          let front = ptr + i;\n          let back  = ptr + tail - i;\n          let temp  = bswap(load<u64>(front));\n          store<u64>(front, bswap(load<u64>(back)));\n          store<u64>(back, temp);\n          i += 8;\n        }\n      }\n\n      if (sizeof<T>() == 2) {\n        tail = len - 2;\n        while (i + 1 < hlen) {\n          let front = ptr + (i << 1);\n          let back  = ptr + (tail - i << 1);\n          let temp  = rotr(load<u32>(back), 16);\n          store<u32>(back, rotr(load<u32>(front), 16));\n          store<u32>(front, temp);\n          i += 2;\n        }\n      }\n    }\n\n    tail = len - 1;\n    while (i < hlen) {\n      let front = ptr + (i << alignof<T>());\n      let back  = ptr + (tail - i << alignof<T>());\n      let temp  = load<T>(front);\n      store<T>(front, load<T>(back));\n      store<T>(back, temp);\n      i++;\n    }\n  }\n}\n\nexport function FILL<T>(\n  ptr: usize,\n  len: usize,\n  value: T,\n  start: isize,\n  end: isize\n): void {\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        ptr + <usize>start,\n        u8(value),\n        <usize>(end - start)\n      );\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL <= 1) {\n      if (isInteger<T>()) {\n        // @ts-ignore\n        if (value == <T>0 | value == <T>-1) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              u8(value),\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      } else if (isFloat<T>()) {\n        // for floating non-negative zeros we can use fast memory.fill\n        if ((sizeof<T>() == 4 && reinterpret<u32>(f32(value)) == 0) ||\n            (sizeof<T>() == 8 && reinterpret<u64>(f64(value)) == 0)) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              0,\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      }\n    }\n    for (; start < end; ++start) {\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\n    }\n  }\n}\n","import { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport { getI32FromJSONValue } from '../helpers/jsonHelpers'\n\nexport class EventQueueOptions extends JSON.Obj {\n    eventRequestChunkSize: i32 = 100\n    disableAutomaticEventLogging: bool = false\n    disableCustomEventLogging: bool = false\n\n    constructor(str: string) {\n        super()\n        const json = JSON.parse(str)\n        if (!json.isObj) throw new Error('EventQueueOptions not a JSON Object')\n        const jsonObj = json as JSON.Obj\n\n        const disableAutomaticEventLogging = jsonObj.getBool('disableAutomaticEventLogging')\n        if (disableAutomaticEventLogging) {\n            this.disableAutomaticEventLogging = disableAutomaticEventLogging.valueOf()\n        }\n\n        const disableCustomEventLogging = jsonObj.getBool('disableCustomEventLogging')\n        if (disableCustomEventLogging) {\n            this.disableCustomEventLogging = disableCustomEventLogging.valueOf()\n        }\n\n        const chunkSizeValue = jsonObj.get('eventRequestChunkSize')\n        if (chunkSizeValue) {\n            this.eventRequestChunkSize = getI32FromJSONValue(chunkSizeValue)\n        }\n        if (this.eventRequestChunkSize < 10) {\n            throw new Error(`eventRequestChunkSize: ${this.eventRequestChunkSize} must be larger than 10`)\n        } else if (this.eventRequestChunkSize > 10000) {\n            throw new Error(`eventRequestChunkSize: ${this.eventRequestChunkSize} must be smaller than 10000`)\n        }\n    }\n\n    stringify(): string {\n        const json = new JSON.Obj()\n        json.set('disableAutomaticEventLogging', this.disableAutomaticEventLogging)\n        json.set('disableCustomEventLogging', this.disableCustomEventLogging)\n        json.set('eventRequestChunkSize', this.eventRequestChunkSize)\n        return json.stringify()\n    }\n}\n\nexport function testEventQueueOptionsClass(optionsStr: string): string {\n    const options = new EventQueueOptions(optionsStr)\n    return options.stringify()\n}\n","import {\n    DVCEvent,\n    DVCUser,\n    DVCPopulatedUser,\n    DVCRequestEvent,\n    FlushPayload,\n    UserEventsBatchRecord,\n    EventQueueOptions,\n} from '../types'\nimport { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport { _getPlatformData } from '../managers/platformDataManager'\nimport {\n    AggEventQueue,\n    FeatureAggMap,\n    VariableAggMap,\n    VariationAggMap,\n} from './eventQueue'\n\n/**\n * This RequestPayloadManager Class handles all the logic for creating event flushing payloads,\n * and handling the onSuccess and onFailure logic for those payloads.\n */\nexport class RequestPayloadManager {\n    private pendingPayloads: Map<string, FlushPayload>\n    private readonly chunkSize: i32\n    private readonly clientUUID: string\n\n    constructor(options: EventQueueOptions, clientUUID: string) {\n        this.pendingPayloads = new Map<string, FlushPayload>()\n        this.chunkSize = options.eventRequestChunkSize\n        this.clientUUID = clientUUID\n    }\n\n    constructFlushPayloads(\n        userEventQueue: Map<string, UserEventsBatchRecord>,\n        aggEventQueue: AggEventQueue,\n    ): FlushPayload[] {\n        this.checkForFailedPayloads()\n\n        const records = this.constructBatchRecordsFromUserEvents(userEventQueue)\n        records.push(this.constructBatchRecordsFromAggEvents(aggEventQueue))\n        this.addEventRecordsToPendingPayloads(records)\n\n        this.updateFailedPayloads()\n        return this.pendingPayloads.values()\n    }\n\n    /**\n     * Generate UserEventsBatchRecord from User Event Queue\n     */\n    private constructBatchRecordsFromUserEvents(\n        userEventQueue: Map<string, UserEventsBatchRecord>,\n    ): UserEventsBatchRecord[] {\n        const records = new Array<UserEventsBatchRecord>()\n        const userEventQueueValues = userEventQueue.values()\n\n        for (let i = 0; i < userEventQueueValues.length; i++) {\n            records.push(userEventQueueValues[i])\n        }\n        return records\n    }\n\n    /**\n     * generate aggregated events by resolving aggregated event map into DVCEvents.\n     */\n    private constructBatchRecordsFromAggEvents(\n        aggEventQueue: AggEventQueue,\n    ): UserEventsBatchRecord {\n        const aggEventQueueKeys = aggEventQueue.keys()\n        const aggEvents: DVCRequestEvent[] = []\n\n        const platformData = _getPlatformData()\n        let user_id = 'aggregate'\n        if (platformData.hostname && this.clientUUID) {\n            user_id = `${this.clientUUID}@${platformData.hostname as string}`\n        } else if (platformData.hostname) {\n            user_id = platformData.hostname as string\n        }\n        const emptyFeatureVars = new Map<string, string>()\n\n        for (let i = 0; i < aggEventQueueKeys.length; i++) {\n            const type = aggEventQueueKeys[i]\n            const variableAggMap: VariableAggMap = aggEventQueue.get(type)\n            const variableFeatureVarAggMapKeys = variableAggMap.keys()\n\n            for (let y = 0; y < variableFeatureVarAggMapKeys.length; y++) {\n                const variableKey = variableFeatureVarAggMapKeys[y]\n                const featureVarAggMap: FeatureAggMap =\n                    variableAggMap.get(variableKey)\n\n                let value: f64 = NaN\n                if (featureVarAggMap.has('value')) {\n                    const varAggMap = featureVarAggMap.get('value')\n                    if (varAggMap.has('value')) {\n                        const evalReasonAggMap = varAggMap.get('value')\n                        if (evalReasonAggMap) {\n                            const evalReasonKeys = evalReasonAggMap.keys()\n                            for (let i = 0; i < evalReasonKeys.length; i++) {\n                                const evalReasonKey = evalReasonKeys[i]\n                                value = f64(evalReasonAggMap.get(evalReasonKey))\n                            }\n\n                            const evalMetadata = new JSON.Obj()\n                            evalMetadata.set('DEFAULT', value)\n\n                            const metaData = new JSON.Obj()\n                            metaData.set('_variation', 'DEFAULT')\n                            metaData.set('eval', evalMetadata)\n\n                            // Add aggVariableDefaulted Events\n                            const dvcEvent = new DVCEvent(\n                                type,\n                                variableKey,\n                                null,\n                                value,\n                                metaData,\n                            )\n                            aggEvents.push(\n                                new DVCRequestEvent(\n                                    dvcEvent,\n                                    user_id,\n                                    emptyFeatureVars,\n                                ),\n                            )\n                        } else {\n                            throw new Error('Missing evalReasonAggMap for value')\n                        }\n                    } else {\n                        throw new Error(\n                            'Missing sub value map to write aggVariableDefaulted events',\n                        )\n                    }\n                } else {\n                    const featureVarAggMapKeys = featureVarAggMap.keys()\n\n                    for (let x = 0; x < featureVarAggMapKeys.length; x++) {\n                        const _feature = featureVarAggMapKeys[x]\n                        const variationAggMap: VariationAggMap =\n                            featureVarAggMap.get(_feature)\n                        const variationAggMapKeys = variationAggMap.keys()\n\n                        for (let z = 0; z < variationAggMapKeys.length; z++) {\n                            const variationId = variationAggMapKeys[z]\n                            const evalReasonAggMap = variationAggMap.get(variationId)\n\n                            const evalMetadata = new JSON.Obj()\n\n                            value = 0\n                            if (evalReasonAggMap) {\n                                const evalReasonKeys = evalReasonAggMap.keys()\n                                for (let i = 0; i < evalReasonKeys.length; i++) {\n                                    const evalReasonKey = evalReasonKeys[i]\n                                    const evalReasonValue = f64(evalReasonAggMap.get(evalReasonKey))\n                                    evalMetadata.set(evalReasonKey, evalReasonValue)\n                                    value = value + evalReasonValue\n                                }\n                            }\n\n                            const metaData = new JSON.Obj()\n                            if (evalMetadata.stringify() !== '{}') {\n                                metaData.set('eval', evalMetadata)\n                            }\n                            metaData.set('_feature', _feature)\n                            metaData.set('_variation', variationId)\n\n                            // Add aggVariableEvaluated Events\n                            const dvcEvent = new DVCEvent(\n                                type,\n                                variableKey,\n                                null,\n                                value,\n                                metaData,\n                            )\n                            aggEvents.push(\n                                new DVCRequestEvent(\n                                    dvcEvent,\n                                    user_id,\n                                    emptyFeatureVars,\n                                ),\n                            )\n                        }\n                    }\n                }\n            }\n        }\n\n        // Generate defaulted aggregate user as our events APIs require a user / user_id\n        const dvcUser = new DVCPopulatedUser(\n            new DVCUser(\n                user_id,\n                null,\n                null,\n                null,\n                null,\n                NaN,\n                null,\n                null,\n                null,\n                null,\n            ),\n        )\n        return new UserEventsBatchRecord(dvcUser, aggEvents)\n    }\n\n    /**\n     * Find existing FlushPayload that is less than this.chunkSize, and isn't a failed payload\n     */\n    private getFlushPayload(): FlushPayload {\n        const payloads = this.pendingPayloads.values()\n\n        for (let i = 0; i < payloads.length; i++) {\n            const payload = payloads[i]\n            if (payload.status === 'failed') {\n                continue\n            }\n            if (payload.eventCount() < this.chunkSize) {\n                return payload\n            }\n        }\n\n        return new FlushPayload([])\n    }\n\n    /**\n     * Chunk up UserEventsBatchRecord's into payloads of size: this.chunkSize\n     */\n    private addEventRecordsToPendingPayloads(\n        records: UserEventsBatchRecord[],\n    ): void {\n        for (let i = 0; i < records.length; i++) {\n            const record: UserEventsBatchRecord = records[i]\n\n            while (record.events.length > 0) {\n                const flushPayload = this.getFlushPayload()\n                flushPayload.addBatchRecordForUser(record, this.chunkSize)\n                if (flushPayload.records.length > 0) {\n                    this.pendingPayloads.set(\n                        flushPayload.payloadId,\n                        flushPayload,\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * Mark pending payload as success, remove from pending payloads array.\n     */\n    markPayloadSuccess(payloadId: string): void {\n        if (!this.pendingPayloads.has(payloadId)) {\n            throw new Error(\n                `Could not find payloadId: ${payloadId} to mark as success`,\n            )\n        }\n\n        this.pendingPayloads.delete(payloadId)\n    }\n\n    markPayloadFailure(payloadId: string, retryable: boolean): void {\n        if (!this.pendingPayloads.has(payloadId)) {\n            throw new Error(\n                `Could not find payload: ${payloadId}, retryable: ${retryable} to mark as failure`,\n            )\n        }\n\n        if (retryable) {\n            const payload = this.pendingPayloads.get(payloadId)\n            payload.status = 'failed'\n        } else {\n            this.pendingPayloads.delete(payloadId)\n        }\n    }\n\n    /**\n     * Check that the pendingPayloads queue is empty or only contains retryable failed payloads\n     * before creating new batch of payloads.\n     */\n    checkForFailedPayloads(): void {\n        this.pendingPayloads.values().forEach((payload) => {\n            if (payload.status !== 'failed') {\n                throw new Error(\n                    `Request Payload: ${payload.payloadId} has not finished sending`,\n                )\n            }\n        })\n    }\n\n    /**\n     * Update all the failed payload statuses to sending after generating all new payloads to be sent.\n     */\n    updateFailedPayloads(): void {\n        this.pendingPayloads.values().forEach((payload) => {\n            if (payload.status === 'failed') {\n                payload.status = 'sending'\n            }\n        })\n    }\n\n    payloadEventCount(): i32 {\n        return this.pendingPayloads.values().reduce((count: i32, payload) => {\n            return count + payload.eventCount()\n        }, 0 as i32)\n    }\n}\n","import rng from \"./rng\";\nimport v4 from \"./v4\";\n\nexport default function uuid(): string {\n    return v4(rng());\n}\n","import stringify from \"./stringify\";\n\n// @ts-ignore: decorator\n@inline\nexport default function v4(rnds: Uint8Array): string {\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    unchecked(rnds[6] = (rnds[6] & 0x0f) | 0x40);\n    unchecked(rnds[8] = (rnds[8] & 0x3f) | 0x80);\n\n    return stringify(rnds);\n}\n","/**\n * Exposes methods to unit test different functionality by parsing string arguments into complex data structures\n */\n\nimport { JSON } from '@devcycle/assemblyscript-json/assembly'\nimport {\n    BucketedUserConfig, ConfigBody, ConfigBodyV2, CustomDataFilter,\n    DVCPopulatedUser,\n    DVCUser,\n    Rollout as PublicRollout,\n    Target as PublicTarget,\n    AudienceOperator, UserFilter,\n    decodeVariableForUserParams_PB,\n    encodeVariableForUserParams_PB,\n    decodeDVCUser_PB,\n    decodeSDKVariable_PB,\n    encodeSDKVariable_PB,\n    Audience,\n} from './types'\nimport {\n    _checkCustomData,\n    _checkVersionFilters,\n    _doesUserPassRollout,\n    _evaluateOperator,\n    checkNumbersFilterJSONValue\n} from './bucketing'\nimport { SortingArray, sortObjectsByString } from './helpers/arrayHelpers'\n\nexport {\n    testEventQueueOptionsClass,\n    testDVCEventClass,\n    testDVCRequestEventClass,\n    testPlatformDataClass,\n    testPlatformDataClassFromUTF8,\n} from './types'\n\nexport function testVariableForUserParams_PB(buffer: Uint8Array): Uint8Array {\n    const params = decodeVariableForUserParams_PB(buffer)\n    return encodeVariableForUserParams_PB(params)\n}\n\nexport function testDVCUser_PB(buffer: Uint8Array): Uint8Array {\n    const user = DVCUser.fromPBUser(decodeDVCUser_PB(buffer))\n    return user.toProtoBuf()\n}\n\nexport function testSDKVariable_PB(buffer: Uint8Array): Uint8Array {\n    const variable = decodeSDKVariable_PB(buffer)\n    return encodeSDKVariable_PB(variable)\n}\n\nexport function checkNumbersFilterFromJSON(number: string, filterStr: string): bool {\n    const filterJSON = JSON.parse(filterStr)\n    const parsedNumber = JSON.parse(number)\n    if (!filterJSON.isObj) throw new Error('checkNumbersFilterFromJSON filterStr param not a JSON Object')\n    const filter = new UserFilter(filterJSON as JSON.Obj)\n    return checkNumbersFilterJSONValue(parsedNumber, filter)\n}\n\nexport function checkVersionFiltersFromJSON(appVersion: string | null, filterStr: string): bool {\n    const filterJSON = JSON.parse(filterStr)\n    if (!filterJSON.isObj) throw new Error('checkVersionFiltersFromJSON filterStr param not a JSON Object')\n    const filter = new UserFilter(filterJSON as JSON.Obj)\n    return _checkVersionFilters(appVersion, filter)\n}\n\nexport function checkCustomDataFromJSON(data: string | null, filterStr: string): bool {\n    const filterJSON = JSON.parse(filterStr)\n    const dataJSON = JSON.parse(data || 'null')\n\n    if (!filterJSON.isObj) throw new Error('checkCustomDataFromJSON filterStr param not a JSON Object')\n    if (dataJSON && !dataJSON.isNull && !dataJSON.isObj) {\n        throw new Error('checkCustomDataFromJSON data param not a JSON Object')\n    }\n\n    const filter = new CustomDataFilter(filterJSON as JSON.Obj)\n    const dataJSONObj = dataJSON && dataJSON.isObj ? dataJSON as JSON.Obj : null\n    return _checkCustomData(dataJSONObj, new JSON.Obj(), filter)\n}\n\nexport function evaluateOperatorFromJSON(\n    operatorStr: string,\n    userStr: string,\n    audiencesStr: string | null = ''\n): string {\n    const operatorJSON = JSON.parse(operatorStr)\n    if (!operatorJSON.isObj) {\n        throw new Error('evaluateOperatorFromJSON operatorStr or userStr param not a JSON Object')\n    }\n    const audiences = new Map<string, Audience>()\n    if (audiencesStr !== '' && audiencesStr !== '{}') {\n        const audiencesJSON = JSON.parse(audiencesStr) as JSON.Obj\n        if (!audiencesJSON.isObj) {\n            throw new Error('evaluateOperatorFromJSON operatorStr or userStr param not a JSON Object')\n        }\n        const keys = audiencesJSON.keys\n        for (let i = 0; i < keys.length; i++) {\n            const aud = audiencesJSON.get(keys[i]) as JSON.Obj\n            audiences.set(keys[i], new Audience(aud))\n        }\n    }\n\n    const operator = new AudienceOperator(operatorJSON as JSON.Obj)\n    const user = DVCPopulatedUser.fromJSONString(userStr)\n    const resultReason = _evaluateOperator(operator, audiences, user, new JSON.Obj())\n    return resultReason.stringify()\n}\n\nexport function decideTargetVariationFromJSON(targetStr: string, boundedHash: f64): string {\n    const targetJSON = JSON.parse(targetStr)\n    if (!targetJSON.isObj) throw new Error('decideTargetVariationFromJSON targetStr param not a JSON Object')\n    const target = new PublicTarget(targetJSON as JSON.Obj)\n    return target.decideTargetVariation(boundedHash)\n}\n\nexport function doesUserPassRolloutFromJSON(rolloutStr: string | null, boundedHash: f64): bool {\n    const rolloutJSON = rolloutStr ? JSON.parse(rolloutStr) : null\n    if (rolloutJSON && !rolloutJSON.isObj) {\n        throw new Error('doesUserPassRolloutFromJSON rolloutStr param not a JSON Object')\n    }\n    const rollout = rolloutJSON ? new PublicRollout(rolloutJSON as JSON.Obj) : null\n    return _doesUserPassRollout(rollout, boundedHash)\n}\n\nexport function testConfigBodyClass(configStr: string, etag: string | null = null): string {\n    const config = ConfigBody.fromString(configStr, etag)\n    return config.stringify()\n}\n\nexport function testConfigBodyClassFromUTF8(configStr: Uint8Array, etag: string | null = null): string {\n    const config = ConfigBody.fromUTF8(configStr, etag)\n    return config.stringify()\n}\n\nexport function testConfigBodyV2Class(configStr: string, etag: string | null = null): string {\n    const config = ConfigBodyV2.fromString(configStr, etag)\n    return config.stringify()\n}\n\nexport function testConfigBodyV2ClassFromUTF8(configStr: Uint8Array, etag: string | null = null): string {\n    const config = ConfigBodyV2.fromUTF8(configStr, etag)\n    return config.stringify()\n}\n\nexport function testDVCUserClass(userStr: string): string {\n    const user = DVCUser.fromJSONString(userStr)\n    const populatedUser = new DVCPopulatedUser(user)\n    return populatedUser.stringify()\n}\n\nexport function testDVCUserClassFromUTF8(userStr: Uint8Array): string {\n    const user = DVCUser.fromUTF8(userStr)\n    const populatedUser = new DVCPopulatedUser(user)\n    return populatedUser.stringify()\n}\n\nexport function testBucketedUserConfigClass(userConfigStr: string): string {\n    const userConfig = BucketedUserConfig.fromJSONString(userConfigStr)\n    return userConfig.stringify()\n}\n\nexport function echoString(str: string): string {\n    return str\n}\n\nexport function echoUint8Array(data: Uint8Array): Uint8Array {\n    return data\n}\n\nexport function triggerAbort(): void {\n    throw new Error(\"Manual abort triggered\")\n}\n\nclass TestData {\n    key: string\n}\nexport function testSortObjectsByString(arr: SortingArray<TestData>, direction: string): TestData[] {\n    return sortObjectsByString<TestData>(arr, direction)\n}\n\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}